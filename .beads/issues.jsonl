{"id":"git_safety_guard-26f","title":"Define TypeScript destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous TypeScript constructs within heredoc bodies.\n\n## Why This Matters\n\nTypeScript heredocs (ts-node, tsx, npx ts-node) share JavaScript's risks plus:\n1. Type erasure can hide dangerous operations behind clean interfaces\n2. Decorators and metaprogramming can obscure behavior\n3. Many TypeScript users assume type safety means runtime safety (it doesn't)\n\n## Pattern Categories to Define\n\n### All JavaScript Patterns (Inherited)\nAll patterns from the JavaScript task apply here since TypeScript compiles to JavaScript.\n\n### TypeScript-Specific Patterns\n- any type casts that hide dangerous operations\n- Type assertions (as unknown as DangerousType)\n- @ts-ignore comments preceding dangerous code\n- Non-null assertions (!) on potentially null file handles\n\n### Decorator Abuse\n- Decorators that execute arbitrary code\n- Metadata reflection for dynamic execution\n- Class decorator patterns that modify behavior\n\n### Module System\n- Triple-slash directives loading external code\n- Type-only imports that get erased (import type)\n- Namespace merging that hides implementations\n\n## Implementation Notes\n\nTypeScript parsing requires tree-sitter-typescript which handles:\n- Generic type syntax\n- Type annotations\n- Decorators\n- JSX/TSX syntax variants\n\nConsider whether to parse TypeScript directly or check the JavaScript output.\n\n## Test Cases\n\nTest TypeScript-specific constructs:\n- Type assertions around dangerous calls\n- Decorator execution order\n- Generic type inference edge cases\n- Module augmentation\n\n## Dependencies\n\n- JavaScript patterns (shared base)\n- Pattern library structure design\n- ast-grep invocation layer\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:37:17.541114003-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:37:26.449207203-05:00","dependencies":[{"issue_id":"git_safety_guard-26f","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:37:34.25492655-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-26f","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:37:34.273731104-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-26f","depends_on_id":"git_safety_guard-mcf","type":"blocks","created_at":"2026-01-07T18:37:34.292923988-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-2cu","title":"Design false positive reduction strategy for string arguments","description":"## Objective\n\nDesign and implement strategies to dramatically reduce false positives in command blocking, especially for documentation and string arguments.\n\n## The Core Problem\n\nThe current regex-based guard suffers from context blindness. It sees:\n```\nbd create --description=\"Pattern blocks rm -rf commands\"\n```\n\nAnd matches \"rm -rf\" without understanding it's:\n1. Inside a quoted string\n2. An argument to a documentation tool\n3. NOT actually being executed\n\nThis creates severe workflow disruption when trying to document the very patterns we're blocking.\n\n## Why This Is Critical\n\nFalse positives are arguably WORSE than false negatives:\n- False negative: A dangerous command might slip through (rare, recoverable with backups)\n- False positive: Blocks legitimate work, forces workarounds, erodes trust in the tool\n- Repeated false positives lead users to disable the guard entirely\n\nThe guard must be TRUSTED to make intelligent decisions, not blindly pattern-match text.\n\n## Solution Approaches\n\n### 1. Command Structure Analysis (Primary Approach)\n\nParse the top-level command with tree-sitter-bash to understand structure:\n- Identify command name (bd, git, echo, etc.)\n- Identify argument positions (which are options vs values)\n- Identify quoting context (single, double, unquoted)\n- Only apply destructive patterns to EXECUTABLE positions\n\nExample analysis:\n```\nbd create --title=\"...\" --description=\"rm -rf pattern docs\"\n         ^command       ^option         ^string value (NOT executed)\n```\n\n### 2. Safe Command Registry\n\nMaintain a list of commands that take non-executable string arguments:\n- bd create, bd update (--description, --title)\n- git commit (-m), git tag (-m)\n- echo, printf (arguments are printed, not executed)\n- grep, rg (pattern arguments)\n\nFor these commands, don't apply destructive patterns to their string arguments.\n\n### 3. Execution Context Detection\n\nDistinguish between:\n- **Direct execution**: The string IS the command (`bash dangerous_cmd`)\n- **String literal**: The string is DATA passed to a command (`bd --desc=\"...\"`)\n- **Heredoc body**: Requires language-specific analysis (the whole point of ast-grep)\n\n### 4. Two-Phase Analysis\n\n1. **Quick structural check**: Parse command structure, identify context\n2. **Pattern matching**: Only apply patterns to executable contexts\n3. **Deep analysis**: For heredocs/complex cases, use ast-grep\n\n### 5. Confidence Scoring\n\nInstead of binary block/allow:\n- High confidence dangerous: Block immediately\n- Medium confidence: More thorough analysis\n- Low confidence (looks like documentation): Allow with optional warning\n\n## Implementation Strategy\n\n1. Add tree-sitter-bash as a dependency (if not using ast-grep CLI)\n2. Parse incoming commands to identify structure\n3. Create ExecutionContext enum: Direct, StringArg, Heredoc, PipeTarget\n4. Only apply destructive patterns when context is Direct, Heredoc, or PipeTarget\n5. For StringArg context with safe parent commands, skip pattern matching\n\n## Test Cases\n\nEssential false positive tests:\n- `bd create --description=\"This blocks rm -rf\"` → ALLOW\n- `git commit -m \"Fix rm -rf pattern matching\"` → ALLOW\n- `echo \"example: git reset --hard\"` → ALLOW\n- `grep \"rm -rf\" patterns.txt` → ALLOW\n\nEssential true positive tests (should still block):\n- `rm -rf /tmp/*` → BLOCK\n- `bash -c \"rm -rf /\"` → BLOCK\n- `python3 \u003c\u003c 'EOF'\n  import os; os.system(\"rm -rf /\")\n  EOF` → BLOCK (via heredoc analysis)\n\n## Success Criteria\n\n- Zero false positives for documentation workflows (bd, git commit -m)\n- Zero false positives for string pattern searches (grep, rg)\n- Maintain blocking of actual dangerous commands\n- Sub-5ms overhead for structural analysis\n\n## Dependencies\n\n- Heredoc detection strategy (shares parsing infrastructure)\n- May influence choice of ast-grep vs tree-sitter-rust\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:36:56.104462373-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:37:02.97601574-05:00","dependencies":[{"issue_id":"git_safety_guard-2cu","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:37:02.996636534-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2cu","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:37:03.01736459-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-2d4","title":"Define Perl destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous Perl constructs within heredoc bodies.\n\n## Why This Matters\n\nPerl heredocs are a classic attack vector because:\n1. Perl is often used for system administration scripts\n2. system(), exec(), backticks are core features\n3. Perl's \"TIMTOWTDI\" philosophy means many ways to do dangerous things\n4. Perl heredocs have complex quoting semantics\n\n## Pattern Categories to Define\n\n### Shell Execution\n- system() and exec() calls\n- Backtick commands `cmd`\n- qx// operator (equivalent to backticks)\n- open() with pipe syntax (open FH, \"|cmd\" or \"cmd|\")\n- IPC::Open2, IPC::Open3\n\n### Filesystem Operations\n- unlink() for file deletion\n- rmdir() for directory removal\n- File::Path::rmtree\n- rename() and link() for file manipulation\n\n### Dangerous Built-ins\n- eval() for code execution\n- do EXPR for executing files\n- require/use with dynamic paths\n- AUTOLOAD abuse\n\n### Regular Expression Dangers\n- /e modifier (eval in regex replacement)\n- Regex denial of service patterns\n- (?{code}) embedded code in regex\n\n### Process Control\n- kill() on processes\n- fork() and wait()\n- alarm() and signal handlers\n\n### Data Handling\n- Two-argument open() (security risk)\n- Reading from tainted input\n- LWP/HTTP::Tiny for network access\n\n## Implementation Notes\n\nPerl is notoriously hard to parse correctly. Challenges include:\n- Context-dependent syntax\n- Sigils ($, @, %, *)\n- Barewords vs strings vs subroutines\n- Regular expression complexity\n- Here-doc quoting variations\n\ntree-sitter-perl exists but may have limitations for complex Perl.\n\n## Test Cases\n\nPerl-specific tests:\n- Various quoting mechanisms\n- Regex with embedded code\n- open() variants\n- Sigil interpolation\n\n## Dependencies\n\n- Pattern library structure design\n- ast-grep invocation layer\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:37:19.324205765-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:37:26.492349961-05:00","dependencies":[{"issue_id":"git_safety_guard-2d4","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:37:37.366046506-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2d4","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:37:37.385299864-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-2j3","title":"Research tree-sitter Rust bindings","description":"# Research tree-sitter Rust Bindings\n\n## Objective\nEvaluate direct tree-sitter integration as an alternative to ast-grep CLI.\n\n## Background\ntree-sitter is the underlying parsing library used by ast-grep. Using it directly could offer:\n- Lower latency (no process spawning)\n- More control over parsing\n- Smaller dependency footprint (maybe)\n\nHowever, it may require more work to implement pattern matching.\n\n## Research Areas\n\n### 1. tree-sitter Rust Crate\n- API documentation and examples\n- How to load language grammars\n- Parsing API (parse string, get AST)\n- Query API for pattern matching\n\n### 2. Language Grammar Crates\n- tree-sitter-python\n- tree-sitter-bash\n- tree-sitter-javascript\n- tree-sitter-typescript\n- tree-sitter-ruby\n- How are grammars distributed? (separate crates vs bundled)\n\n### 3. Query Language\n- S-expression query syntax\n- Captures and predicates\n- Multiple patterns in one query\n- Performance of compiled queries\n\n### 4. Build Complexity\n- Compile time impact\n- Binary size impact\n- Cross-compilation considerations\n- Grammar file generation (if needed)\n\n### 5. Comparison with ast-grep\n- Feature parity\n- Development effort\n- Maintenance burden\n- Community support\n\n## Deliverables\n- Document comparing tree-sitter direct vs ast-grep\n- Code examples for both approaches\n- Recommendation with justification\n\n## Success Criteria\n- Clear understanding of trade-offs\n- Can make informed architecture decision\n- Have working proof-of-concept for both approaches","notes":"Research completed: tree-sitter v0.26.3 available with 11M+ downloads. Language grammars: tree-sitter-bash, tree-sitter-python, tree-sitter-javascript all at ^0.23.0. Ruby available, Perl uncertain.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:28:46.751144719-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:46:14.52717456-05:00"}
{"id":"git_safety_guard-49s","title":"Implement heredoc syntax detection (regex quick-check)","description":"# Implement Heredoc Syntax Detection (Regex Quick-Check)\n\n## Objective\nImplement a fast regex-based detector that identifies commands potentially containing heredoc content.\n\n## Background\nBefore we can scan heredoc content, we need to detect its presence. This is a two-stage approach:\n1. Quick regex check (this task) - fast, may have false positives\n2. Full extraction (separate task) - accurate, only runs if quick check triggers\n\n## Implementation Details\n\n### Quick-Check Patterns\nThe quick check should match common heredoc indicators:\n\n```rust\n// Patterns to detect heredoc presence\nstatic HEREDOC_QUICK_PATTERNS: \u0026[\u0026str] = \u0026[\n    r\"\u003c\u003c[-~]?\\s*['\\\"]?\\w+['\\\"]?\",  // \u003c\u003c EOF, \u003c\u003c- 'EOF', \u003c\u003c~ \"END\"\n    r\"\u003c\u003c\u003c\\s*['\\\"]\",                 // \u003c\u003c\u003c \"here string\"\n    r\"-c\\s+['\\\"]\",                  // python -c \"code\", bash -c 'code'\n    r\"-e\\s+['\\\"]\",                  // node -e \"code\", perl -e 'code'\n];\n```\n\n### Integration Point\nAdd to the main processing pipeline after quick-reject but before pattern matching:\n\n```rust\nfn process_command(cmd: \u0026str) -\u003e Decision {\n    // Existing quick-reject (no git/rm)\n    if quick_reject(cmd) \u0026\u0026 global_quick_reject(cmd) {\n        return Decision::Allow;\n    }\n    \n    // NEW: Check for potential heredoc content\n    if has_potential_heredoc(cmd) {\n        if let Some(reason) = scan_heredoc_content(cmd) {\n            return Decision::Deny(reason);\n        }\n    }\n    \n    // Continue with existing pattern matching...\n}\n```\n\n### Performance Requirements\n- Quick check must complete in \u003c 0.5ms\n- Should not allocate on the hot path\n- Use lazy-compiled static patterns\n\n### False Positive Tolerance\n- Quick check can have false positives (triggers full scan unnecessarily)\n- Quick check must NOT have false negatives (miss actual heredocs)\n- Full scan will handle false positives gracefully\n\n## Files to Modify\n- src/packs/mod.rs or new src/heredoc/mod.rs\n- src/main.rs (pipeline integration)\n\n## Testing\n- Test each heredoc variant is detected\n- Test non-heredoc commands don't trigger\n- Benchmark quick check performance\n\n## Dependencies\n- Design: heredoc detection strategy (git_safety_guard-o15)\n- ADR approved (git_safety_guard-5ib)\n\n## Success Criteria\n- All heredoc variants from design doc are detected\n- Quick check adds \u003c 0.5ms to non-heredoc commands\n- Zero false negatives in test suite","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:30:59.514233315-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:30:59.514233315-05:00","dependencies":[{"issue_id":"git_safety_guard-49s","depends_on_id":"git_safety_guard-5ib","type":"blocks","created_at":"2026-01-07T18:31:05.994685018-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-4o8","title":"Create documentation for heredoc detection feature","description":"## Objective\n\nCreate comprehensive documentation for the heredoc detection feature, covering user configuration, pattern authoring, and security considerations.\n\n## Documentation Deliverables\n\n### 1. User Guide Updates\n\n#### README.md Updates\n- Add heredoc scanning to feature list\n- Document new command-line options (if any)\n- Update configuration examples\n\n#### Configuration Guide\n- How to enable/disable heredoc scanning\n- Language-specific configuration\n- Performance tuning options\n- Fallback behavior settings\n\n### 2. Pattern Authoring Guide\n\nNew document: `docs/patterns.md`\n\n#### Pattern Syntax\n- tree-sitter query syntax (if using queries)\n- ast-grep pattern syntax (if using ast-grep-core)\n- Examples for each supported language\n\n#### Adding New Patterns\n- Step-by-step guide\n- Testing requirements\n- Performance considerations\n- Review checklist\n\n#### Pattern Library Reference\n- Complete list of all patterns\n- What each pattern detects\n- Known limitations\n- False positive/negative notes\n\n### 3. Security Documentation\n\nNew document: `docs/security.md`\n\n#### Threat Model\n- Attack vectors heredoc detection addresses\n- Attack vectors explicitly out of scope\n- Assumptions and limitations\n\n#### Bypass Considerations\n- Known potential bypasses\n- Why certain bypasses are accepted\n- Defense in depth recommendations\n\n#### Incident Response\n- What to do if a command is wrongly blocked\n- What to do if a dangerous command gets through\n- How to report security issues\n\n### 4. Developer Documentation\n\n#### Architecture Overview\n- Pipeline flow diagram\n- Module responsibilities\n- Data flow through heredoc analysis\n\n#### API Documentation\n- Internal Rust API documentation (rustdoc)\n- Integration points for extending\n- Error handling patterns\n\n#### Contributing Guide Updates\n- How to add new language support\n- How to add new patterns\n- Testing requirements for contributions\n\n### 5. AGENTS.md Updates\n\nUpdate the AI agent guidelines:\n- New heredoc detection capabilities\n- How to test heredoc patterns\n- False positive handling guidance\n\n## Documentation Quality Requirements\n\n- All code examples must be tested\n- All configuration examples must be valid\n- Mermaid diagrams for complex flows\n- Cross-references between related docs\n- Version numbers where relevant\n\n## Dependencies\n\n- Feature implementation complete\n- Test suite passing\n- Performance benchmarks available\n- ADR finalized\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:40:41.014282391-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:40:53.349791375-05:00","dependencies":[{"issue_id":"git_safety_guard-4o8","depends_on_id":"git_safety_guard-8wt","type":"blocks","created_at":"2026-01-07T18:40:53.36819319-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-5ib","title":"Write architecture decision document (ADR)","description":"# Write Architecture Decision Document (ADR)\n\n## Objective\nSynthesize research findings into a formal Architecture Decision Record that guides implementation.\n\n## Background\nAfter completing research on ast-grep, tree-sitter, and design tasks, we need to document the chosen approach and rationale. This ADR will be the reference for all implementation work.\n\n## ADR Structure\n\n### 1. Title\n\"ADR-001: Heredoc Scanning Architecture\"\n\n### 2. Status\nProposed -\u003e Accepted -\u003e Implemented\n\n### 3. Context\n- Problem statement (heredoc bypass attacks)\n- Constraints (performance, dependencies, maintenance)\n- Options considered\n\n### 4. Decision\n- Chosen approach (ast-grep CLI vs library vs tree-sitter direct)\n- Pattern storage format\n- Integration points with existing dcg architecture\n\n### 5. Consequences\n- Benefits of chosen approach\n- Drawbacks and mitigations\n- Future considerations\n\n### 6. Technical Details\n- Dependency changes to Cargo.toml\n- New modules and their responsibilities\n- Data flow through the system\n- Configuration schema additions\n\n## Key Decisions to Document\n\n### Integration Approach\n- CLI invocation vs library\n- Sync vs async processing\n- Caching strategy\n\n### Language Support\n- Initial language set\n- Grammar distribution\n- Extension mechanism\n\n### Pattern Format\n- Hardcoded vs external\n- File format (YAML, TOML, custom)\n- Validation approach\n\n### Performance Strategy\n- Quick-reject optimizations\n- Lazy loading\n- Timeout handling\n\n### Error Handling\n- Parse failures\n- Unknown languages\n- Pattern match errors\n\n## Deliverables\n- ADR document in docs/adr/001-heredoc-scanning.md\n- Updated AGENTS.md with implementation notes\n- Diagram showing data flow\n\n## Dependencies\n- Research: ast-grep API (git_safety_guard-b45)\n- Research: tree-sitter bindings (git_safety_guard-2j3)\n- Design: heredoc detection (git_safety_guard-o15)\n- Design: language detection (git_safety_guard-jfj)\n- Design: pattern library (git_safety_guard-6sg)\n\n## Success Criteria\n- Clear, actionable decisions documented\n- All stakeholder concerns addressed\n- Implementation can proceed without ambiguity","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:30:31.162229073-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:30:31.162229073-05:00","dependencies":[{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:30:37.437715869-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:30:37.457081439-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-o15","type":"blocks","created_at":"2026-01-07T18:30:37.477144052-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-jfj","type":"blocks","created_at":"2026-01-07T18:30:37.496865872-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:30:37.516274063-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-boy","type":"blocks","created_at":"2026-01-07T18:39:09.196463586-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-6sg","title":"Design destructive pattern library structure","description":"# Design Destructive Pattern Library Structure\n\n## Objective\nDesign the structure and organization of language-specific destructive patterns for heredoc scanning.\n\n## Background\nEach supported language has its own idioms for destructive operations. We need a well-organized pattern library that:\n- Is maintainable and extensible\n- Integrates with the existing pack system\n- Provides clear documentation for each pattern\n\n## Pattern Categories by Language\n\n### Python Patterns\n- File system: os.remove, os.unlink, shutil.rmtree, pathlib.Path.unlink\n- Process execution: os.system, subprocess.run/call/Popen\n- Database: DROP TABLE, TRUNCATE (via string in execute())\n\n### Bash Patterns\n- File deletion: rm, unlink, shred\n- Git operations: git reset, git clean, git checkout (destructive forms)\n- System: reboot, shutdown, init\n\n### JavaScript/Node Patterns\n- File system: fs.rmSync, fs.unlinkSync, fs.rmdirSync\n- Process: child_process.exec, child_process.spawn\n- Database operations in strings\n\n### Ruby Patterns\n- FileUtils.rm_rf, File.delete, Dir.rmdir\n- system(), exec(), backticks\n- Database operations\n\n### Perl Patterns\n- unlink, rmdir, rmtree\n- system(), exec(), backticks\n- Database operations\n\n## Design Considerations\n\n### 1. Pattern Specification Format\nShould patterns be:\n- Hardcoded in Rust?\n- Loaded from YAML/TOML files?\n- ast-grep rule files?\n\nTrade-offs:\n- Hardcoded: Fast, type-safe, harder to update\n- External files: Flexible, slower to load, easier to contribute\n- Hybrid: Core patterns hardcoded, extensions in files\n\n### 2. Pattern Metadata\nEach pattern needs:\n- Unique ID\n- Language\n- ast-grep/tree-sitter pattern\n- Human-readable description\n- Severity level\n- False positive likelihood\n- Suggested alternative\n\n### 3. Pack Integration\nHow do heredoc patterns integrate with existing packs?\n- New pack category: heredoc.*?\n- Sub-patterns within existing packs?\n- Separate configuration section?\n\n### 4. Contextual Patterns\nSome patterns are only dangerous in context:\n- subprocess.run is fine for \"ls\", dangerous for \"rm\"\n- Need to check arguments, not just function calls\n- May require more complex pattern matching\n\n### 5. Allowlisting\nUsers need to allowlist legitimate uses:\n- Test files that exercise dangerous code paths\n- Documentation containing examples\n- CI scripts that intentionally clean up\n\n## Deliverables\n- Pattern specification format (schema)\n- Initial pattern inventory per language\n- Integration plan with pack system\n- Allowlist/exception mechanism design\n\n## Success Criteria\n- Clear, consistent pattern format\n- Coverage of top 10 dangerous patterns per language\n- Smooth integration with existing dcg architecture\n- Path for community contributions","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:30:05.921495349-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:30:05.921495349-05:00","dependencies":[{"issue_id":"git_safety_guard-6sg","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:30:14.503126907-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-6sg","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:30:14.524054168-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-8wt","title":"Create comprehensive test suite for heredoc detection","description":"## Objective\n\nCreate comprehensive test coverage for heredoc detection and AST-based pattern matching, including unit tests, integration tests, and bypass attempt tests.\n\n## Test Categories\n\n### 1. Unit Tests\n\n#### Heredoc Detection Tests\n- Bash heredoc variants: \u003c\u003cEOF, \u003c\u003c-EOF, \u003c\u003c\u003c, \u003c\u003c'EOF', \u003c\u003c\"EOF\"\n- Python multiline strings as heredocs: python3 -c '''...'''\n- Node.js: node -e '...', node \u003c\u003cEOF\n- Perl: perl -e '...', perl \u003c\u003c'END'\n- Ruby: ruby -e '...', ruby \u003c\u003c~RUBY\n\n#### Language Detection Tests\n- Detection from command prefix (python3, node, ruby, perl, bash)\n- Detection from shebang (#!/usr/bin/env python3)\n- Detection from content heuristics (import statements, require(), etc.)\n- Fallback behavior for unknown languages\n\n#### Pattern Matching Tests\n- Each destructive pattern per language\n- Each safe pattern (things that look dangerous but aren't)\n- Edge cases in quoting and escaping\n- Variable interpolation handling\n\n### 2. Integration Tests\n\n#### Pipeline Tests\n- Full flow from JSON input to block/allow decision\n- Heredoc commands correctly trigger deep analysis\n- Non-heredoc commands still use fast path\n- Performance within latency budget\n\n#### Error Handling Tests\n- Malformed heredoc syntax\n- Unparseable content (binary, corrupted)\n- Unknown languages fall back gracefully\n- Timeout handling\n\n### 3. Bypass Attempt Tests (Security Focus)\n\nThese are CRITICAL - they test the actual attack vectors we're trying to block.\n\n#### Encoding Bypasses\n- Base64 encoded commands in heredocs\n- Hex encoding\n- Unicode obfuscation\n- String concatenation to build dangerous strings\n\n#### Indirection Bypasses\n- Variable expansion: CMD=\"rm\"; ${CMD} -rf\n- Array expansion: arr=(rm -rf /); \"${arr[@]}\"\n- Command substitution: $(echo rm) -rf\n- Eval-based: eval \"dangerous command\"\n\n#### Language-Specific Bypasses\n- Python: __import__, exec(), compile()\n- JavaScript: eval(), Function(), require()\n- Ruby: send(), instance_eval(), Kernel.`\n- Perl: eval, do EXPR, qx//\n\n#### Heredoc Nesting\n- Heredoc containing another heredoc\n- Heredoc with escaped delimiters\n- Heredoc across multiple commands (pipelines)\n\n### 4. False Positive Tests\n\nEnsure we DON'T block legitimate uses:\n- Documentation containing command examples\n- Grep patterns searching for dangerous commands\n- Test files containing example commands\n- Config files with commented dangerous commands\n- bd create with descriptions about dangerous patterns\n\n### 5. Performance Tests\n\n- Latency benchmarks for various command types\n- Memory usage under load\n- Concurrent command checking\n- Large heredoc handling\n\n## Test Infrastructure\n\n### Test Data Directory\n```\ntests/\n  fixtures/\n    heredocs/\n      bash/\n      python/\n      javascript/\n      ruby/\n      perl/\n    bypass_attempts/\n    false_positives/\n```\n\n### Test Macros\n```rust\n// Test that a command is blocked\nassert_blocked!(\"python3 \u003c\u003c 'EOF'\\nimport os; os.system('rm -rf /')\\nEOF\");\n\n// Test that a command is allowed\nassert_allowed!(\"python3 \u003c\u003c 'EOF'\\nprint('hello')\\nEOF\");\n\n// Test specific pattern match\nassert_pattern_matches!(\"python\", \"os.system($CMD)\", \"os.system('rm -rf /')\");\n```\n\n## Success Criteria\n\n- 100% coverage of documented attack vectors\n- Zero false positives in false_positive test suite\n- All performance tests pass within budget\n- Clear documentation of what each test validates\n\n## Dependencies\n\n- Integration pipeline must be complete\n- All language patterns must be defined\n- Performance benchmarking infrastructure\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:40:09.282575411-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:40:16.193121871-05:00","dependencies":[{"issue_id":"git_safety_guard-8wt","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T18:40:16.212012296-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-b45","title":"Research ast-grep API and integration patterns","description":"# Research ast-grep API and Integration Patterns\n\n## Objective\nThoroughly understand ast-grep's capabilities, API, and integration options to make informed architecture decisions.\n\n## Background\nast-grep (https://ast-grep.github.io/) is a CLI tool and library for structural code search. It uses tree-sitter for parsing and provides a pattern matching language for AST nodes. We need to understand how to leverage it for detecting destructive patterns in heredoc content.\n\n## Research Areas\n\n### 1. CLI Interface\n- Command syntax for pattern matching\n- JSON output format (--json flag)\n- Language specification options\n- Performance characteristics (startup time, parsing speed)\n- Error handling and edge cases\n\n### 2. Pattern Language\n- Basic pattern syntax ($VAR for metavariables)\n- Pattern composition and nesting\n- Regex support within patterns\n- Multiple pattern matching\n- YAML rule files vs inline patterns\n\n### 3. Language Support\n- Which languages are supported out of the box?\n- How are languages detected/specified?\n- Can we add custom language support?\n- Tree-sitter grammar availability\n\n### 4. Library Integration (sg crate)\n- Is there a Rust library we can use directly?\n- API surface and documentation\n- Dependency graph and compile time impact\n- Memory usage patterns\n\n### 5. Performance Benchmarks\n- Time to parse small code snippets (10-100 lines)\n- Pattern matching overhead\n- Comparison: CLI invocation vs library calls\n- Caching possibilities\n\n## Deliverables\n- Document summarizing findings\n- Code snippets demonstrating CLI and library usage\n- Performance benchmark results\n- Recommendation for integration approach\n\n## Success Criteria\n- Can confidently choose between CLI and library integration\n- Understand pattern language well enough to write destructive patterns\n- Have baseline performance numbers for decision making\n\n## Resources\n- https://ast-grep.github.io/\n- https://github.com/ast-grep/ast-grep\n- https://tree-sitter.github.io/tree-sitter/","notes":"Research completed: ast-grep-core v0.40.4 available on crates.io. Provides Pattern struct and Matcher trait. Depends on tree-sitter ^0.26.3. Intuitive pattern syntax like 'os.system($CMD)'. Recommended approach for dcg.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:28:24.602476336-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:46:12.030060139-05:00"}
{"id":"git_safety_guard-beq","title":"Define Python destructive patterns for heredoc scanning","description":"# Define Python Destructive Patterns for Heredoc Scanning\n\n## Objective\nCreate ast-grep/tree-sitter patterns to detect destructive operations in Python heredoc content.\n\n## Background\nPython offers many ways to perform destructive operations. We need comprehensive patterns that catch common attack vectors while minimizing false positives.\n\n## Patterns to Implement\n\n### 1. File System Operations\n\n**Direct file deletion:**\n- os.remove(path)\n- os.unlink(path)\n- pathlib.Path(path).unlink()\n- shutil.rmtree(path)\n- shutil.move() when destination exists\n\n**ast-grep pattern examples:**\n```yaml\nid: python-os-remove\nlanguage: python\nrule:\n  pattern: os.remove($PATH)\n  message: \"os.remove() deletes files - verify path is safe\"\n\nid: python-shutil-rmtree  \nlanguage: python\nrule:\n  pattern: shutil.rmtree($PATH)\n  message: \"shutil.rmtree() recursively deletes directories\"\n```\n\n### 2. Command Execution\n\n**Shell commands:**\n- os.system(cmd)\n- os.popen(cmd)\n- subprocess.run(cmd, shell=True)\n- subprocess.call(cmd, shell=True)\n- subprocess.Popen(cmd, shell=True)\n\n**ast-grep patterns:**\n```yaml\nid: python-os-system\nlanguage: python\nrule:\n  pattern: os.system($CMD)\n  message: \"os.system() executes shell commands\"\n\nid: python-subprocess-shell\nlanguage: python\nrule:\n  any:\n    - pattern: subprocess.run($$$, shell=True, $$$)\n    - pattern: subprocess.call($$$, shell=True, $$$)\n    - pattern: subprocess.Popen($$$, shell=True, $$$)\n  message: \"subprocess with shell=True executes arbitrary commands\"\n```\n\n### 3. Code Execution\n\n**Dynamic execution:**\n- exec(code)\n- eval(code)\n- compile() + exec()\n\n### 4. Database Operations\n\n**Destructive SQL:**\n- cursor.execute(\"DROP ...\")\n- cursor.execute(\"TRUNCATE ...\")\n- cursor.execute(\"DELETE FROM ... WHERE 1=1\")\n\nNote: These require checking string content, which is harder.\n\n### 5. Network/Download and Execute\n\n**Dangerous patterns:**\n- urllib.request.urlopen() + exec()\n- requests.get() + exec()\n\n## Pattern File Location\n- src/heredoc/patterns/python.yml\n- Or embedded in Rust code\n\n## Severity Levels\n- Critical: os.system, subprocess with shell, exec/eval\n- High: shutil.rmtree, os.remove\n- Medium: subprocess without shell (less dangerous)\n\n## False Positive Mitigation\n- Don't flag imports alone (import os is fine)\n- Consider context (test files, documentation)\n- Allow configuration to disable specific patterns\n\n## Testing\n- Test each pattern matches its target\n- Test patterns don't match safe code\n- Test edge cases (different import styles, aliases)\n\n## Dependencies\n- Design: pattern library structure (git_safety_guard-6sg)\n- ast-grep invocation (git_safety_guard-f4f)\n\n## Success Criteria\n- Cover top 10 dangerous Python patterns\n- Reasonable false positive rate (\u003c5%)\n- Patterns validated against real-world code","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:32:51.428196157-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:32:51.428196157-05:00","dependencies":[{"issue_id":"git_safety_guard-beq","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:34:20.583247557-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-beq","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:34:20.601617242-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-boy","title":"Evaluate embedded Rust crates vs external binaries for AST analysis","description":"## Objective\n\nEmbed structural analysis directly in the dcg binary using Rust crates rather than shelling out to external tools.\n\n## Architecture Decision\n\n**DECISION: Embed tree-sitter and ast-grep-core in Rust binary**\n\n### Why Not External Binaries?\n\nExternal process invocation (ripgrep CLI, ast-grep CLI) has unacceptable overhead:\n- Process spawn: 5-20ms\n- IPC serialization: 1-5ms\n- Output parsing: 1-2ms\n- Total: 10-50ms per command\n\nSince dcg runs on EVERY bash command, this latency is unacceptable. Users would notice slowdown.\n\n### Why Embedded Rust Crates?\n\n1. **tree-sitter** is available as a Rust crate with excellent performance\n2. **ast-grep is written in Rust** - we may be able to use ast-grep-core directly\n3. **Language grammars** are available as Rust crates (tree-sitter-bash, etc.)\n4. **Sub-millisecond latency** when everything is compiled in\n5. **Single binary** - no \"install ast-grep\" requirement\n\n### Implementation Strategy\n\n#### Phase 1: tree-sitter Integration\n```toml\n[dependencies]\ntree-sitter = \"0.22\"\ntree-sitter-bash = \"0.21\"\ntree-sitter-python = \"0.21\"\ntree-sitter-javascript = \"0.21\"\n# ... etc\n```\n\n#### Phase 2: Pattern Matching\n\nTwo options:\n\n**Option A: tree-sitter Queries**\nUse tree-sitter's built-in query language (S-expressions):\n```scheme\n(command\n  name: (command_name) @cmd\n  argument: (word) @arg\n  (#eq? @cmd \"rm\")\n  (#match? @arg \"-rf\"))\n```\n\nPros: Built into tree-sitter, well-documented\nCons: Verbose, less expressive than ast-grep patterns\n\n**Option B: ast-grep-core Crate**\nIf ast-grep publishes a library crate, use it:\n```rust\nuse ast_grep_core::{Pattern, Matcher};\n\nlet pattern = Pattern::new(\"os.system($CMD)\")?;\nlet matches = pattern.find_all(\u0026python_ast);\n```\n\nPros: More expressive patterns, proven matching logic\nCons: May not be published as separate crate, may need vendoring\n\n**Option C: Vendor ast-grep Code**\nIf ast-grep-core isn't available as a crate:\n1. Clone ast-grep repo\n2. Extract relevant modules (pattern matching, not CLI)\n3. Vendor into our codebase\n4. Maintain minimal fork\n\nPros: Full control\nCons: Maintenance burden\n\n#### Recommendation: Try in order A → B → C\n\n1. Start with tree-sitter queries - simplest, no extra deps\n2. If queries are too limiting, try ast-grep-core crate\n3. If not available, vendor minimal ast-grep code\n\n### Performance Budget\n\nTarget latency for heredoc analysis:\n- Heredoc detection (regex): \u003c0.5ms\n- Content extraction: \u003c0.1ms\n- tree-sitter parse: \u003c2ms (for typical heredoc size)\n- Pattern matching: \u003c1ms\n- **Total: \u003c5ms worst case**\n\n### Binary Size Considerations\n\nEach tree-sitter grammar adds ~500KB-2MB to binary size.\n6 languages × 1MB average = ~6MB added\n\nMitigation:\n- Compile grammars with size optimization\n- Consider optional features (--features python,bash,js)\n- Default: most common languages (bash, python, js)\n- Extended: all languages\n\n### Research Tasks Update\n\nThis decision affects:\n- git_safety_guard-b45: Research should focus on ast-grep's Rust internals\n- git_safety_guard-2j3: This becomes primary focus - tree-sitter Rust bindings\n- git_safety_guard-5ib: ADR should document this embedded approach\n\n## Success Criteria\n\n- All parsing embedded in single binary\n- No external tool dependencies\n- Heredoc analysis completes in \u003c5ms\n- Binary size increase \u003c10MB\n- Pattern matching expressiveness sufficient for all use cases\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:39:01.437304904-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:39:09.138923635-05:00","dependencies":[{"issue_id":"git_safety_guard-boy","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:39:09.157751983-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-boy","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:39:09.175608651-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-du4","title":"Implement language detection from command context","description":"# Implement Language Detection from Command Context\n\n## Objective\nImplement the language detection logic that determines which parser/patterns to use for heredoc content.\n\n## Background\nBased on the design (git_safety_guard-jfj), implement the multi-source language detection:\n1. Command prefix lookup\n2. Shebang detection\n3. Content heuristics (fallback)\n\n## Implementation Details\n\n### Language Enum\n\n```rust\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum Language {\n    Python,\n    Bash,\n    JavaScript,\n    TypeScript,\n    Ruby,\n    Perl,\n    Php,\n    Unknown,\n}\n\nimpl Language {\n    /// Get the tree-sitter/ast-grep language identifier\n    pub fn grammar_name(\u0026self) -\u003e Option\u003c\u0026'static str\u003e {\n        match self {\n            Self::Python =\u003e Some(\"python\"),\n            Self::Bash =\u003e Some(\"bash\"),\n            Self::JavaScript =\u003e Some(\"javascript\"),\n            Self::TypeScript =\u003e Some(\"typescript\"),\n            Self::Ruby =\u003e Some(\"ruby\"),\n            Self::Perl =\u003e Some(\"perl\"),\n            Self::Php =\u003e Some(\"php\"),\n            Self::Unknown =\u003e None,\n        }\n    }\n}\n```\n\n### Command Prefix Mapping\n\n```rust\nstatic COMMAND_LANGUAGE_MAP: LazyLock\u003cHashMap\u003c\u0026'static str, Language\u003e\u003e = LazyLock::new(|| {\n    let mut m = HashMap::new();\n    // Python\n    m.insert(\"python\", Language::Python);\n    m.insert(\"python3\", Language::Python);\n    m.insert(\"python2\", Language::Python);\n    // Bash/Shell\n    m.insert(\"bash\", Language::Bash);\n    m.insert(\"sh\", Language::Bash);\n    m.insert(\"zsh\", Language::Bash);\n    m.insert(\"ksh\", Language::Bash);\n    // JavaScript/Node\n    m.insert(\"node\", Language::JavaScript);\n    m.insert(\"nodejs\", Language::JavaScript);\n    // ... etc\n    m\n});\n\npub fn detect_from_command(cmd: \u0026str) -\u003e Option\u003cLanguage\u003e {\n    // Extract first word (command name)\n    let first_word = cmd.split_whitespace().next()?;\n    // Handle paths: /usr/bin/python3 -\u003e python3\n    let basename = first_word.rsplit('/').next()?;\n    COMMAND_LANGUAGE_MAP.get(basename).copied()\n}\n```\n\n### Shebang Detection\n\n```rust\npub fn detect_from_shebang(content: \u0026str) -\u003e Option\u003cLanguage\u003e {\n    let first_line = content.lines().next()?;\n    if !first_line.starts_with(\"#!\") {\n        return None;\n    }\n    // Parse: #!/usr/bin/env python3 -\u003e python3\n    // Parse: #!/bin/bash -\u003e bash\n    let interpreter = first_line\n        .strip_prefix(\"#!\")?\n        .trim()\n        .split_whitespace()\n        .last()?\n        .rsplit('/')\n        .next()?;\n    COMMAND_LANGUAGE_MAP.get(interpreter).copied()\n}\n```\n\n### Content Heuristics (Fallback)\n\n```rust\npub fn detect_from_content(content: \u0026str) -\u003e Option\u003cLanguage\u003e {\n    // Very basic heuristics - only if nothing else works\n    let lines: Vec\u003c\u0026str\u003e = content.lines().take(10).collect();\n    \n    // Python indicators\n    if lines.iter().any(|l| l.starts_with(\"import \") || l.starts_with(\"from \")) {\n        return Some(Language::Python);\n    }\n    \n    // JavaScript/Node indicators\n    if lines.iter().any(|l| l.contains(\"require(\") || l.contains(\"const \") || l.contains(\"let \")) {\n        return Some(Language::JavaScript);\n    }\n    \n    // Ruby indicators\n    if lines.iter().any(|l| l.starts_with(\"def \") \u0026\u0026 content.contains(\"end\")) {\n        return Some(Language::Ruby);\n    }\n    \n    None\n}\n```\n\n### Combined Detection\n\n```rust\npub fn detect_language(cmd: \u0026str, heredoc: \u0026HeredocContent) -\u003e Language {\n    // Priority 1: Command prefix\n    if let Some(lang) = detect_from_command(cmd) {\n        return lang;\n    }\n    \n    // Priority 2: Shebang\n    if let Some(lang) = detect_from_shebang(\u0026heredoc.content) {\n        return lang;\n    }\n    \n    // Priority 3: Content heuristics\n    if let Some(lang) = detect_from_content(\u0026heredoc.content) {\n        return lang;\n    }\n    \n    Language::Unknown\n}\n```\n\n## Files to Modify\n- New: src/heredoc/language.rs\n- src/heredoc/mod.rs\n\n## Testing\n- Test command prefix for all supported commands\n- Test shebang detection with various formats\n- Test content heuristics\n- Test fallback chain\n\n## Dependencies\n- Design: language detection heuristics (git_safety_guard-jfj)\n- Implement heredoc extraction (git_safety_guard-y4j)\n\n## Success Criteria\n- Correctly identify language in 95%+ of test cases\n- No panics on malformed input\n- Clear Language::Unknown for genuinely unknown cases","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:31:49.058497233-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:31:49.058497233-05:00","dependencies":[{"issue_id":"git_safety_guard-du4","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T18:31:58.308674617-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-du4","depends_on_id":"git_safety_guard-jfj","type":"blocks","created_at":"2026-01-07T18:31:58.326331058-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-e7m","title":"Integrate heredoc detection into main check pipeline","description":"## Objective\n\nIntegrate all heredoc detection components into the main dcg check pipeline, creating a seamless flow from command input to block/allow decision.\n\n## Pipeline Architecture\n\n```\nJSON Input → Parse → Quick Reject → Normalize →\n  → Heredoc Detection → [if heredoc found] →\n    → Extract Content → Detect Language → Parse with ast-grep →\n    → Apply Language Patterns → Block Decision\n  → [no heredoc] → Existing Pattern Matching → Block Decision\n```\n\n## Integration Points\n\n### 1. Entry Point Hook\n\nModify main.rs check flow to:\n1. After quick reject passes, check for heredoc indicators\n2. If heredoc found, branch to heredoc analysis path\n3. If no heredoc, continue with existing pattern matching\n4. Merge results from both paths\n\n### 2. Heredoc Detection Integration\n\nInsert heredoc detection before main pattern matching:\n```rust\nfn check_command(cmd: \u0026str) -\u003e CheckResult {\n    // Quick reject (existing)\n    if global_quick_reject(cmd) {\n        return CheckResult::allowed();\n    }\n\n    // NEW: Heredoc detection\n    if let Some(heredoc_result) = check_heredoc(cmd) {\n        if heredoc_result.blocked {\n            return heredoc_result;\n        }\n    }\n\n    // Existing pattern matching\n    REGISTRY.check_command(cmd, \u0026enabled_packs)\n}\n```\n\n### 3. Performance Budget\n\nTotal additional latency budget: 50ms worst case\n- Heredoc detection regex: \u003c2ms\n- Content extraction: \u003c1ms\n- Language detection: \u003c1ms\n- ast-grep invocation: \u003c40ms (external process)\n- Pattern matching: \u003c5ms\n\nIf ast-grep is too slow, fall back to regex patterns for the heredoc body.\n\n### 4. Feature Flag\n\nAdd heredoc scanning to pack system:\n- New pack: \"heredoc\" or integrate into \"core\"\n- Can be enabled/disabled via configuration\n- Default: enabled for new installations\n\n### 5. Error Handling\n\nGraceful degradation:\n- ast-grep not installed → warn, fall back to regex\n- ast-grep timeout → allow command, log warning\n- Parse error → allow command, log for debugging\n- Unknown language → use generic patterns or allow\n\n## Configuration\n\nNew config options:\n```toml\n[heredoc]\nenabled = true\ntimeout_ms = 50\nfallback_on_error = true\nlanguages = [\"python\", \"bash\", \"javascript\", \"typescript\", \"ruby\", \"perl\"]\n```\n\n## Testing Integration\n\nIntegration tests should cover:\n- Normal commands (no heredoc) still work fast\n- Heredoc commands get analyzed\n- Pattern matches in heredocs block correctly\n- Safe heredocs pass through\n- Error paths handle gracefully\n\n## Dependencies\n\n- Heredoc syntax detection\n- Content extraction\n- Language detection\n- ast-grep invocation layer\n- All language patterns\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:38:07.195631302-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:39:16.10840837-05:00","dependencies":[{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-49s","type":"blocks","created_at":"2026-01-07T18:39:24.471336629-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T18:39:24.491188224-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T18:39:24.509697502-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:39:24.528749381-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-2cu","type":"blocks","created_at":"2026-01-07T18:39:31.682050985-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-beq","type":"blocks","created_at":"2026-01-07T18:39:31.702476952-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-uau","type":"blocks","created_at":"2026-01-07T18:39:31.720255513-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-mcf","type":"blocks","created_at":"2026-01-07T18:39:31.739706774-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-26f","type":"blocks","created_at":"2026-01-07T18:39:31.75902245-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-mvh","type":"blocks","created_at":"2026-01-07T18:39:31.776348198-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-2d4","type":"blocks","created_at":"2026-01-07T18:39:31.795580477-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-f4f","title":"Implement ast-grep invocation layer","description":"# Implement ast-grep Invocation Layer\n\n## Objective\nCreate an abstraction layer for invoking ast-grep to scan heredoc content for destructive patterns.\n\n## Background\nBased on the ADR decision (CLI vs library), implement the chosen approach. This task assumes CLI invocation; if library is chosen, adjust accordingly.\n\n## Implementation Details (CLI Approach)\n\n### Scanner Trait\n\n```rust\npub trait HeredocScanner: Send + Sync {\n    /// Scan content for destructive patterns\n    fn scan(\u0026self, content: \u0026str, language: Language) -\u003e ScanResult;\n}\n\npub struct ScanResult {\n    pub blocked: bool,\n    pub matches: Vec\u003cPatternMatch\u003e,\n    pub scan_time_ms: u64,\n}\n\npub struct PatternMatch {\n    pub pattern_id: String,\n    pub reason: String,\n    pub line: usize,\n    pub column: usize,\n    pub matched_text: String,\n}\n```\n\n### ast-grep CLI Scanner\n\n```rust\npub struct AstGrepCliScanner {\n    /// Path to ast-grep binary\n    binary_path: PathBuf,\n    /// Pattern rules directory\n    rules_dir: PathBuf,\n    /// Timeout for scanning\n    timeout: Duration,\n}\n\nimpl AstGrepCliScanner {\n    pub fn new() -\u003e Result\u003cSelf, ScannerError\u003e {\n        // Find ast-grep binary\n        let binary_path = which::which(\"ast-grep\")\n            .or_else(|_| which::which(\"sg\"))\n            .map_err(|_| ScannerError::BinaryNotFound)?;\n        \n        Ok(Self {\n            binary_path,\n            rules_dir: default_rules_dir(),\n            timeout: Duration::from_millis(500),\n        })\n    }\n}\n\nimpl HeredocScanner for AstGrepCliScanner {\n    fn scan(\u0026self, content: \u0026str, language: Language) -\u003e ScanResult {\n        let lang_name = match language.grammar_name() {\n            Some(n) =\u003e n,\n            None =\u003e return ScanResult::empty(), // Unknown language, skip\n        };\n        \n        // Write content to temp file\n        let temp_file = tempfile::NamedTempFile::with_suffix(\u0026format!(\".{}\", lang_name))?;\n        std::fs::write(temp_file.path(), content)?;\n        \n        // Invoke ast-grep\n        let output = Command::new(\u0026self.binary_path)\n            .args([\n                \"scan\",\n                \"--lang\", lang_name,\n                \"--rule\", \u0026self.rules_dir.join(format!(\"{}.yml\", lang_name)).to_string_lossy(),\n                \"--json\",\n                temp_file.path().to_str().unwrap(),\n            ])\n            .timeout(self.timeout)\n            .output()?;\n        \n        // Parse JSON output\n        parse_ast_grep_output(\u0026output.stdout)\n    }\n}\n```\n\n### Library Scanner (Alternative)\n\n```rust\n#[cfg(feature = \"ast-grep-lib\")]\npub struct AstGrepLibScanner {\n    // Direct tree-sitter integration\n}\n```\n\n### Scanner Selection\n\n```rust\npub fn create_scanner() -\u003e Box\u003cdyn HeredocScanner\u003e {\n    // Try library first (if compiled in)\n    #[cfg(feature = \"ast-grep-lib\")]\n    if let Ok(scanner) = AstGrepLibScanner::new() {\n        return Box::new(scanner);\n    }\n    \n    // Fall back to CLI\n    if let Ok(scanner) = AstGrepCliScanner::new() {\n        return Box::new(scanner);\n    }\n    \n    // No scanner available\n    Box::new(NoOpScanner)\n}\n```\n\n## Files to Create\n- src/heredoc/scanner.rs\n- src/heredoc/ast_grep_cli.rs\n- (optional) src/heredoc/ast_grep_lib.rs\n\n## Error Handling\n- ast-grep binary not found -\u003e warn and disable scanning\n- Timeout -\u003e warn and allow command (fail-open)\n- Parse error -\u003e warn and allow command\n\n## Testing\n- Mock ast-grep output for unit tests\n- Integration test with real ast-grep if available\n- Test timeout handling\n- Test error recovery\n\n## Dependencies\n- ADR approved (git_safety_guard-5ib)\n- Language detection (git_safety_guard-du4)\n\n## Success Criteria\n- Scanner successfully invokes ast-grep\n- JSON output correctly parsed\n- Graceful degradation when ast-grep unavailable\n- Timeout handling prevents hangs","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:32:24.313325332-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:32:24.313325332-05:00","dependencies":[{"issue_id":"git_safety_guard-f4f","depends_on_id":"git_safety_guard-5ib","type":"blocks","created_at":"2026-01-07T18:32:32.909572665-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-f4f","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T18:32:32.929896409-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-jfj","title":"Design language detection heuristics","description":"# Design Language Detection Heuristics\n\n## Objective\nDesign reliable heuristics for determining the programming language of heredoc content.\n\n## Background\nTo scan heredoc content with ast-grep/tree-sitter, we need to know which language grammar to use. Language must be inferred from context clues.\n\n## Detection Sources (in priority order)\n\n### 1. Command Prefix (Most Reliable)\nMap command names to languages:\n- python, python3, python2 -\u003e Python\n- bash, sh, zsh, ksh -\u003e Bash\n- node, nodejs -\u003e JavaScript\n- ruby, irb -\u003e Ruby\n- perl -\u003e Perl\n- php -\u003e PHP\n\n### 2. Shebang Line (Heredoc Content)\nIf heredoc starts with #!, parse the interpreter:\n- #!/usr/bin/env python3 -\u003e Python\n- #!/bin/bash -\u003e Bash\n- #!/usr/bin/node -\u003e JavaScript\n\n### 3. File Extension in Command\nSome commands specify a language via temp file extension:\n- cat \u003e /tmp/script.py \u003c\u003c EOF -\u003e Python\n- This is less common but worth supporting\n\n### 4. Content Heuristics (Fallback)\nAnalyze content for language-specific patterns:\n- \"import \" at start of line -\u003e likely Python\n- \"function \" or \"const \" -\u003e likely JavaScript\n- \"def \" and \"end\" -\u003e likely Ruby\n- This is unreliable but better than nothing\n\n### 5. Configuration Override\nAllow users to specify default language for unknown heredocs.\n\n## Design Considerations\n\n### Ambiguity Handling\n- What if detection is uncertain?\n- Should we scan with multiple grammars?\n- Should we skip uncertain content?\n\n### Performance\n- Command prefix lookup should be O(1) hash map\n- Shebang detection is simple string parsing\n- Content heuristics should be bounded (first 10 lines)\n\n### Extensibility\n- Users should be able to add custom command-\u003elanguage mappings\n- New languages should be easy to add\n\n## Deliverables\n- Language detection algorithm specification\n- Command-to-language mapping table\n- Fallback strategy for unknown languages\n- Configuration schema for custom mappings\n\n## Success Criteria\n- Correctly identify language for 95%+ of real-world heredocs\n- Graceful degradation for unknown languages\n- Configuration mechanism for edge cases","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:29:39.984610362-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:29:39.984610362-05:00","dependencies":[{"issue_id":"git_safety_guard-jfj","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:29:45.118494749-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-mcf","title":"Define JavaScript/Node destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous JavaScript/Node.js constructs within heredoc bodies.\n\n## Why This Matters\n\nNode.js heredocs (node -e, node \u003c\u003cEOF) are a significant attack vector because:\n1. Node has full filesystem and process access via built-in modules\n2. npm/npx can execute arbitrary packages\n3. child_process module provides shell execution capabilities\n\n## Pattern Categories to Define\n\n### Filesystem Operations\n- fs.rmSync, fs.rmdirSync with recursive option\n- fs.unlinkSync on critical paths\n- fs.writeFileSync overwriting system files\n- rimraf and similar destructive packages\n\n### Process Execution\n- child_process.exec, execSync, spawn, spawnSync\n- Commands piped to shell interpreters\n- process.kill on system processes\n\n### Dangerous Requires/Imports\n- require('child_process')\n- Dynamic requires with user input\n- import() with untrusted paths\n\n### Network Exfiltration\n- http/https requests to unknown endpoints\n- fs.readFileSync followed by network calls\n- Buffer manipulations for data encoding\n\n### Package Manager Abuse\n- Requiring packages that execute on install\n- npx with arbitrary package names\n- Global installs of untrusted packages\n\n## Implementation Notes\n\nJavaScript patterns need to handle:\n- CommonJS vs ES modules syntax\n- async/await patterns\n- Promise chains\n- Destructuring in imports\n- Template literals\n- eval() and Function() constructors\n\nUse tree-sitter-javascript for parsing. Consider typescript patterns separately.\n\n## Test Cases\n\nEach pattern needs tests for:\n- Various import styles (require, import, dynamic import)\n- Async vs sync API variants\n- Method chaining patterns\n- Callback vs Promise vs async/await styles\n\n## Dependencies\n\n- Pattern library structure design\n- ast-grep invocation layer\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:35:33.877595699-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:35:39.971741549-05:00","dependencies":[{"issue_id":"git_safety_guard-mcf","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:35:39.990890431-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-mcf","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:35:40.010899112-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-mvh","title":"Define Ruby destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous Ruby constructs within heredoc bodies.\n\n## Why This Matters\n\nRuby heredocs are dangerous because:\n1. Ruby has powerful metaprogramming (eval, define_method, method_missing)\n2. Backticks and system() provide easy shell access\n3. FileUtils module has destructive filesystem operations\n4. Ruby's flexibility makes static analysis challenging\n\n## Pattern Categories to Define\n\n### Shell Execution\n- Backtick commands: `dangerous command`\n- system(), exec(), spawn() calls\n- %x{} syntax for shell commands\n- Open3 module usage\n- IO.popen for process execution\n\n### Filesystem Operations\n- FileUtils.rm_rf, FileUtils.remove_dir\n- File.delete, File.unlink\n- Dir.rmdir, Dir.delete\n- Pathname#rmtree\n\n### Metaprogramming Dangers\n- eval() and instance_eval\n- send() and public_send() with dynamic methods\n- define_method with external input\n- const_get with dynamic names\n- method_missing abuse\n\n### Kernel Methods\n- Kernel.exit!, Kernel.abort\n- Kernel.load, Kernel.require with dynamic paths\n- Kernel.fork and process manipulation\n\n### Data Exfiltration\n- Net::HTTP requests\n- open-uri with external URLs\n- Socket operations\n\n## Implementation Notes\n\nRuby parsing challenges:\n- Multiple string syntaxes (', \", %, heredocs)\n- Blocks and procs as arguments\n- Method calls without parentheses\n- Symbol to proc (\u0026:method_name)\n- Duck typing makes type inference hard\n\nUse tree-sitter-ruby for parsing.\n\n## Test Cases\n\nRuby-specific test cases:\n- Block syntax variations\n- Method chaining\n- Metaprogramming patterns\n- Different string quoting styles\n\n## Dependencies\n\n- Pattern library structure design\n- ast-grep invocation layer\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:37:18.506057604-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:37:26.473732741-05:00","dependencies":[{"issue_id":"git_safety_guard-mvh","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:37:35.430025823-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-mvh","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:37:35.449812115-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-o15","title":"Design heredoc detection strategy","description":"# Design Heredoc Detection Strategy\n\n## Objective\nDesign a robust, performant strategy for detecting heredoc syntax in shell commands.\n\n## Background\nHeredocs appear in many forms across different shells and use cases. We need to detect when a command contains embedded script content that should be scanned for destructive patterns.\n\n## Heredoc Syntax Variants to Support\n\n### Bash/POSIX Shell\n- Basic: command \u003c\u003c DELIMITER ... DELIMITER\n- Quoted (no expansion): command \u003c\u003c 'DELIMITER' ... DELIMITER\n- Tab-stripped: command \u003c\u003c- DELIMITER ... DELIMITER\n- Here-string: command \u003c\u003c\u003c \"string\"\n\n### Other Shells\n- Zsh: same as bash plus \u003c\u003c~ for indentation stripping\n- Fish: different syntax entirely\n\n### Inline Scripts (not heredocs but similar)\n- Python -c \"code\"\n- node -e \"code\"\n- ruby -e \"code\"\n- perl -e \"code\"\n\n## Design Considerations\n\n### 1. Detection Approach\n- Regex-based quick check (fast, may have false positives)\n- Full parsing (accurate, slower)\n- Hybrid: regex for detection, parsing for extraction\n\n### 2. Content Extraction\n- How to correctly identify delimiter boundaries\n- Handling of quoted vs unquoted delimiters\n- Preservation of indentation for \u003c\u003c-\n\n### 3. Edge Cases\n- Nested heredocs\n- Heredocs in command substitution\n- Multiple heredocs in one command\n- Empty heredocs\n- Heredocs with special delimiters (containing quotes, spaces)\n\n### 4. Performance Budget\n- Detection should add \u003c 1ms to non-heredoc commands\n- Extraction should be \u003c 5ms for typical heredocs\n\n## Deliverables\n- Specification document with:\n  - Supported heredoc forms\n  - Detection algorithm\n  - Extraction algorithm\n  - Edge case handling\n  - Performance requirements\n\n## Success Criteria\n- Clear specification that can be implemented\n- Covers all common heredoc forms\n- Performance requirements are realistic and measurable\n\n## Dependencies\n- Benefits from ast-grep research (may inform approach)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:29:15.526903078-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:29:15.526903078-05:00","dependencies":[{"issue_id":"git_safety_guard-o15","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:29:24.626856626-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-uau","title":"Define Bash/Shell destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous Bash/Shell constructs within heredoc bodies.\n\n## Why This Matters\n\nBash heredocs are the most common attack vector because:\n1. bash -c, sh -c are extremely common command forms\n2. Shell scripts can invoke ANY system command\n3. Existing dcg regex patterns already target many shell commands - we need equivalent AST patterns\n\n## Pattern Categories to Define\n\n### File/Directory Destruction\n- recursive forced removal patterns\n- rmdir on critical directories\n- find with delete patterns\n- Wildcards in destructive contexts\n\n### Git Destructive Operations\n- hard reset patterns\n- forced clean patterns\n- force push to protected branches\n- force branch deletion\n\n### Permission/Ownership Changes\n- chmod 777 on system paths\n- chown root or changing critical file ownership\n- setfacl manipulations\n\n### System Administration\n- mkfs, fdisk, dd commands on devices\n- service/systemctl stop on critical services\n- kill -9 on system processes\n- shutdown, reboot, halt\n\n### Data Exfiltration Indicators\n- curl/wget piped to shell\n- base64 encoding of sensitive files\n- tar/zip of home directories or /etc\n\n## Implementation Notes\n\nShell parsing is complex due to:\n- Quoting rules (single, double, command substitution)\n- Variable expansion\n- Command substitution\n- Heredocs within heredocs\n- Arrays and special variables\n\nStart with tree-sitter-bash and test each pattern against real shell scripts to validate accuracy.\n\n## Test Cases\n\nEach pattern needs positive tests (should match) and negative tests (should not match) covering:\n- Common benign uses that look similar\n- Quoting variations\n- Variable indirection\n- Command aliasing\n\n## Dependencies\n\n- Pattern library structure design (how patterns are organized)\n- ast-grep invocation layer (how to run ast-grep on content)\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:34:59.51511691-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:35:04.976948155-05:00","dependencies":[{"issue_id":"git_safety_guard-uau","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:35:11.201594037-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-uau","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:35:11.220201218-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-y4j","title":"Implement heredoc content extraction","description":"# Implement Heredoc Content Extraction\n\n## Objective\nExtract the actual script content from detected heredocs for scanning.\n\n## Background\nOnce we detect a heredoc is present, we need to accurately extract its content. This is more complex than detection because we must:\n1. Identify the delimiter\n2. Find the matching end delimiter\n3. Handle quoting and expansion rules\n4. Preserve or strip indentation as appropriate\n\n## Implementation Details\n\n### Heredoc Extraction Logic\n\n```rust\npub struct HeredocContent {\n    /// The extracted script content\n    pub content: String,\n    /// Detected or inferred language\n    pub language: Option\u003cLanguage\u003e,\n    /// Original delimiter used\n    pub delimiter: String,\n    /// Whether the delimiter was quoted (no expansion)\n    pub quoted: bool,\n    /// Byte offset in original command\n    pub start_offset: usize,\n    pub end_offset: usize,\n}\n\npub fn extract_heredoc(cmd: \u0026str) -\u003e Option\u003cHeredocContent\u003e {\n    // 1. Find heredoc start pattern\n    // 2. Extract delimiter (handle quoting)\n    // 3. Find matching end delimiter\n    // 4. Extract content between\n    // 5. Apply indentation rules for \u003c\u003c-\n}\n```\n\n### Delimiter Handling\n- Unquoted: EOF, END, SCRIPT\n- Single-quoted: 'EOF', 'END'\n- Double-quoted: \"EOF\", \"END\"\n- Backtick-quoted: \\`EOF\\` (rare)\n\n### Indentation Rules\n- Standard \u003c\u003c: preserve all indentation\n- Tab-stripped \u003c\u003c-: remove leading tabs from content AND delimiter\n- Zsh \u003c\u003c~: remove common leading whitespace\n\n### Edge Cases\n- Multiple heredocs in one command\n- Nested command substitution containing heredocs\n- Empty heredocs\n- Heredocs with embedded quotes\n- Heredocs that span multiple lines of piped commands\n\n### Inline Script Extraction (Non-Heredoc)\nAlso handle -c/-e style inline scripts:\n```\npython -c \"import os; os.system('...')\"\nnode -e \"require('fs').rmSync('/')\"\n```\n\n## Files to Modify\n- New: src/heredoc/extract.rs\n- src/heredoc/mod.rs\n\n## Testing\n- Test each delimiter quoting style\n- Test \u003c\u003c, \u003c\u003c-, \u003c\u003c~ variants\n- Test inline -c/-e scripts\n- Test edge cases (empty, nested, multiple)\n- Test error handling for malformed heredocs\n\n## Dependencies\n- Implement heredoc detection (git_safety_guard-49s)\n\n## Success Criteria\n- Correctly extract content from all supported heredoc forms\n- Handle edge cases gracefully (no panics)\n- Clear error messages for malformed input","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:31:21.081724798-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:31:21.081724798-05:00","dependencies":[{"issue_id":"git_safety_guard-y4j","depends_on_id":"git_safety_guard-49s","type":"blocks","created_at":"2026-01-07T18:31:27.231452201-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-yza","title":"Epic: ast-grep Integration for Heredoc Detection","description":"# Epic: ast-grep Integration for Heredoc Detection\n\n## Problem Statement\n\nAI coding agents sometimes attempt to bypass destructive command guards by embedding dangerous commands inside heredoc scripts. The current dcg implementation only examines the top-level command, missing destructive patterns hidden within inline scripts.\n\n### Example Attack Vectors\n\nAn attacker might use Python, Bash, Node.js, or other language heredocs to embed dangerous operations that slip past the quick-reject filter. The top-level command appears benign (e.g., \"python3 \u003c\u003c EOF\") while the heredoc body contains destructive operations.\n\n## Solution Overview\n\nIntegrate ast-grep (or tree-sitter directly) to:\n1. Detect heredoc patterns in commands\n2. Extract embedded script content\n3. Parse the script according to its detected language\n4. Check for destructive patterns within the parsed AST\n5. Block if dangerous patterns are found\n\n## Why ast-grep?\n\nast-grep uses tree-sitter for parsing, providing:\n- **Structural awareness**: Understands code structure, not just text patterns\n- **Language support**: Handles Python, Bash, JavaScript, TypeScript, Ruby, Perl, and many more\n- **Pattern matching**: Powerful AST pattern matching syntax\n- **Battle-tested**: Used in production for large-scale code search and refactoring\n\n## Key Technical Challenges\n\n1. **Heredoc Syntax Variants**: Many forms exist (\u003c\u003c, \u003c\u003c-, \u003c\u003c\u003c, \u003c\u003c~, quoted vs unquoted delimiters)\n2. **Language Detection**: Must infer language from command prefix, shebang, or heuristics\n3. **Performance**: Every command passes through dcg; parsing must be fast\n4. **Pattern Library**: Need comprehensive patterns per language for destructive operations\n5. **Obfuscation**: Attackers might use encoding, string concatenation, or indirect execution\n\n## Success Criteria\n\n- Detect and block heredoc-embedded destructive commands\n- Minimal latency impact (under 10ms for heredoc detection, under 50ms for full parsing)\n- Support Python, Bash, JavaScript/TypeScript, Ruby, Perl at minimum\n- Configurable via pack system (heredoc scanning can be enabled/disabled)\n- Comprehensive test coverage for bypass attempts\n\n## Architecture Decision\n\nWe will evaluate two integration approaches:\n1. **External binary**: Call ast-grep CLI and parse JSON output\n2. **Library integration**: Use tree-sitter Rust bindings directly\n\nThe decision will be made in the research phase based on:\n- Performance benchmarks\n- Dependency complexity\n- Maintenance burden\n- Pattern expressiveness\n\n## Out of Scope (for initial implementation)\n\n- Scanning files referenced in commands (e.g., \"bash script.sh\")\n- Deep obfuscation detection (base64, rot13, etc.)\n- Network-based command retrieval (\"curl ... | bash\" style)\n- Recursive heredoc nesting","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-07T18:28:08.502051689-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:28:08.502051689-05:00","dependencies":[{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:28:33.156627112-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:28:51.942182529-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-o15","type":"blocks","created_at":"2026-01-07T18:29:24.645603891-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-jfj","type":"blocks","created_at":"2026-01-07T18:29:45.137126036-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:30:14.545375401-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-5ib","type":"blocks","created_at":"2026-01-07T18:30:37.534882086-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-49s","type":"blocks","created_at":"2026-01-07T18:31:06.013753048-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T18:31:27.250568872-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T18:31:58.344341425-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:32:32.951489053-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-beq","type":"blocks","created_at":"2026-01-07T18:34:20.619502644-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-uau","type":"blocks","created_at":"2026-01-07T18:35:11.238168575-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-mcf","type":"blocks","created_at":"2026-01-07T18:35:40.032362893-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-2cu","type":"blocks","created_at":"2026-01-07T18:37:03.035457423-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-26f","type":"blocks","created_at":"2026-01-07T18:37:34.31174363-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-mvh","type":"blocks","created_at":"2026-01-07T18:37:35.469733942-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-2d4","type":"blocks","created_at":"2026-01-07T18:37:37.404070403-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-boy","type":"blocks","created_at":"2026-01-07T18:39:09.216578116-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T18:39:24.548074304-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-8wt","type":"blocks","created_at":"2026-01-07T18:40:16.23083852-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-4o8","type":"blocks","created_at":"2026-01-07T18:40:53.391076545-05:00","created_by":"ubuntu"}]}
